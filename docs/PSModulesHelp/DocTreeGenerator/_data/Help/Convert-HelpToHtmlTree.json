{
  "Synopsis": "Generates API documentation in HTML format for one or more PowerShell namespaces.",
  "Description": "Convert-HelpToHtmlTree generates a complete API in HTML format (similar to Sandcastle for .NET or javadoc for Java) for your PowerShell libraries. As with an API documentation generator for any language, the output you get is only as good as the input you provide. But Convert-HelpToHtmlTree needs little additional information than good coding practice already dictates. If you have designed your modules to display proper help when you invoke the standard Get-Help cmdlet you have already done most everything you need to use Convert-HelpToHtmlTree. If you run Convert-HelpToHtmlTree with totally undecorated source files it will generate the full API tree, but instead of detailed descriptions of each function in your library you will get only a concise syntax diagram--just as Get-Help would do. With Convert-HelpToHtmlTree, you will also get a slew of warning messages telling you what key pieces of documentation you are missing.\n\nConvert-HelpToHtmlTree supports PowerShell scripted modules (those written in PowerShell) as well as PowerShell binary modules (those written in C#).\n\nTo get started with decorating your scripted modules properly for Get-Help and Convert-HelpToHtmlTree, start with the PowerShell help topic \"about_Comment_Based_Help\".  Scroll down to the \"Syntax for Comment-Based Help in Functions\" section.  Note that the page also talks about adding help for the script itself; that applies only to main scripts (ps1 files) not to modules (psm1 files). Convert-HelpToHtmlTree works only with modules, not with scripts. Best practices dictate that for any substantive code, you will want to use modules in any case. And be sure to use Export-ModuleMember to explicitly specify which functions are public functions within your module; omitting it makes *all* your functions public by default.\n\nTo get started with decorating your binary modules, you need to do an additional step of preparing a help file for PowerShell to consume. If you use the open-source XmlDoc2CmdletDoc utility, the process is very easy: you decorate your C# code like your PowerShell code, then run one command and you're done. (There are a variety of other tools out there that are much more manual in terms of hand-crafting a MAML file.) See my reference and tutorial on XmlDoc2CmdletDoc at https://www.simple-talk.com/dotnet/software-tools/documenting-your-powershell-binary-cmdlets/.\n\nYou specify (via the Namespaces parameter) which PowerShell modules to document. The modules must be installed as user modules (i.e. in C:\\Users\\username\\Documents\\WindowsPowerShell\\Modules) rather than system modules (i.e. C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\Modules).  See \"Storing Modules on Disk\" at http://msdn.microsoft.com/en-us/library/dd878324%28v=vs.85%29.aspx as well as \"Installing Modules\" in my Simple-Talk.com article at http://www.simple-talk.com/dotnet/.net-tools/further-down-the-rabbit-hole-powershell-modules-and-encapsulation/#seventh.\n\nSee my article \"How To Document Your PowerShell Library\" at https://www.simple-talk.com/sysadmin/powershell/how-to-document-your-powershell-library/ for a walk-through of using Convert-HelpToHtmlTree.\n\nFor simplicity, the discussion below focuses on cmdlets written in PowerShell, but the concepts map directly to doc-comments in your C# code as well.\n\n==== File Organization ====\n\nConvert-HelpToHtmlTree needs some additional doc-comments to generate a cohesive API for you.\n  (1) Each module (x.psm1 or x.dll) must have an associated manifest (x.psd1) in the same directory and the manifest must include a Description property.\n  (2) Each module must have an associated overview (module_overview.html) in the same directory. This is a standard HTML file, i.e., it must have an <html> element containing a <body> element containing some container element. The contents of the <body> element are extracted verbatim as the introductory text of the index.html page for each module.\n  (3) Each namespace must also include an associated overview (namespace_overview.html).  This is a standard HTML file, i.e., it must have an <html> element containing a <body> element containing some container element.  The contents of the <body> element are extracted verbatim as the introductory text of each namespace in the master index.html page.\n\nNote that I use the term \"namespace\" here informally because (as of v3) PowerShell does not yet have the notion of namespaces.  Convert-HelpToHtmlTree, however, requires you to structure your modules grouped in namespaces as shown in the sample input tree below.  Thus, if you have a module MyStuff.psm1, normal PowerShell conventions require you to store this in a path like this:\n\n\t...\\WindowsPowerShell\\Modules\\MyStuff\\MyStuff.psm1\n\n...but Convert-HelpToHtmlTree requires you to include one more level for namespace, so the module must be stored in a path like this:\n\n\t...\\WindowsPowerShell\\Modules\\MyNamespace\\MyStuff\\MyStuff.psm1\n\nThis allows you to organize your modules into more than one logical group if desired. In my own PowerShell library, for example, I have FileTools, SqlTools, and SvnTools modules (among others) all under the CleanCode namespace. But you may, however, include multiple namespaces.\n\nHere's a sample input tree illustrating this:\n\t==========================================\n\tWindowsPowerShell\\Modules\n\t+---namespace1\n\t\t+---namespace_overview.html\n\t\t+---moduleA\n\t\t\t+---module_overview.html\n\t\t\t+---moduleA.psm1\n\t\t\t+---moduleA.psd1\n\t\t+---moduleB\n\t\t\t+---module_overview.html\n\t\t\t+---moduleB.psm1\n\t\t\t+---moduleB.psd1\n\t\tetc...\n\t+---namespace2\n\t\t+---namespace_overview.html\n\t\t+---moduleX\n\t\t\t+---module_overview.html\n\t\t\t+---moduleX.psm1\n\t\t\t+---moduleX.psd1\n\t\t+---moduleY\n\t\t\t+---module_overview.html\n\t\t\t+---moduleY.psm1\n\t\t\t+---moduleY.psd1\n\t\tetc...\n\t==========================================\n\nThe output structure mirrors the input structure; the above input might generate the output tree shown below. There is a single master index page documenting all namespaces.\n\t==========================================\n\t$TargetDir\n\t+---contents.html\n\t+---index.html\n\t+---namespace1\n\t\t+---moduleA\n\t\t\t+---index.html\n\t\t\t+---Function1.html\n\t\t\t+---Function2.html\n\t\t\t+---Function3.html\n\t\t\t+---Function4.html\n\t\t\tetc...\n\t\t+---moduleB\n\t\t\t+---index.html\n\t\t\t+---Function1.html\n\t\t\t+---Function2.html\n\t\t\tetc...\n\t+---namespace2\n\t\t+---moduleX\n\t\t\t+---index.html\n\t\t\t+---Function1.html\n\t\t\tetc...\n\t\t+---moduleY\n\t\t\t+---index.html\n\t\t\t+---Function1.html\n\t\t\t+---Function2.html\n\t\t\tetc...\n\tetc...\n\t==========================================\n\nConvert-HelpToHtmlTree reports its progress as it runs, indicating each module and each function it is documenting. Any detected problems are comingled in this output report. Here is a portion of a run on my CleanCode library (with selected parts removed to force problems to be reported): \n\t==========================================\n\tModule: Assertion\n\t\tCommand: Assert-Expression\n\t\tCommand: Get-AssertCounts\n\t\tCommand: Set-AbortOnError\n\t\tCommand: Set-MaxExpressionDisplayLength\n\tModule: DocTreeGenerator\n\t\tCommand: Convert-HelpToHtmlTree\n\t** Missing summary (from module_overview.html)\n\t** Missing description (from manifest)\n\tModule: EnhancedChildItem\n\t\tCommand: Get-EnhancedChildItem\n\t** Missing summary (from module_overview.html)\n\tModule: Miscellaneous\n\t** No objects found\n\tModule: FileTools\n\t\tCommand: Get-IniFile\n\tetc...\n\t==========================================\n\nAt the end of the run it also reports the number of namespaces, modules, functions, and total files processed.\n\n==== Documentation Template ====\n\nTake a look at the default template (see TemplateName parameter) and you will find it sprinkled with place holders that are automatically filled in at runtime (surrounded by braces): title, subtitle, breadcrumbs, preamble, body, postscript, copyright, and revdate.  Also, there are module-specific place holders of the form {module.propertyname} where \"propertyname\" may be any of the standard properties of a module -- use this to see the list of properties:\n\tGet-Module | Get-Member\n\nYou will also see conditional section definitions of the form \n\t{ifdef pagetype}\n\t. . .\n\t{endif pagetype}\n...where \"pagetype\" may be any of the four types of pages created: \n+ the single master page (pagetype=\"master\"),\n+ the single contents page (\"contents\"),\n+ the module index pages, one per module (\"module\"), and\n+ the function pages, one per exported function (\"function\").\n\nThe content of these conditional sections (which may be any HTML) is included only on the pages of the corresponding type, while the other conditional sections are suppressed.  Note that the module-specific place holders discussed earlier (e.g. {module.xyz}) may be used in module pages or function pages only.\n\n==== Output Enhancements: Live links ====\n\nUnlike the MSDN pages for the standard PowerShell library, output generated by Convert-HelpToHtmlTree  makes live links in your references (.LINK) documentation section.  There are seven classes of input you can specify, shown below.  In order, they are MSDN-defined (built-in) cmdlet, MSDN-defined (built-in) topic, custom function in the same module, custom function in a different local module, plain text, explicit link with a label, and explicit link without a label.\n\n\tGet-ChildItem\n\tabout_Aliases\n\tNew-CustomFunctionInSameModule\n\tNew-CustomFunctionInOtherModule\n\tsome plain text here\n\t[other important stuff] (http://foobar.com)\n\thttp://alpha/beta/\n\nThis output is generated from the above input:\n\n\t<ul>\n\t<li><a href='http://technet.microsoft.com/en-us/library/dd347686.aspx'>Get-ChildItem</a></li>\n\t<li><a href='http://technet.microsoft.com/en-us/library/dd347645.aspx'>about_Aliases</a></li>\n\t<li><a href='New-CustomFunctionInSameModule.html'>New-CustomFunctionInSameModule</a></li>\n\t<li><a href='../../namespace/module/New-CustomFunctionInOtherModule.html'>New-CustomFunctionInOtherModule</a></li>\n\t<li>some plain text here</li>\n\t<li><a href='http://foobar.com'>other important stuff</a></li>\n\t<li><a href='http://alpha/beta/'>http://alpha/beta/</a></li>\n\t</ul>\n\nThe MSDN references are retrieved automatically from two fixed MSDN reference pages (one for cmdlets and one for \"about\" topics).  If those fixed references ever change URLs, that will break the generator; update those URLs in the Get-CmdletDocLinks function to mend it.\nNote that if you get just plain text with no hyperlink for any of the first four classes of input, chances are you have a typo, because the function or topic could not be found.\n\n==== Output Enhancements: Formatting ====\n\nConvert-HelpToHtmlTree also adds some simple CSS styling to the generated web pages, making the generated web pages much more user-friendly than the plain mono-spaced text output of Get-Help viewed in a PowerShell window. Viewing help from within Show-Command is only minimally better than Get-Help, adding some bold markup. Convert-HelpToHtmlTree, on the other hand:\n+ Adds section headings to each of the main sections within help.\n+ Outputs most text in proportional font, automatically flowing lines and wrapping at your browser width.\n+ Outputs portions of text you designate in a fixed-width font; simply start a line with 4 spaces for this (useful typically for code samples).\n+ Recognizes simple lists; any line beginning with an asterisk, plus, or minus will force a line break.\n+ Recognizes simple headers; any line beginning or ending with a run of 4 of any of these characters (=_+*#~-) will be emboldened and force a line break.\n+ Stylizes the syntax section with bold and italics for easier visual recognition.\n+ Highlights initial code sample in each example.\n\nOn that last point, the code sample is by convention just the first line of text in your example block, ending with a carriage return. But what if your example cmdlet takes six arguments and you have a really long line?  You could break that up into smaller lines with PowerShell's line continuation character, the backtick.  Convention, though (as defined by how the .NET cmdlets do it), is to always put a single example command on one line, and let the window width determine where the line wraps.  DocTreeGenerator, however, provides the flexibility to handle multiple lines if you really want to break a line with backticks. Actually, it just coincidentally supports backticks; support for a multiple-line example was added to accommodate two other use cases: pipes in your example and multiple commands in your example. That is, one could argue that it is easier to digest this:\n\tGet-Something -a 1 -b 2 -c 3 |\n\tGet-Something Else |\n\tGet-MoreStuff\n\nthan this:\n\tGet-Something -a 1 -b 2 -c 3 | Get-Something Else | Get-MoreStuff\n\nThe trick to get the HTML to have those line breaks is simply to add one to three leading spaces to the lines after the first line (if you go to four spaces, then it becomes a pre-formatted block).\n\nAnd similarly, you might prefer this:\n\tPS> Get-Something -a 1 -b 2 -c 3\n\tPS> Get-Something Else\n\ninstead of this:\n\tPS> Get-Something -a 1 -b 2 -c 3; Get-Something Else\n\nIf you use the canonical \"PS>\" prompt in your example, you do not need the leading spaces; it recognizes the prompt.",
  "Parameters": [
    {
      "Name": null,
      "Type": null,
      "Description": "",
      "Required": false,
      "Position": 0,
      "Aliases": null,
      "DefaultValue": null,
      "Globbing": false,
      "PipelineInput": null,
      "variableLength": false
    }
  ],
  "Notes": [
    null
  ],
  "CommandType": "Function",
  "Component": [
    null
  ],
  "Inputs": [
    "None. You cannot pipe objects to Convert-HelpToHtmlTree."
  ],
  "Outputs": [
    "None. Convert-HelpToHtmlTree does not generate any output."
  ],
  "Links": [
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Examples": [
    {
      "Title": "EXAMPLE 1",
      "Markdown": "",
      "Code": "Convert-HelpToHtmlTree -Namespaces \"MyPsEnhancements\" -TargetDir \"API\"\r\nGenerates documentation for the modules under\r\n...\\My Documents\\WindowsPowerShell\\Modules\\MyPsEnhancements to the relative path \"API\"\r\nusing the default template, omitting replacement values for DocTitle, Copyright, or RevisionDate."
    },
    {
      "Title": "EXAMPLE 2",
      "Markdown": "",
      "Code": "Convert-HelpToHtmlTree -Namespaces \"Html\",\"Files\" -TemplateName \"C:\\myfiles\\psdoc_template.html\" -TargetDir \"c:\\temp\\psdoc_tmp\" -DocTitle 'PowerShell Libraries v1.5.1 API' -Copyright '2011' -RevisionDate '2011.12.13'\r\nThis uses ...\\My Documents\\WindowsPowerShell\\Modules\\Html and\r\n...\\My Documents\\WindowsPowerShell\\Modules\\Files as source namespaces and\r\ngenerates output into c:\\temp\\psdoc_tmp.  The pages use the specified template\r\nrather than the default template.  Values are given for the document title/home\r\npage header, the copyright date and the revision date."
    },
    {
      "Title": "EXAMPLE 3",
      "Markdown": "",
      "Code": "Convert-HelpToHtmlTree * API\r\nScans all namespace-aware directories under ...\\WindowsPowerShell\\Modules\r\nand generates documentation for them in a local subdirectory called API."
    }
  ]
}