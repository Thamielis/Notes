Invoke-IfDebug
--------------

### Synopsis
Invokes a series of commands when in debug mode and sends any output those commands generate to the debug stream.

---

### Description

The ifdebug command invokes a series of commands when in debug mode and sends any output that those commands generate to the debug stream.

You can use the ifdebug command in a pipeline to output debug information related to objects as they are passed through the pipeline. When debug mode is disabled, the objects will simply be passed through without the debug commands being invoked.

In order to enable debug mode in PowerShell, you either need to invoke the command you want to debug with the -Debug common parameter, or you need to set $DebugPreference to any value other than Ignore or SilentlyContinue.

The ifdebug command allows command authors to include blocks of script that output debug information to the debug stream without concern that leaving those blocks of script in place will impact performance or generate confusing output when the command is used normally. This is very useful for support purposes, allowing command authors to gather very specific pieces of information during the invocation of a PowerShell command by simply instructing an end user to run the command with the -Debug switch.

---

### Examples
> EXAMPLE 1

PS C:\> function Test-Debug {
>>     [CmdletBinding()]
>>     param()
>>     ifdebug {
>>         Write-Debug 'Anything you output here is sent to the debug stream.'
>>         'Even ordinary strings and objects.'
>>         Get-Service wuauserv
>>     }
>> }
PS C:\> Test-Debug
PS C:\> Test-Debug -Debug
The first command in this example creates a function that includes some debug output. Then once that function is created, the second command invokes the function without using the -Debug parameter. No output is generated. Finally, the last command invokes the function with the -Debug parameter, and all of the output from the ifdebug block is written to the debug stream and displayed in the console.

---

### Parameters
#### **DebugScript**
The script block that will be invoked when debug mode is enabled.
When the ifdebug command is used in a pipeline, you can use the $_ or $PSItem variables to reference the current item that was just received from the previous stage in the pipeline.

|Type           |Required|Position|PipelineInput|Aliases           |
|---------------|--------|--------|-------------|------------------|
|`[ScriptBlock]`|true    |0       |false        |ScriptBlock<br/>sb|

#### **InputObject**
The object that was input to the command, either by value (using this parameter) or through the pipeline.
When ifdebug is invoked while debug mode is disabled, input objects will be passed directly through to the next stage in the pipeline without any additional processing.

|Type        |Required|Position|PipelineInput |
|------------|--------|--------|--------------|
|`[PSObject]`|false   |named   |true (ByValue)|

---

### Inputs
System.Management.Automation.PSObject

---

### Outputs
* [Management.Automation.PSObject](https://learn.microsoft.com/en-us/dotnet/api/System.Management.Automation.PSObject)

---

### Notes
The -Debug common parameter has been in PowerShell since version 1. It was originally designed to allow script authors to conditionally enter a nested prompt at a 
specific location when running a script. Using -Debug when invoking a command would result in the caller being prompted whenever a Write-Debug command was invoked. 
This would happen because $DebugPreference would be set to "Inquire" whenever -Debug was used.

While this design worked for PowerShell 1.0, it is fundamentally flawed in PowerShell 2.0 and later where breakpoint support is available. Breakpoints allow script 
authors to control when they want a script to stop execution, and stopping execution is a script author activity, not a script consumer activity. All use of 
Write-Debug inside of commands would either have to be commented out or removed entirely before a command was shipped, unless the command author wanted end users to 
deal with debug mode when they invoked a command with -Debug.

A better use case for -Debug would be to provide additional output that is useful when troubleshooting issues with a command, including object data that would 
normally not be output and that would make even a Verbose stream look busy. Unlike Verbose output, which is usually descriptive, Debug output is more often not, and 
it is only helpful to a command author when troubleshooting issues. The ifdebug command solves this need by providing a script block that will only be invoked if 
the command is either invoked with -Debug or if the $DebugPreference variable in a scope where the command is invoked is set to any value other than 
SilentlyContinue or Ignore. In these scenarios, $DebugPreference is set to Continue before the DebugScript is invoked, all output generated by the DebugScript is 
written to the Debug stream, and then $DebugPreference is set back to its original value once the DebugScript has completed. With this model, there is no need to 
remove an ifdebug command invocation from a script when it comes time to release it to customers.

---

### Syntax
```PowerShell
Invoke-IfDebug [-DebugScript] <ScriptBlock> [-InputObject <PSObject>] [<CommonParameters>]
```
