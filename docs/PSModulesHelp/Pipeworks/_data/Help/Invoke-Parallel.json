{
  "Synopsis": "Invokes PowerShell in parallel",
  "Description": "Invokes PowerShell in parallel and in the same proess space.  This maximizes performance for parallel execution in PowerShell, by removing the drag associated with background processes.",
  "Parameters": [
    {
      "Name": null,
      "Type": null,
      "Description": "",
      "Required": false,
      "Position": 0,
      "Aliases": null,
      "DefaultValue": null,
      "Globbing": false,
      "PipelineInput": null,
      "variableLength": false
    }
  ],
  "Notes": [
    "Invoke-Parallel is an alternative to using PowerShell workflows to run PowerShell in parallel.  \n\nBecause PowerShell workflows involve process isolation, each workflow takes up a lot of overhead for a small operation.  \n\nThis overhead is considerably increased when the workflow is expected to return information, since this information has to be deserialized and brought into the process via interprocess communication (IPC).  Doing this takes up a lot of time and requires the movement of a lot of memory, which also slows down workflows.\n\n\nInvoke-Parallel uses PowerShell RunspacePools to run code in parallel within the current process, which saves a lot of overhead."
  ],
  "CommandType": "Function",
  "Component": [
    null
  ],
  "Inputs": [
    null
  ],
  "Outputs": [
    "System.Management.Automation.PSObject"
  ],
  "Links": [
    null
  ],
  "Examples": [
    {
      "Title": "EXAMPLE 1",
      "Markdown": "",
      "Code": "1..10 | Invoke-Parallel -Command {                        \r\n    (Get-Date).ToShortTimeString() + \".\" + (Get-Date).Millisecond                        \r\n} -SliceSize 1 -MaxRunning 10"
    },
    {
      "Title": "EXAMPLE 2",
      "Markdown": "",
      "Code": "1..10 | Invoke-Parallel -Command {                        \r\n    foreach ($a in $args) {\r\n        \"$a - \" + ((Get-Date).ToShortTimeString() + \".\" + (Get-Date).Millisecond)\r\n    }\r\n}"
    }
  ]
}