Holger Schwichtenberg

###### PowerShell 7 und Windows

###### PowerShell 5

Das Praxisbuch

```
5., aktualisierte Auflage
```

Alle in diesem Buch enthaltenen Informationen, Verfahren und Darstellungen wurden
nach bestem Wissen zusammengestellt und mit Sorgfalt getestet. Dennoch sind Fehler
nicht ganz auszuschließen. Aus diesem Grund sind die im vorliegenden Buch
enthaltenen Informationen mit keiner Verpflichtung oder Garantie irgendeiner Art
verbunden. Autoren und Verlag übernehmen infolgedessen keine juristische
Verantwortung und werden keine daraus folgende oder sonstige Haung übernehmen,
die auf irgendeine Art aus der Benutzung dieser Informationen – oder Teilen davon –
entsteht.
Ebenso übernehmen Autoren und Verlag keine Gewähr dafür, dass beschriebene
Verfahren usw. frei von Schutzrechten Dritter sind. Die Wiedergabe von
Gebrauchsnamen, Handelsnamen, Warenbezeichnungen usw. in diesem Buch
berechtigt deshalb auch ohne besondere Kennzeichnung nicht zu der Annahme, dass
solche Namen im Sinne der Warenzeichen- und Markenschutz-Gesetzgebung als frei zu
betrachten wären und daher von jedermann benutzt werden düren.

Bibliografische Information der Deutschen Nationalbibliothek:
Die Deutsche Nationalbibliothek verzeichnet diese Publikation in der Deutschen
Nationalbibliografie; detaillierte bibliografische Daten sind im Internet über
[http://dnb.d-nb.de](http://dnb.d-nb.de) abrufbar.

Dieses Werk ist urheberrechtlich geschützt.
Alle Rechte, auch die der Übersetzung, des Nachdruckes und der Vervielfältigung des
Buches, oder Teilen daraus, vorbehalten. Kein Teil des Werkes darf ohne schriliche
Genehmigung des Verlages in irgendeiner Form (Fotokopie, Mikrofilm oder ein anderes
Verfahren) – auch nicht für Zwecke der Unterrichtsgestaltung – reproduziert oder unter
Verwendung elektronischer Systeme verarbeitet, vervielfältigt oder verbreitet werden.

&copy; 2022 Carl Hanser Verlag München, [http://www.hanser-fachbuch.de](http://www.hanser-fachbuch.de)
Lektorat: Sylvia Hasselbach
Copy editing: Matthias Bloch, Bochum, und Sandra Gottmann, Wasserburg
Umschlagdesign: Marc Müller-Bremer, [http://www.rebranding.de,](http://www.rebranding.de,) München
Umschlagrealisation: Max Kostopoulos
Titelmotiv: &copy; shutterstock.com/Irina Kolesnichenko

Print-ISBN: 978-3-446-47296-
E-Book-ISBN: 978-3-446-47446-
E-Pub-ISBN: 978-3-446-47574-


Inhalt

Titelei
Impressum
Inhalt
Vorwort
Über den Autor

## Teil A: PowerShell-Basiswissen

    1. Fakten zur PowerShell
        1.1 Was ist die PowerShell?
        1.2 Geschichte der PowerShell
        1.3 Welche Varianten und Versionen der PowerShell gibt es?
        1.4 Windows PowerShell versus PowerShell Core versus PowerShell 7.x
        1.5 Motivation zur PowerShell
        1.6 Betriebssysteme mit vorinstallierter PowerShell
        1.7 Support der PowerShell
        1.8 Einflussfaktoren auf die Entwicklung der PowerShell
        1.9 Anbindung an Klassenbibliotheken
        1.10 PowerShell versus WSH

    2. Erste Schritte mit der PowerShell
        2.1 Windows PowerShell herunterladen und auf anderen Windows-Betriebssystemen installieren
        2.2 Die Windows PowerShell testen
        2.3 Woher kommen die PowerShell-Befehle?
        2.4 PowerShell Community Extensions (PSCX) herunterladen und installieren
        2.5 Den Windows PowerShell-Editor "ISE" verwenden
        2.6 PowerShell 7 installieren und testen

    3. Einzelbefehle der PowerShell
        3.1 Commandlets
        3.2 Aliase
        3.3 Ausdrücke
        3.4 Externe Befehle (klassische Kommandozeilenbefehle)
        3.5 Dateinamen

    4 Hilfefunktionen
        4.1 Auflisten der verfügbaren Befehle
        4.2 Praxistipp: Den Standort eines Kommandozeilenbefehls suchen
        4.3 Anzahl der Befehle
        4.4 Volltextsuche
        4.5 Erläuterungen zu den Befehlen
        4.6 Hilfe zu Parametern
        4.7 Hilfe mit Show-Command
        4.8 Hilfefenster
        4.9 Allgemeine Hilfetexte
        4.10 Aktualisieren der Hilfedateien
        4.11 Online-Hilfe
        4.12 Fehlende Hilfetexte
        4.13 Dokumentation der .NETKlassen

    5 Objektorientiertes Pipelining
        5.1 Befehlsübersicht
        5.2 Pipeline-Operator
        5.3. NET-Objekte in der Pipeline
        5.4 Pipeline Processor
        5.5 Pipelining von Parametern
        5.6 Pipelining von klassischen Befehlen
        5.7 Zeilenumbrüche in Pipelines
        5.8 Schleifen
        5.9 Zugriff auf einzelne Objekte aus einer Menge
        5.10 Zugriff auf einzelne Werte in einem Objekt
        5.11 Methoden ausführen
        5.12 Analyse des Pipeline-Inhalts
        5.13 Filtern
        5.14 Zusammenfassung von Pipeline-Inhalten
        5.15 "Kastrierung" von Objekten in der Pipeline
        5.16 Sortieren
        5.17 Duplikate entfernen
        5.18 Gruppierung
        5.19 Objekte verbinden mit Join-String
        5.20 Berechnungen
        5.21 Zwischenschritte in der Pipeline mit Variablen
        5.22 Verzweigungen in der Pipeline
        5.23 Vergleiche zwischen Objekten
        5.24 Weitere Praxislösungen

    6 PowerShell-Skripte
        6.1 Skriptdateien
        6.2 Start eines Skripts
        6.3 Aliase für Skripte verwenden
        6.4 Parameter für Skripte
        6.5 Skripte dauerha einbinden (Dot Sourcing)
        6.6 Das aktuelle Skriptverzeichnis
        6.7 Sicherheitsfunktionen für PowerShell-Skripte
        6.8 Skripte mit vollen Rechten (Elevation)
        6.9 Blockierte PowerShell-Skripte
        6.10 PowerShell-Skripte im Kontextmenü des Windows Explorers
        6.11 Anforderungsdefinitionen von Skripten
        6.12 Skripte anhalten
        6.13 Versionierung und Versionsverwaltung von Skripten

    7 PowerShell-Skriptsprache
        7.1 Hilfe zur PowerShell-Skriptsprache
        7.2 Befehlstrennung
        7.3 Kommentare
        7.4 Variablen
        7.5 Variablenbedingungen
        7.6 Zahlen
        7.7 Zeichenketten (Strings)
        7.8 Reguläre Ausdrücke
        7.9 Datum und Uhrzeit
        7.10 Objekte
        7.11 Arrays
        7.12 ArrayList
        7.13 Assoziative Arrays (Hash-Tabellen)
        7.14 Operatoren
        7.15 Überblick über die Kontrollkonstrukte
        7.16 Bedingungen
        7.17 Unterroutinen (Prozedur/Funktionen)
        7.18 Eingebaute Funktionen
        7.19 Fehlerausgabe
        7.20 Fehlerbehandlung
        7.21 Laufzeitfehler erzeugen
        7.22 Objektorientiertes Programmieren mit Klassen

    8 Ausgaben
        8.1 Ausgabe-Commandlets
        8.2 Benutzerdefinierte Tabellenformatierung
        8.3 Benutzerdefinierte Listenausgabe
        8.4 Mehrspaltige Ausgabe
        8.5 Out-GridView
        8.6 Standardausgabe
        8.7 Einschränkung der Ausgabe
        8.8 Seitenweise Ausgabe
        8.9 Ausgabe einzelner Werte
        8.10 Details zum Ausgabeoperator
        8.11 Ausgabe von Methodenergebnissen und Unterobjekten in Pipelines
        8.12 Ausgabe von Methodenergebnissen und Unterobjekten in Zeichenketten
        8.13 Unterdrückung der Ausgabe
        8.14 Ausgaben an Drucker
        8.15 Ausgaben in Dateien
        8.16 Umleitungen (Redirection)
        8.17 Fortschrittsanzeige
        8.18 Sprachausgabe

    9 Das PowerShell-Navigationsmodell (PowerShell Provider)
        9.1 Einführungsbeispiel: Navigation in der Registrierungsdatenbank
        9.2 Provider und Laufwerke
        9.3 Navigationsbefehle
        9.4 Pfadangaben
        9.5 Beispiel
        9.6 Eigene Laufwerke definieren

    10 Fernausführung (Remoting)
        10.1 RPC-Fernabfrage ohne WS-Management
        10.2 Anforderungen an PowerShell Remoting
        10.3 Rechte für PowerShell-Remoting
        10.4 Einrichten von PowerShell Remoting
        10.5 Überblick über die Fernausführungs-Commandlets
        10.6 Interaktive Fernverbindungen im Telnet-Stil
        10.7 Fernausführung von Befehlen
        10.8 Parameterübergabe an die Fernausführung
        10.9 Fernausführung von Skripten
        10.10 Ausführung auf mehreren Computern
        10.11 Sitzungen
        10.12 Implizites Remoting
        10.13 Zugriff auf entfernte Computer außerhalb der eigenen Domäne
        10.14 Verwaltung des WS-Management-Dienstes
        10.15 PowerShell Direct für Hyper-V
        10.16 Praxislösung zu PowerShell Direct

    11 PowerShell-Werkzeuge
        11.1 PowerShell-Standardkonsole
        11.2 Windows Terminal
        11.3 Erweiterung der Konsolen
        11.4 PowerShell Integrated Scripting Environment (ISE)
        11.5 PowerShell Script Analyzer
        11.6 PowerShell Analyzer
        11.7 PowerShell Tools for Visual Studio
        11.8 PowerShell Pro Tools for Visual Studio
        11.9 Visual Studio Developer PowerShell
        11.10 NuGet Package Manager Console (PMC)
        11.11 Visual Studio Code mit PowerShell-Erweiterung
        11.12 PowerShell-Erweiterungen für andere Editoren
        11.13 PowerShell Web Access (PSWA)
        11.14 Azure Cloud Shell
        11.15 ISE Steroids
        11.16 PowerShellPlus
        11.17 PoshConsole
        11.18 PowerGUI
        11.19 PrimalScript
        11.20 CIM Explorer for PowerShell ISE

    12 Windows PowerShell Core 5.1 in Windows Nano Server
        12.1 Installation
        12.2 PowerShell-Skriptsprache
        12.3 Werkzeuge
        12.4 Fehlende Funktionen

    13 PowerShell 7 für Windows, Linux und macOS
        13.1 Motivation für den Einsatz der PowerShell 7 auf Linux und macOS
        13.2 Basis der PowerShell 7
        13.3 Identifizierung der PowerShell 7
        13.4 Funktionsumfang der PowerShell 7
        13.5 Entfallene Befehle in PowerShell 7
        13.6 Erweiterungsmodule nutzen in PowerShell 7
        13.7 Geänderte Funktionen in PowerShell 7
        13.8 Neue Funktionen der PowerShell 7
        13.9 PowerShell 7-Konsole
        13.10 Praxislösung: Fallunterscheidung für PowerShell-Varianten
        13.11 VSCode-PowerShell als Editor für PowerShell 7
        13.12 Verwendung von PowerShell 7 auf Linux und macOS
        13.13 PowerShell-Remoting via SSH
        13.14 Performance-Vorteile der PowerShell 7
        13.15 Dokumentation zur PowerShell 7
        13.16 Quellcode zur PowerShell 7

## Teil B: PowerShell-Aufbauwissen

    14 Verwendung von .NET-Klassen
        14.1. NET versus .NET Core
        14.2 Ermitteln der verwendeten .NET-Version
        14.3 .NET-Bibliotheken
        14.4 Microsoft Docs
        14.5 Überblick über die Verwendung von .NET-Klassen
        14.6 Erzeugen von Instanzen
        14.7 Parameterbehaftete Konstruktoren
        14.8 Initialisierung von Objekten
        14.9 Nutzung von Attributen und Methoden
        14.10 Statische Mitglieder in .NET-Klassen und statische .NET-Klassen
        14.11 Generische Klassen nutzen
        14.12 Zugriff auf bestehende Objekte
        14.13 Laden von Assemblies
        14.14 Liste der geladen Assemblies
        14.15 Verwenden von NuGet-Assemblies
        14.16 Objektanalyse
        14.17 Aufzählungstypen (Auflistungen/Enumerationen)

    15 Verwendung von COM-Klassen
        15.1 Unterschiede zwischen COM und .NET
        15.2 Erzeugen von COM-Instanzen
        15.3 Abruf der Metadaten
        15.4 Nutzung von Attributen und Methoden
        15.5 Liste aller COM-Klassen
        15.6 Holen bestehender COM-Instanzen
        15.7 Distributed COM (DCOM)

    16 Zugriff auf die Windows Management Instrumentation (WMI)
        16.1 Einführung in WMI
        16.2 WMI in der PowerShell
        16.3 Open Management Infrastructure (OMI)
        16.4 Abruf von WMI-Objektmengen
        16.5 Fernzugriffe
        16.6 Filtern und Abfragen
        16.7 Liste aller WMI-Klassen
        16.8 Hintergrundwissen: WMI-Klassenprojektion mit dem PowerShell-WMI-Objektadapter
        16.9 Beschränkung der Ausgabeliste bei WMI-Objekten
        16.10 Zugriff auf einzelne Mitglieder von WMI-Klassen
        16.11 Werte setzen in WMI-Objekten
        16.12 Umgang mit WMI-Datumsangaben
        16.13 Methodenaufrufe
        16.14 Neue WMI-Instanzen erzeugen
        16.15 Instanzen entfernen
        16.16 Commandlet Definition XML-Datei (CDXML)

    17 Dynamische Objekte
        17.1 Erweitern bestehender Objekte
        17.2 Komplett dynamische Objekte

    18 Einbinden von C# und Visual Basic .NET

    19 Win32-API-Aufrufe

    20 Benutzereingaben
        20.1 Read-Host
        20.2 Benutzerauswahl
        20.3 Grafischer Eingabedialog
        20.4 Dialogfenster
        20.5 Authentifizierungsdialog
        20.6 Zwischenablage (Clipboard)

    21 Fehlersuche
        21.1 Detailinformationen
        21.2 Einzelschrittmodus
        21.3 Zeitmessung
        21.4 Ablaufverfolgung (Tracing)
        21.5 Erweiterte Protokollierung aktivieren
        21.6 Script-Debugging in der ISE
        21.7 Kommandozeilenbasiertes Script-Debugging

    22 Transaktionen
        22.1 Commandlets für Transaktionen
        22.2 Start und Ende einer Transaktion
        22.3 Zurücksetzen der Transaktion
        22.4 Mehrere Transaktionen

    23 Standardeinstellungen ändern mit Profilskripten
        23.1 Profilpfade
        23.2 Ausführungsreihenfolge
        23.3 Beispiel für eine Profildatei
        23.4 Starten der PowerShell ohne Profilskripte
        
    24 Digitale Signaturen für PowerShell-Skripte
        24.1 Zertifikat erstellen
        24.2 Skripte signieren
        24.3 Verwenden signierter Skripte
        24.4 Mögliche Fehlerquellen

    25 Hintergrundaufträge ("Jobs")
        25.1 Voraussetzungen
        25.2 Architektur
        25.3 Starten eines Hintergrundauftrags
        25.4 Hintergrundaufträge abfragen
        25.5 Warten auf einen Hintergrundauftrag
        25.6 Abbrechen und Löschen von Aufträgen
        25.7 Analyse von Fehlermeldungen
        25.8 Fernausführung von Hintergrundaufträgen
        25.9 Praxislösung: Einen Job auf mehreren Computern starten
    
    26 Geplante Aufgaben und zeitgesteuerte Jobs
        26.1 Geplante Aufgaben (Scheduled Tasks)
        26.2 Zeitgesteuerte Jobs
    
    27 PowerShell-Workflows
        27.1 Ein erstes Beispiel
        27.2 Unterschiede zu einer Function bzw. einem Skript
        27.3 Einschränkungen bei Workflows
        27.4 Workflows in der Praxis
        27.5 Workflows in Visual Studio erstellen
    
    28 Ereignissystem
        28.1 WMI-Ereignisse
        28.2 WMI-Ereignisabfragen
        28.3 WMI-Ereignisse seit PowerShell 1.0
        28.4 Registrieren von WMIEreignisquellen seit PowerShell 2.0
        28.5 Auslesen der Ereignisliste
        28.6 Reagieren auf Ereignisse
        28.7 WMI-Ereignisse seit PowerShell-Version 3.0
        28.8 Registrieren von .NET-Ereignissen
        28.9 Erzeugen von Ereignissen
    
    29 Datenbereiche und Datendateien
        29.1 Datenbereiche
        29.2 Datendateien
        29.3 Mehrsprachigkeit/Lokalisierung
    
    30 Desired State Configuration (DSC)
        30.1 Grundprinzipien
        30.2 DSC für PowerShell 7
        30.3 Ressourcen
        30.4 Verfügbare DSC-Ressourcen
        30.5 Eigenschaen einer Ressource
        30.6 Aufbau eines DSC-Dokuments
        30.7 Commandlets für die Arbeit mit DSC
        30.8 Ein erstes DSC-Beispiel
        30.9 Kompilieren und Anwendung eines DSC-Dokuments
        30.10 Variablen in DSC-Dateien
        30.11 Parameter für DSC-Dateien
        30.12 Konfigurationsdaten
        30.13 Entfernen einer DSC-Konfiguration
        30.14 DSC Pull Server
        30.15 DSC-Praxislösung 1: IIS installieren
        30.16 DSC-Praxislösung 2: Soware installieren
        30.17 DSC-Praxislösung 3: Soware deinstallieren
        30.18 Realisierung einer DSC-Ressource
        30.19 Weitere Möglichkeiten
    
    31 PowerShell-Snap-Ins
        31.1 Einbinden von Snap-Ins
        31.2 Liste der Commandlets

    32 PowerShell-Module
        32.1 Überblick über die Commandlets
        32.2 Modularchitektur
        32.3 Aufbau eines Moduls
        32.4 Module aus dem Netz herunterladen und installieren mit PowerShellGet
        32.5 Module manuell installieren
        32.6 Doppeldeutige Namen
        32.7 Auflisten der verfügbaren Module
        32.8 Importieren von Modulen
        32.9 Entfernen von Modulen

    33 Ausgewählte PowerShell-Erweiterungen
        33.1 PowerShell-Module in Windows 8.0 und Windows Server 2012
        33.2 PowerShell-Module in Windows 8.1 und Windows Server 2012 R 2
        33.3 PowerShell-Module in Windows 10 und Windows Server 2019
        33.4 PowerShell Community Extensions (PSCX)
        33.5 PowerShellPack
        33.6 [http://www.IT-Visions.de:](http://www.IT-Visions.de:) PowerShell Extensions
        33.7 Quest Management Shell for Active Directory
        33.8 Microsoft Exchange Server
        33.9 System Center Virtual Machine Manager
        33.10 PowerShell Management Library for Hyper-V (pshyperv)
        33.11 PowerShell Configurator (PSConfig)
    
    34 Delegierte Administration/Just Enough Administration (JEA)
        34.1 JEA-Konzept
        34.2 PowerShell-Sitzungskonfiguration erstellen

34.3 Sitzungskonfiguration nutzen

34.4 Delegierte Administration per Webseite

35 Tipps und Tricks zur PowerShell

35.1 Alle Anzeigen löschen

35.2 Befehlsgeschichte

35.3 System- und Hostinformationen

35.4 Anpassen der Eingabeaufforderung (Prompt)


```
35.5 PowerShell-Befehle aus anderen Anwendungen
heraus starten
```
35.6 ISE erweitern

35.7 PowerShell für Gruppenrichtlinienskripte

35.8 Einblicke in die Interna der Pipeline-Verarbeitung

Teil C:PowerShell im Praxiseinsatz

36 Dateisystem

36.1 Laufwerke

36.2 Ordnerinhalte

36.3 Dateieigenschaen verändern

36.4 Eigenschaen ausführbarer Dateien

36.5 Kurznamen

36.6 Lange Pfade

36.7 Dateisystemoperationen


36.8 Praxislösung: Dateien umorganisieren

36.9 Praxislösung: Zufällige Dateisystemstruktur

erzeugen

36.10 Praxislösung: Leere Ordner löschen

36.11 Praxislösung: Geschwindigkeitsmessung des

Dateisystems (beim Kopieren von Dateien)

36.12 Einsatz von Robocopy in der PowerShell

36.13 NTFS-Komprimierung

36.14 Dateisystemkataloge

36.15 Papierkorb leeren

36.16 Dateieigenschaen lesen

36.17 Praxislösung: Fotos nach Aufnahmedatum

sortieren

36.18 Datei-Hash

36.19 Finden von Duplikaten


36.20 Verknüpfungen im Dateisystem

36.21 Komprimierung

36.22 Dateisystemfreigaben

36.23 Überwachung des Dateisystems

36.24 Dateiversionsverlauf

36.25 Windows Explorer öffnen

36.26 Windows Server Backup

37 Festplattenverschlüsselung mit BitLocker

37.1 Übersicht über das BitLocker-Modul

37.2 Verschlüsseln eines Laufwerks

38 Dokumente

38.1 Textdateien

38.2 CSV-Dateien

38.3 Analysieren von Textdateien


38.4 INI-Dateien

38.5 XML-Dateien

38.6 HTML- und Markdown-Dateien

38.7 JSON-Dateien

38.8 Binärdateien

38.9 Praxislösung: Grafikdateien verändern

38.10 Praxislösung: Drucken vieler Dateien

39 Microso Office

```
39.1 Allgemeine Informationen zur Office-
Automatisierung per PowerShell
```
```
39.2 Praxislösung: Terminserien aus Textdateien
anlegen in Outlook
```
```
39.3 Praxislösung: Outlook-Termine anhand von
Suchkriterien löschen
```
```
39.4 Praxislösung: Grafiken aus einem Word-
Dokument (DOCX) extrahieren
```

40 Datenbanken

40.1 ADO.NET-Grundlagen

40.2 Beispieldatenbank

40.3 Datenzugriff mit den Bordmitteln der PowerShell

```
40.4 Hilfsfroutinen für den Datenbankzugriff
(DBUtil.ps1)
```
40.5 Datenzugriff mit den PowerShell-Erweiterungen

40.6 Datenbankzugriff mit SQLPS

40.7 Datenbankzugriff mit SQLPSX

41 Microso-SQL-Server-Administration

```
41.1 PowerShell-Integration im SQL Server
Management Studio
```
41.2 SQL-Server-Laufwerk "SQLSERVER:"

41.3 Die SQLPS-Commandlets

41.4 Die SQL Server Management Objects (SMO)


41.5 SQLPSX

```
41.6 Microso-SQL-Server-Administration mit der
PowerShell in der Praxis
```
42 ODBC-Datenquellen

42.1 ODBC-Treiber und -Datenquellen auflisten

42.2 Anlegen einer ODBC-Datenquelle

42.3 Zugriff auf eine ODBC-Datenquelle

43 Registrierungsdatenbank (Registry)

43.1 Schlüssel auslesen

43.2 Schlüssel anlegen und löschen

43.3 Laufwerke definieren

43.4 Werte anlegen und löschen

43.5 Werte auslesen

43.6 Praxislösung: Windows-Explorer-Einstellungen


```
43.7 Praxislösung: Massenanlegen von Registry-
Schlüsseln
```
44 Computer- und

Betriebssystemverwaltung

44.1 Computerinformationen

44.2 Versionsnummer des Betriebssystems

```
44.3 Zeitdauer seit dem letzten Start des
Betriebssystems
```
44.4 BIOS- und Startinformationen

44.5 Windows-Produktaktivierung

44.6 Umgebungsvariablen

44.7 Schriarten

44.8 Computername und Domäne

44.9 Herunterfahren und Neustarten

44.10 Windows Updates installieren


44.11 Wiederherstellungspunkte verwalten

45 Windows Defender

46 Hardwareverwaltung

46.1 Hardwarebausteine

46.2 Plug-and-Play-Geräte

46.3 Druckerverwaltung (ältere Betriebssysteme)

```
46.4 Druckerverwaltung (seit Windows 8 und
Windows Server 2012)
```
47 Sowareverwaltung

47.1 Sowareinventarisierung

47.2 Installation von Anwendungen

47.3 Deinstallation von Anwendungen

47.4 Praxislösung: Installationstest

47.5 Praxislösung: Installierte .NET SDKs aufräumen


47.6 Windows 10 Apps verwalten

```
47.7 Installationen mit PowerShell Package
Management ("OneGet")
```
47.8 Versionsnummer ermitteln

47.9 Servermanager

```
47.10 Windows-Features installieren auf Windows-
Clientbetriebssystemen
```
47.11 Praxislösung: IIS-Installation

```
47.12 Sowareeinschränkungen mit dem PowerShell-
Modul "AppLocker"
```
48 Prozessverwaltung

48.1 Prozesse auflisten

48.2 Prozesse starten

48.3 Prozesse mit vollen Administratorrechten starten

```
48.4 Prozesse unter einem anderen Benutzerkonto
starten
```

48.5 Prozesse beenden

48.6 Warten auf das Beenden einer Anwendung

49 Windows-Systemdienste

49.1 Dienste auflisten

49.2 Dienstzustand ändern

49.3 Diensteigenschaen ändern

49.4 Dienste hinzufügen

49.5 Dienste entfernen

50 Netzwerk

50.1 Netzwerkkonfiguration

50.2 DNS-Client-Konfiguration

50.3 DNS-Namensauflösung

50.4 Erreichbarkeit prüfen (Ping)

50.5 Windows Firewall


50.6 Remote Desktop (RDP) einrichten

50.7 E-Mails senden (SMTP)

50.8 Auseinandernehmen von E-Mail-Adressen

50.9 Abruf von Daten von einem HTTP-Server

50.10 Praxislösung: Linkprüfer für eine Website

50.11 Aufrufe von SOAP-Webdiensten

50.12 Aufruf von REST-Diensten

50.13 File Transfer Protocol (FTP)

50.14 Hintergrunddatentransfer mit BITS

51 Ereignisprotokolle (Event Log)

51.1 Protokolleinträge auslesen

51.2 Ereignisprotokolle erzeugen

51.3 Protokolleinträge erzeugen

51.4 Protokollgröße festlegen


51.5 Protokolleinträge löschen

52 Leistungsdaten (Performance Counter)

52.1 Zugriff auf Leistungsindikatoren über WMI

52.2 Get-Counter

53 Sicherheitseinstellungen

53.1 Aktueller Benutzer

53.2 Grundlagen

53.3 Zugriffsrechtelisten auslesen

53.4 Einzelne Rechteeinträge auslesen

53.5 Besitzer auslesen

53.6 Benutzer und SID

```
53.7 Hinzufügen eines Rechteeintrags zu einer
Zugriffsrechteliste
```
```
53.8 Entfernen eines Rechteeintrags aus einer
Zugriffsrechteliste
```

53.9 Zugriffsrechteliste übertragen

53.10 Zugriffsrechteliste über SDDL setzen

53.11 Zertifikate verwalten

54 Optimierungen und Problemlösungen

54.1 PowerShell-Modul "TroubleshootingPack"

54.2 PowerShell-Modul "Best Practices"

55 Active Directory

55.1 Benutzer- und Gruppenverwaltung mit WMI

55.2 Einführung in System.DirectoryServices

55.3 Basiseigenschaen

```
55.4 Benutzer- und Gruppenverwaltung im Active
Directory
```
55.5 Verwaltung der Organisationseinheiten

55.6 Suche im Active Directory


```
55.7 Navigation im Active Directory mit den
PowerShell Extensions
```
```
55.8 Verwendung der Active-Directory-Erweiterungen
von http://www.IT-Visions.de
```
```
55.9 PowerShell-Modul "Active Directory"
(ADPowerShell)
```
55.10 PowerShell-Modul "ADDSDeployment"

```
55.11 Informationen über die Active Directory-
Struktur
```
56 Gruppenrichtlinien

56.1 Verwaltung der Gruppenrichtlinien

56.2 Verknüpfung der Gruppenrichtlinien

56.3 Gruppenrichtlinienberichte

56.4 Gruppenrichtlinienvererbung

56.5 Weitere Möglichkeiten

57 Lokale Benutzer und Gruppen


57.1 Modul "Microso.PowerShell.LocalAccounts"

```
57.2 Lokale Benutzerverwaltung in älteren
PowerShell-Versionen
```
58 Microso Exchange Server

58.1 Daten abrufen

58.2 Postfächer verwalten

58.3 Öffentliche Ordner verwalten

59 Internet Information Services (IIS)

59.1 Überblick

59.2 Navigationsprovider

59.3 Anlegen von Websites

59.4 Praxislösung: Massenanlegen von Websites

59.5 Ändern von Website-Eigenschaen

59.6 Anwendungspool anlegen


59.7 Virtuelle Verzeichnisse und IIS-Anwendungen

59.8 Website-Zustand ändern

59.9 Anwendungspools starten und stoppen

59.10 Löschen von Websites

60 Virtuelle Systeme mit Hyper-V

60.1 Das Hyper-V-Modul von Microso

60.2 Die ersten Schritte mit dem Hyper-V-Modul

60.3 Virtuelle Maschinen anlegen

60.4 Umgang mit virtuellen Festplatten

60.5 Konfiguration virtueller Maschinen

60.6 Praxislösungen: Ressourcennutzung überwachen

60.7 Dateien kopieren in virtuelle Systeme

```
60.8 PowerShell Management Library for Hyper-V (für
ältere Betriebssysteme)
```

61 Windows Nano Server

61.1 Das Konzept von Nano Server

61.2 Einschränkungen von Nano Server

61.3 Varianten des Nano Servers

61.4 Installation eines Nano Servers

61.5 Docker-Image

61.6 Fernverwaltung mit PowerShell

61.7 Windows Update auf einem Nano Server

61.8 Nachträgliche Paketinstallation

61.9 Abgespeckter IIS unter Nano Server

61.10 Nano-Serververwaltung aus der Cloud heraus

62 Docker-Container

62.1 Container-Varianten für Windows


```
62.2 Docker-Installation auf aktuellem Windows 10
und Windows 11
```
```
62.3 Docker-Installation auf älteren Windows 10-
Clients
```
62.4 Docker-Installation auf Windows Server

62.5 Docker PowerShell installieren

62.6 Docker-Basiswissen

62.7 Container mit modernem .NET

```
62.8 Container mit IIS-Webserver und klassischem
ASP.NET
```
62.9 Container mit Linux und PowerShell 7

62.10 Container mit Linux und Microso SQL Server

62.11 Docker-Container mit Visual Studio

62.12 Weitere Container-Befehle

63 Microso Azure


63.1 Azure-Konzepte

```
63.2 Kommandozeilenwerkzeuge für die Azure-
Verwaltung
```
63.3 Benutzeranmeldung und Informationsabfrage

63.4 Azure Ressourcen-Gruppen

63.5 Azure Web-Apps

63.6 Azure SQL Server

63.7 Azure Kubernetes Services (AKS)

63.8 Azure DevOps (ADO)

64 Grafische Benutzeroberflächen (GUI)

64.1 Einfache Nachfragedialoge

64.2 Einfache Eingabe mit Inputbox

64.3 Komplexere Eingabemasken

64.4 Universelle Objektdarstellung


64.5 WPF PowerShell Kit (WPK)

64.6 Direkte Verwendung von WPF

Teil D: Profiwissen – Erweitern der

PowerShell

65 Unit Tests mit Pester

65.1 Einführung in das Konzept des Unit Testing

65.2 Pester installieren

65.3 Befehle in Pester

65.4 Testen einer PowerShell-Funktion

65.5 Testgenerierung

65.6 Tests starten

65.7 Prüf-Operationen

65.8 Mock-Objekte

65.9 Test von Dateisystemoperationen


66 Entwicklung von Commandlets in der

PowerShell-Skriptsprache

66.1 Aufbau eines skriptbasierten Commandlets

66.2 Verwendung per Dot Sourcing

66.3 Parameterfestlegung

66.4 Fortgeschrittene Funktion (Advanced Function)

66.5 Mehrere Parameter und Parametersätze

```
66.6 Unterstützung für Sicherheitsabfragen (-whatif
und -confirm)
```
66.7 Kaufmännisches Beispiel: Test-CustomerID

```
66.8 Erweitern bestehender Commandlets durch
Proxy-Commandlets
```
66.9 Dokumentation

67 Entwicklung eigener Commandlets mit C#

67.1 Technische Voraussetzungen


67.2 Grundkonzept der .NET-basierten Commandlets

67.3 Schrittweise Erstellung eines minimalen

Commandlets

67.4 Erstellung eines Commandlets mit einem

Rückgabeobjekt

67.5 Erstellung eines Commandlets mit mehreren

Rückgabeobjekten

67.6 Erstellen eines Commandlets mit Parametern

67.7 Verarbeiten von Pipeline-Eingaben

67.8 Verkettung von Commandlets

67.9 Fehlersuche in Commandlets

67.10 Statusinformationen

67.11 Unterstützung für Sicherheitsabfragen (-whatif

und -confirm)

67.12 Festlegung der Hilfeinformationen


```
67.13 Erstellung von Commandlets für den Zugriff auf
eine Geschäsanwendung
```
67.14 Konventionen für Commandlets

67.15 Weitere Möglichkeiten

68 PowerShell-Module erstellen

68.1 Erstellen eines Skriptmoduls

```
68.2 Praxislösung: Umwandlung einer Skriptdatei in
ein Modul
```
68.3 Erstellen eines Moduls mit Binärdateien

68.4 Erstellen eines Moduls mit Manifest

```
68.5 Erstellung eines Manifest-Moduls mit Visual
Studio
```
69 Hosting der PowerShell

69.1 Voraussetzungen für das Hosting

69.2 Hosting mit PSHost


69.3 Vereinfachtes Hosting seit PowerShell 2.0

Anhang A: Crashkurs Objektorientierung

Anhang B: Crashkurs .NET

B.1 Was ist das .NET Framework?

B.2 Was ist .NET Core/.NET?

B.3 Eigenschaen von .NET

B.4 .NET-Klassen

B.5 Namensgebung von .NET-Klassen (Namensräume)

B.6 Namensräume und Sowarekomponenten

B.7 Bestandteile einer .NET-Klasse

B.8 Vererbung

B.9 Schnittstellen

Anhang C: Weitere Informationen im

Internet


Anhang D: Abkürzungsverzeichnis


# Vorwort

Liebe Leserin, lieber Leser,

willkommen zur aktuellen Auflage meines PowerShell-Buchs! Es
handelt sich hierbei um die füne Auflage des Windows
PowerShell 5-Buches und die neunte Auflage des PowerShell-
Buches insgesamt, das erstmalig 2007 bei Addison-Wesley
erschienen ist.

## Was ist das Thema dieses Buchs?

Das vor Ihnen liegende Fachbuch behandelt die Windows
PowerShell in der Version 5.1 sowie die plattformneutrale
PowerShell 7.2 von Microso wie auch ergänzende Werkzeuge
von Microso und Drittanbietern (z. B. PowerShell Community
Extensions). Es gibt in dem Buch auch Ausblicke auf die
PowerShell 7.3, die derzeit in der Entwicklung ist.

Das Buch ist aber auch für Sie geeignet, wenn Sie noch Windows
PowerShell 2.0/3.0/4.0/5.0 oder PowerShell Core 6.x bzw.
PowerShell 7.0/7.1 einsetzen. Welche Funktionen neu
hinzugekommen sind, wird jeweils in diesem Buch erwähnt.


Wer bin ich?

Mein Name ist Holger Schwichtenberg, ich bin derzeit 49 Jahre
alt und habe im Fachgebiet Wirtschasinformatik promoviert. Ich
lebe (in Essen, im Herzen des Ruhrgebiets) davon, dass mein
Team und ich im Rahmen unserer Firma [http://www.IT-Visions.de](http://www.IT-Visions.de)
anderen Unternehmen bei der Entwicklung von .NET-, Web- und
PowerShell-Anwendungen beratend und schulend zur Seite
stehen. Zudem entwickeln wir im Rahmen der MAXIMAGO GmbH
(www.MAXI-MAGO.de) Soware im Aurag von Kunden in
zahlreichen Branchen.

Es ist nur ein Hobby, IT-Fachbücher zu schreiben, denn damit
kann man als Autor kaum Geld verdienen. Dieses Buch ist, unter
Mitzählung aller nennenswerten Neuauflagen, das 92. Buch, das
ich allein oder mit Co-Autoren geschrieben habe. Meine weiteren
Hobbys sind Mountain Biking, Fotografie und Reisen.

Natürlich verstehe ich das Bücherschreiben auch als Werbung für
die Arbeit unserer Unternehmen, und wir hoffen, dass der ein
oder andere von Ihnen uns beauragen wird, Ihre Organisation
durch Beratung, Schulung und Auragsentwicklung zu
unterstützen.

Wer sind Sie?

Damit Sie den optimalen Nutzen aus diesem Buch ziehen
können, möchte ich – so genau es mir möglich ist – beschreiben,
an wen sich dieses Buch richtet. Hierzu habe ich einen
Fragebogen ausgearbeitet, mit dem Sie schnell erkennen
können, ob das Buch für Sie geeignet ist.


Sind Sie Systemadministrator in einem Windows-
Netzwerk?

Ja Nein

Laufen die für Sie relevanten Computer mit den
von PowerShell unterstützten Betriebssystemen?
(Windows 7/8/8.1/10/11, Windows Server
2008/2008 R2/2012/2012 R2/2016/2019/2022,
macOS, Linux)

Ja Nein

Sie besitzen zumindest rudimentäre
Grundkenntnisse im Bereich des
(objektorientierten) Programmierens?

Ja Nein

Wünschen Sie einen kompakten Überblick über
die Architektur, Konzepte und Anwendungsfälle
der PowerShell?

Ja Nein

Sie können auf Schritt-für-Schritt-Anleitungen
verzichten?

Ja Nein

Sie können auf formale Syntaxbeschreibungen
verzichten und lernen lieber an aussagekräigen
Beispielen?

Ja Nein

Sie erwarten nicht, dass in diesem Buch alle
Möglichkeiten der PowerShell detailliert
beschrieben werden?

Ja Nein

Sind Sie, nachdem Sie ein Grundverständnis
durch dieses Buch gewonnen haben, bereit,
Detailfragen in der Dokumentation der
PowerShell, von .NET und WMI nachzuschlagen,

Ja Nein


```
da das Buch auf rund 1400 Seiten nicht alle Details
erläutern, sondern – in dem Sinn "Hilfe zur
Selbsthilfe" – nur ausgewählte Aspekte
darstellen kann, anhand deren Sie dann Ihre
eigenen Lösungen für Ihre spezifischen Szenarien
entwickeln?
```
Wenn Sie alle obigen Fragen mit "Ja" beantwortet haben, ist
dieses Fachbuch richtig für Sie. In anderen Fällen sollten Sie sich
erst mit einführender Literatur beschäigen.

Was ist neu in diesem Buch?

Gegenüber der vorherigen Auflage zur PowerShell
5.1/PowerShell 7.0 wurde das Buch um die neuen Commandlets,
Funktionen und Operationen in PowerShell 7.1 und 7.2 erweitert.

Zudem wurden die bestehenden Inhalte des Buchs an vielen
Stellen optimiert. Das Kapitel zu "Docker-Container" wurde in
weiten Teilen überarbeitet. Zum Dateisystem, zur
Dokumentenverarbeitung, zum Netzwerk, zu Hyper-V und zu
Azure DevOps-Pipelines habe ich Praxislösungen ergänzt.

Zudem wurde das Feedback einiger Leser eingearbeitet, um
Beispiele und Texte zu optimieren.

Sind in diesem Buch alle Features der

PowerShell beschrieben?


Die PowerShell umfasst mittlerweile mehrere Tausend
Commandlets mit jeweils zahlreichen Optionen. Zudem gibt es
unzählige Erweiterungen mit vielen Hundert weiteren
Commandlets. Außerdem existieren zahlreiche Zusatzwerkzeuge.
Es ist allein schon aufgrund der Vorgaben des Verlags für den
Umfang des Buchs nicht möglich, alle Commandlets und
Parameter hier auch nur zu erwähnen. Zudem habe ich – obwohl
ich selbst fast jede Woche mit der PowerShell in der Praxis
arbeite – immer noch nicht alle Commandlets und alle Parameter
jemals selbst eingesetzt.

Ich beschreibe in diesem Buch, was ich selbst in der Praxis, in
meinen Schulungen und bei Kundeneinsätzen verwende. Es
macht auch keinen Sinn, hier jedes Detail der PowerShell zu
dokumentieren. Stattdessen gebe ich Ihnen Hilfe zur Selbsthilfe,
damit Sie die Konzepte gut verstehen und sich dann Ihre
spezifischen Lösungen anhand der Dokumentation selbst
erarbeiten können.

Wie aktuell ist dieses Buch?

Die Informationstechnik hat sich immer schon schnell verändert.
Seit aber auch Microso die Themen "Agilität" und "Open
Source" für sich entdeckt hat, ist die Entwicklung nicht mehr nur
schnell, sondern zum Teil rasant:

```
Es erscheinen in kurzer Abfolge immer neue Produkte.
Produkte erscheinen schon in frühen Produktstadien als
"Preview" mit Versionsnummern wie 0.1.
```

```
Produkte ändern sich sehr häufig, teilweise im Abstand von
drei Wochen (z. B. Visual Studio und Azure DevOps).
Aufwärts- und Abwärtskompatibilität ist kein Ziel bei
Microso mehr. Es wird erwartet, dass Sie Ihre Lösungen
ständig den neuen Gegebenheiten anpassen.
Produkte werden nicht mehr so ausführlich dokumentiert
wie früher. Teilweise erscheint die Dokumentation erst
deutlich nach dem Erscheinen der Soware. O bleibt die
Dokumentation auch dauerha lückenha.
Produkte werden schnell auch wieder abgekündigt, wenn sie
sich aus der Sicht der Hersteller bzw. aufgrund des
Nutzerfeedbacks nicht bewährt haben.
```
```
HINWEIS: Nicht nur Microso geht so vor, sondern viele
andere Sowarehersteller (z. B. Google) agieren genauso.
```
Unter diesen neuen Einflussströmen steht natürlich auch dieses
etablierte Fachbuch. Leider kann man ein gedrucktes Buch nicht
so schnell ändern wie Soware. Verlage definieren nicht
unerhebliche Mindestauflagen, die abverkau werden müssen,
bevor neu gedruckt werden darf. Das E-Book ist keine Alternative.
Die Verkaufszahlen zeigen, dass nur eine kleine Menge von
Lesern technischer Literatur ein E-Book statt eines gedruckten
Buchs kau. Das E-Book wird offenbar nur gerne als Ergänzung
genommen. Das kann ich gut verstehen, denn ich selbst lese
auch lieber gedruckte Bücher und nutze E-Books nur für eine
Volltextsuche.


Daher kann es passieren, dass – auch schon kurz nach dem
Erscheinen dieses Buchs – einzelne Informationen in diesem
Buch nicht mehr zu neueren Versionen passen. Wenn Sie so
einen Fall feststellen, schreiben Sie bitte eine Nachricht an mich
(siehe unten). Ich werde dies dann in Neuauflagen des Buchs
berücksichtigen.

Zudem ist zu beachten, dass zwischen Abgabe des Manuskripts
beim Verlag und Auslieferung des Buchs aus der Druckerei an den
Buchhandel meist vier bis fünf Monate liegen.

Welche PowerShell-Versionen werden

besprochen?

Das Buch bespricht sowohl die Windows PowerShell 5.1 als auch
die PowerShell 7.2. Es gibt in dem Buch auch Ausblicke auf die
PowerShell 7.3, die derzeit in der Entwicklung ist.

```
Bei der Windows PowerShell 5.1 wird die RTM-Version
besprochen, die Microso in der aktuellen Version von
Windows 10/11 bzw. Windows Server 2019/2022 mitliefert.
Bei PowerShell 7.2 nutzen wir die RTM-Version vom 8.
November 2021 ein.
Bei PowerShell 7.3 gibt es zum Redaktionsschluss erst die
Version Preview 2. Die Power-Shell 7.3 wird voraussichtlich
Ende 2022 erscheinen.
```

Warum behandelt das Buch auch noch

Version 5.1 und nicht nur Version 7.2?

Windows PowerShell 5.1 ist heute in den Unternehmen in
Deutschland der Standard, denn diese Version der PowerShell
wird mit Windows 10/11 und Windows Server 2016, Windows
Server 2019 sowie Windows Server 1709, Windows Server 1909
und Windows Server 2022 ausgeliefert.

Die PowerShell 7.2 wird bisher mit keinem einzigen
Betriebssystem ausgeliefert, sondern muss getrennt
heruntergeladen und installiert werden. Eine Zusatzinstallation
ist in vielen Unternehmen mit stark abgeschotteten Systemen gar
nicht möglich.

Ein zweites Argument für die Beibehaltung der Version 5.1 in
diesem Fachbuch ist, dass die PowerShell 7.2 der Windows
PowerShell 5.1 funktional immer noch nicht ganz ebenbürtig ist.
Einige Befehle sind weiterhin nur in der Windows PowerShell
verfügbar.

Daher wird die Windows PowerShell 5.1 auch weiterhin eine
große Bedeutung haben und in diesem Buch auch weiterhin
behandelt.

Welche Betriebssysteme werden

besprochen?

Der Schwerpunkt des Buchs liegt auf der Nutzung der PowerShell
unter Windows. Es gibt Hinweise und Beispiele für die Nutzung
der PowerShell unter Linux (am Beispiel Ubuntu) und macOS.


Bei Windows gibt es Hinweise auf Unterschiede zwischen
verschiedenen Windows-Varianten (Client/Server) und Windows-
Versionen.

Auch wenn Windows 11 bereits erschienen ist, ist Windows 10
das im professionellen Einsatz vorherrschende Betriebssystem.
Das Buch geht auf existierende kleinere Unterschiede zwischen
Windows 10 und Windows 11 ein, die meisten Screenshots sind
aber mit Windows 10 gemacht. Einige Screenshots sind mit
älteren Windows-Versionen geschossen, was aber kein Problem
ist, denn inhaltlich hat sich nichts geändert (nur optisch an der
Titelleiste und der Schriart).

Woher bekommt man die Beispiele aus

diesem Buch?

Unter [http://www.powershell-doktor.de/leser](http://www.powershell-doktor.de/leser) biete ich ein
ehrenamtlich betriebenes Webportal für Leser meiner Bücher
an. Bei der Erstregistrierung müssen Sie das Losungswort Boba
Fett angeben. Nach erfolgter Registrierung erhalten Sie dann ein
persönliches Zugangskennwort per E-Mail.

In diesem Portal können Sie

```
die Codebeispiele aus diesem Buch in einem Archiv
herunterladen,
eine PowerShell-Kurzreferenz "Cheat Sheet" (zwei DIN-A4-
Seiten als Hilfe für die tägliche Arbeit) kostenlos
herunterladen sowie
Feedback zu diesem Buch geben (Bewertung abgeben und
Fehler melden).
```

Vorderseite der PowerShell-Kurzreferenz


Rückseite der PowerShell-Kurzreferenz

Alle registrierten Leser erhalten auch meinen Newsletter (zwei-
bis viermal im Jahr) mit aktuellen Produktinformationen,
Einladungen zu kostenlosen Community-Veranstaltungen sowie
Vergünstigungen bei unseren öffentlichen Seminaren zu .NET
und zur PowerShell.

Wie sind die Programmcodebeispiele

organisiert?


Die Beispiele sind in der Archivdatei (.zip) organisiert nach den
Buchteilen und innerhalb der Buchteile nach Kapitelnamen nach
folgendem Schema:

Buchteilname\Kapitelname\Dateiname

Die Namen sind zum Teil etwas verkürzt (z. B. "Einsatzgebiete"
statt "PowerShell im Praxiseinsatz"), da sich sonst zu lange
Dateinamen ergeben.

In diesem Buch wird für den Zugriff auf die Skriptdateien das x:-
Laufwerk verwendet. Bitte legen Sie entweder ein Laufwerk x: an
oder ändern Sie den Laufwerksbuchstaben in den Skripten.

Verzeichnisstruktur der Beispielsammlung mit vier Hauptordnern
entsprechend den vier Buchteilen


Inhalt eines der Hauptordner aus der vorherigen Abbildung, d. h.
eines Buchteils

Im Buch werden Sie außerdem noch Zugriffe auf ein w:-Laufwerk
finden. Dies sind Dateisystemordner mit Dokumenten, die in den
Skripten verarbeitet werden. Sofern die Dateien einen
bestimmten Inhalt haben müssen (Eingabedateien für Skripte),
dann finden Sie diese Eingabedateien auch in der Archivdatei in
dem Ordner, wo sich das Skript befindet (oder einem
Unterordner). In einigen Fällen sind die konkreten Dateiinhalte
aber gar nicht relevant (z. B. für ein Skript, das die Größen von
Dateien ermittelt). In diesem Fall können Sie anstelle des w:-
Laufwerks jedes beliebige Ihrer eigenen Laufwerke verwenden.

Warum gendern Sie nicht in diesem Buch?

Während ich in einigen Medien und Sowareprodukten (z. B.
dem virtuellen Klassenraum https://VK.IT-Visions.de) das Gendern
bereits verwende, habe ich in diesem Buch aufgrund der


Lesbarkeit und des notwendigen Umfangs der Änderungen
darauf verzichtet. Selbstverständlich spreche ich aber alle
Personen jeglichen Geschlechts gleichermaßen an.

Grundsätzlich stehe ich dem Gendern offen gegenüber, bin aber
sehr gespannt, wie sich die offiziellen Gesetzes- und
Rechtschreibregeln in den kommenden Jahren entwickeln
werden.

Wie wurde die Qualität gesichert?

Ich versichere Ihnen, dass die Befehls- und Skriptbeispiele auf
mindestens zwei meiner Systeme liefen, bevor ich sie per
Kopieren & Einfügen in das Manuskript zu diesem Buch
übernommen und auf der Leser-Website zum Download
veröffentlicht habe. Zudem haben einige Tausend Leser die
bisherigen Auflagen verwendet, und Feedback dieser Leser habe
ich in das Buch eingearbeitet.

Dennoch gibt es leider Gründe, warum die Beispiele bei Ihnen als
Leser dieses Fachbuchs nicht laufen könnten:

```
Eine abweichende Systemkonfiguration (in der heutigen
komplexen Welt der vielen Varianten und Versionen von
Betriebssystemen und Anwendungen nicht
unwahrscheinlich). Es ist einem Fachbuchautor nicht
möglich, alle Konfigurationen durchzutesten.
```

```
Änderungen, die sich seit der Erstellung der Beispiele
ergeben haben (mittlerweile gibt es sehr regelmäßig
umfangreiche Breaking Changes in den Microso-
Produkten, insbesondere beim Versionsnummernwechsel
an der ersten Stelle, d. h. Windows PowerShell 5.1 und
PowerShell 6.0 sowie PowerShell 6.2 und PowerShell 7.x).
Schließlich sind auch menschliche Fehler des Autors
möglich. Bitte bedenken Sie, dass das Fachbuchschreiben
nur ein Hobby ist. Es gibt nur sehr wenige Menschen in
Deutschland, die hauptberuflich als Fachbuchautor arbeiten
und so professionell Programmcodebeispiele erstellen und
testen können wie kommerziellen (bezahlten)
Programmcode.
```
Wenn Beispiele bei Ihnen nicht laufen, kontaktieren Sie mich
bitte mit einer sehr genauen Fehlerbeschreibung
(Systemumgebung, Skriptcode, vollständiger Fehlertext usw.).
Bitte verwenden Sie dazu das Kontaktformular auf
[http://www.powershell-doktor.de.](http://www.powershell-doktor.de.) Ich bemühe mich, Ihnen binnen zwei
Wochen zu antworten. Im Einzelfall kann es wegen dienstlicher
oder privater Abwesenheit aber auch länger dauern.

Wo kann man Verbesserungsvorschläge

melden?

Nicht nur wenn Sie Fehler in den Befehls- und Skriptbeispielen
finden, sondern auch wenn Sie allgemeine
Verbesserungsvorschläge für die nächste Auflage haben, können
Sie sich gerne bei mir melden. Vielleicht sind Ihnen noch Bugs in
der PowerShell aufgefallen? Oder Sie haben noch eine


funktionelle Anomalie der PowerShell bemerkt, die im Buch nicht
erwähnt ist? Oder es gibt ein Feature, das erwähnt werden sollte?

Es kann sein, dass ich einige Punkte bewusst weggelassen habe.
Es kann aber auch sein, dass ich diesen Bug, diese Anomalie bzw.
dieses Feature selbst noch nicht bemerkt bzw. verwendet habe.
Bitte bedenken Sie, dass kein Mensch jemals alle PowerShell-
Befehle (einige Tausend) bzw. .NET-Programmierschnittstellen
(einige Hunderttausend, wenn man alle Methoden und
Eigenschaen einzeln zählt) in der Praxis benutzt hat oder bis zu
seinem Lebensende benutzen wird.

Ich freue mich immer über konstruktives Feedback und
Verbesserungsvorschläge. Bitte verwenden Sie dazu das
Kontaktformular unter [http://www.powershell-doktor.de/Leserfeedback.](http://www.powershell-doktor.de/Leserfeedback.)

Wann wird die nächste Auflage erscheinen?

Von meinen selbst verlegten Fachbüchern sind Sie es gewohnt,
dass ich in kurzen Abständen von mehreren Wochen neue
Versionen des Buchs veröffentliche.

Bitte beachten Sie, dass ständig neue Auflagen dieses Fachbuchs
leider nicht möglich sind, da der Carl Hanser Verlag längere
Produktionsprozesse hat und Bücher auf Vorrat für einen
längeren Zeitraum druckt. Zwischen zwei Auflagen dieses Buchs
lagen in der Vergangenheit daher immer ein bis zwei Jahre.

Wo kann man sich schulen oder beraten

lassen?


Unter der E-Mail-Adresse Anfrage@IT-Visions.de stehen Ihnen
mein Team und ich für Anfragen bezüglich Schulung, Beratung
und Entwicklungstätigkeiten zur Verfügung – nicht nur zum
Thema PowerShell und .NET/.NET Core, sondern zu fast allen
modernen Techniken der Entwicklung und des Betriebs von
Soware in großen Unternehmen. Wir besuchen Sie gerne in
Ihrem Unternehmen an einem beliebigen Standort oder
unterstützen Sie per Videokonferenz.

Wem ist zu danken?

Folgenden Personen möchte ich meinen ausdrücklichen Dank für
ihre Mitwirkung an diesem Buch aussprechen:

```
meinem Kollegen Peter Monadjemi, der rund 100 Seiten mit
Beispielen zu der 3. Auflage dieses Buchs beigetragen hat
und dessen Inhalte zum Teil noch im Buch enthalten sind
(Themen: Workflows, Bitlocker, ODBC, Hyper-V, DNS-Client,
Firewall und Microso SQL Server-Administration),
meinem Kollegen André Krämer, der die PowerShell 7 auf
macOS getestet hat, da ich selbst kein macOS-Gerät besitze,
Frau Sylvia Hasselbach, die mich schon seit 20 Jahren als
Lektorin begleitet und die dieses Buchprojekt beim Carl
Hanser Verlag koordiniert und vermarktet,
Frau Sandra Gottmann, die meine Tippfehler gefunden und
sprachliche Ungenauigkeiten eliminiert hat,
```

```
den Lesern Alexander Grober und Mario Severing für ihre
ausführlichen Hinweise auf von den Korrektoren früherer
Auflagen nicht gefundene Tippfehler sowie inhaltliche
Optimierungsmöglichkeiten in der Vorauflage,
meiner Frau und meinen Kindern dafür, dass sie mir das
Umfeld geben, um neben meinem Hauptberuf an Büchern
wie diesem zu arbeiten.
```
Zum Schluss dieses Vorworts...

... wünsche ich Ihnen viel Spaß und Erfolg mit der PowerShell!

Dr. Holger Schwichtenberg

Essen, im Sommer 2022


# Über den Autor

```
Studienabschluss Diplom-Wirtschasinformatik an der
Universität Essen
Promotion an der Universität Essen im Fachgebiet
komponentenbasierter Sowareentwicklung
```

Seit 1996 in der IT tätig als Sowareentwickler,
Sowarearchitekt, Berater, Dozent und Fachjournalist

Fachlicher Leiter des Expertenteams bei [http://www.IT-Visions.de](http://www.IT-Visions.de) in

Essen Chief Technology Expert (CTE) der
Sowareentwicklung bei der MAXIMAGO GmbH in Dortmund
(www.MAXIMAGO.de)

Über 90 Fachbücher bei verschiedenen Verlagen, u. a. Carl
Hanser Verlag, O'Reilly, APress, Microso Press, Addison
Wesley sowie im Selbstverlag

Mehr als 1400 Beiträge in Fachzeitschrien und Online-
Portalen

Gutachter in den Wettbewerbsverfahren der EU gegen
Microso (2006–2009)

Ständiger Mitarbeiter der Zeitschrien iX (seit 1999),
dotnetpro (seit 2000) und Windows Developer (seit 2010)
sowie beim Online-Portal heise.de (seit 2008)

Regelmäßiger Sprecher auf nationalen und internationalen
Fachkonferenzen (z. B. enterJS, BASTA!, Microso TechEd,
Microso Summit, Microso IT Forum, OOP, IT Tage, .NET
Architecture Camp, Advanced Developers Conference,
Developer Week, DOTNET Cologne, MD DevDays,
Community in Motion, DOTNET-Konferenz, VS One,
NRW.Conf, Net.Object Days, Windows Forum, Container
Conf)

Zertifikate und Auszeichnungen von Microso:

```
Microso Most Valuable Professional (MVP),
kontinuierlich ausgezeichnet seit 2004
```

Microso Certified Solution Developer (MCSD)

Thematische Schwerpunkte:

```
Sowarearchitektur, mehrschichtige
Sowareentwicklung, Sowarekomponenten
Visual Studio, Continuous Integration (CI) und
Continuous Delivery (CD) mit Azure DevOps
Microso .NET (.NET Framework, .NET Core), C#, Visual
Basic
.NET-Architektur, Auswahl von .NET-Techniken
Einführung von .NET, Migration auf .NET
Webanwendungsentwicklung und Cross-Plattform-
Anwendungen mit HTML/CSS, JavaScript/TypeScript
und C# sowie Webframeworks wie Angular, Vue.js
ASP.NET (Core) und Blazor
Verteilte Systeme/Webservices mit .NET, insbesondere
WebAPI, gRPC und WCF
Relationale Datenbanken, XML, Datenzugriffsstrategien
Objektrelationales Mapping (ORM), insbesondere
ADO.NET Entity Framework und Entity Framework Core
PowerShell
Architektur- und Code-Reviews
Performance-Analysen und -Optimierung
Entwicklungsrichtlinien
```
Ehrenamtliche Community-Tätigkeiten:


```
Vortragender für die International .NET Association
(INETA) und .NET Foundation
Betrieb diverser Community-Websites:
http://www.dotnet-lexikon.de, http://www.dotnetframework.de,
http://www.windows-scripting.de,
http://www.aspnetdev.de u. a.
```
Firmenwebsites: [http://www.IT-Visions.de](http://www.IT-Visions.de) und [http://www.MAXIMAGO.de](http://www.MAXIMAGO.de)

Weblog: [http://www.dotnet-doktor.de](http://www.dotnet-doktor.de)

```
HINWEIS:
Kontakt für Anfragen zu Schulung und Beratung:
kundenteam@IT-Visions.de, Telefon 0201/64 95 90 –
50
Kontakt für Anfragen zu
Sowareentwicklungsprojekten:
hsc@MAXIMAGO.de
Telefon 0231/58 69 67 – 12
Kontakt für Feedback zu diesem Buch:
http://www.dotnet-doktor.de/Leserfeedback
```

# A Teil A:

# PowerShell-Basiswissen

Dieser Buchteil informiert über die Basiskonzepte der
PowerShell, insbesondere Commandlets, Pipelines, Navigation
und Skripte. Außerdem werden am Ende dieses Teils Werkzeuge
vorgestellt.


##### 1 Fakten zur PowerShell

Mit der Windows PowerShell (WPS) besitzt Microso seit dem Jahr 2006 eine
Kommandozeile, die es mit den Unix-Shells aufnehmen kann und diese in
Hinblick auf Eleganz und Robustheit in einigen Punkten auch überbieten
kann. Die PowerShell ist eine Adaption des Konzepts von Unix-Shells auf
Windows unter Verwendung des .NET Frameworks und mit Anbindung an die
Windows Management Instrumentation (WMI).

Dieses Kapitel liefert Ihnen einige wichtige Fakten, die Sie zum Verständnis
der PowerShell kennen sollten.

##### 1.1 Was ist die PowerShell?

Die PowerShell (PS) ist eine .NET-basierte Umgebung für interaktive
Systemadministration und Scripting. Während die Windows PowerShell nur
auf Windows läu, gibt es die Power-Shell seit Version 6.0 auch für Linux und
macOS.

Die Kernfunktionen der PowerShell sind:
Zahlreiche eingebaute Befehle, die "Commandlets" (o abgekürzt "Cmdlets") genannt werden
Zugang zu allen Systemobjekten, die durch COM-Bibliotheken, das .NET
Framework und die Windows Management Instrumentation (WMI)
bereitgestellt werden Robuster Datenaustausch zwischen Commandlets durch Pipelines
basierend auf typisierten Objekten. Ein einheitliches Navigationsparadigma für verschiedene Speicher (z. B. Dateisystem, Registrierungsdatenbank, Zertifikatsspeicher, Active Directory und Umgebungsvariablen) Eine einfach zu erlernende, aber mächtige Skriptsprache mit wahlweise
schwacher oder starker Typisierung Ein Sicherheitsmodell, das die Ausführung unerwünschter Skripte unterbindet Integrierte Funktionen für Ablaufverfolgung und Debugging
Die PowerShell kann um eigene Befehle erweitert werden.
Die PowerShell kann in eigene Anwendungen integriert werden
(PowerShell Hosting).

##### 1.2 Geschichte der PowerShell

Vorgänger der PowerShell sind die DOS-Eingabeaufforderung und das Active
Scripting mit Windows Script Host (WSH) und Visual Basic Script.

Das DOS-ähnliche Kommandozeilenfenster hat viele Windows-Versionen in
beinahe unveränderter Form überlebt. Es bot textbasierte
Kommandozeilenbefehle nur für einige, aber nicht alle administrativen
Aufgaben.

Das Active Scripting war einigen Administratoren zu komplex, weil es viel
Wissen über objektorientiertes Programmieren und das Component Object
Model (COM) voraussetzt. Die vielen Ausnahmen und Ungereimtheiten im
Active Scripting erschweren das Erlernen von Windows Script Host (WSH) und
der zugehörigen Komponentenbibliotheken.

Schon im Zuge der Entwicklung des Windows Server 2003 gab Microso zu,
dass man Unix-Administratoren zum Interview über ihr tägliches
Handwerkszeug gebeten hatte. Das kurzfristige Ergebnis war eine große
Menge zusätzlicher Kommandozeilenwerkzeuge. Langfristig setzt Microso
jedoch auf eine Ablösung des DOS-ähnlichen Konsolenfensters durch eine
neue Scripting-Umgebung.


Mit dem Erscheinen des .NET Frameworks im Jahre 2002 wurde lange über
einen WSH.NET spekuliert. Microso stellte jedoch die Neuentwicklung des
WSH für das .NET Framework ein, als abzusehen war, dass die Verwendung
von .NET-basierten Programmiersprachen wie C# und Visual Basic .NET dem
Administrator nur noch mehr Kenntnisse über objektorientierte
Sowareentwicklung abverlangen würde.

Microso beobachtete in der Unix-Welt eine hohe Zufriedenheit mit den
dortigen Kommandozeilen-Shells und entschloss sich daher, das Konzept der
Unix-Shells, insbesondere das Pipelining, mit dem .NET Framework
zusammenzubringen und daraus eine .NET-basierte Windows Shell zu
entwickeln. Diese sollte noch einfacher als eine Unix-Shell, aber dennoch so
mächtig wie das .NET Framework sein.

In einer ersten Beta-Version wurde die neue Shell schon unter dem
Codenamen "Monad" auf der Professional Developer Conference (PDC) im
Oktober 2003 in Los Angeles vorgestellt. Nach den Zwischenstufen "Microso
Shell (MSH)" und "Microso Command Shell" trägt die neue Skriptumgebung
seit Mai 2006 den Namen "Windows PowerShell (WPS)".

Die PowerShell 1.0 erschien am 6. 11. 2006 zeitgleich mit Windows Vista, war
aber dort nicht enthalten, sondern musste heruntergeladen und
nachinstalliert werden.

Eine Entwicklergruppe außerhalb von Microso hatte 2008 mit einer Linux-
Implementierung der PowerShell unter dem Namen "PASH" begonnen (siehe
https://github.com/Pash-Project/Pash). Dieses Projekt hatte aber in der Praxis
nie eine große Bedeutung.

Die PowerShell 2.0 ist zusammen mit Windows 7/Windows Server 2008 R 2 am

22. 7. 2009 erschienen.

Die PowerShell 3.0 ist zusammen mit Windows 8/Windows Server 2012 am

15. 8. 2012 erschienen.

Die PowerShell 4.0 ist zusammen mit Windows 8.1/Windows Server 2012 R 2
am 9. 9. 2013 erschienen.

Die PowerShell 5.0 ist als Teil von Windows 10 erschienen am 29. 7. 2015.
Abweichend von den bisherigen Gepflogenheiten ist die PowerShell 5.0 als
Erweiterung für Windows Server 2008 R 2 (mit Service Pack 1) und Windows
Server 2012/2012 R 2 erst deutlich später, am 16. 12. 2015 erschienen. Für


Windows 7 und Windows 8.1 sollte es erst gar keine Version mehr geben.
Doch am 18. 12. 2015 hatte Microso ein Einsehen mit den Kunden und
lieferte die PowerShell 5.0 auch für diese Betriebssysteme nach.
Kurioserweise musste Microso den Download dann am 23. 12. 2015 wegen
eines gravierenden Fehlers für einige Wochen vom Netz nehmen. Microso
hatte das Produkt im neuen Agilitäts-Wahn nicht richtig getestet.

Der Windows Server 2016 (erschienen am 26. 9. 2016) enthält PowerShell 5.1
und Windows 10 und wurde mit dem Windows 10 Anniversary Update
(Version 1607, Codename "Redstone 1") am 2. 8. 2016 aktualisiert.
PowerShell 5.1 ist erst seit 19. 1. 2017 als Add-on für Windows 7, Windows 8.1,
Windows Server 2008 R2, Windows 2012 und Windows 2012 R 2 verfügbar.

Eine reduzierte "Core"-Version der Windows PowerShell ist als "Windows
PowerShell Core 5.1" enthalten in Windows Nano Server, im ersten Release
2016 als Standardpaket, im zweiten in Release "1709" als Option.

Microso hat sich seit dem Jahr 2015 für andere Betriebssysteme und die
Entwicklung von "Open Source Soware" (OSS) geöffnet. Am 18. August 2016
hat Microso angekündigt, die PowerShell nun plattformunabhängig zu
entwickeln. Die PowerShell ist seitdem auch ein Open-Source-Projekt (MIT-
Lizenz), das Microso auf Github.com vor den Augen der Öffentlichkeit
entwickelt [github.com/PowerShell/PowerShell]. Die erste Version der
"PowerShell Core" (ohne Windows im Namen!) ist mit der Versionsnummer
6.0 am 20. 01. 2018 erschienen. Danach folgten die Versionen 6.1 und 6.2.

```
HINWEIS: Die Version 6.x der PowerShell trug den Namen
"PowerShell Core 6.x". Microso drückte damit aus, dass diese
Version auf .NET Core, dem plattformunabhängigen .NET Framework,
basiert, und zugleich auch, dass PowerShell Core genau wie .NET ein
Neustart der Entwicklung ist, die nicht den Anspruch hat, kompatibel
zum Vorgänger zu sein. Bei .NET hat sich Microso daher auch dazu
entschlossen, die Versionszählung wieder bei 1.0 zu beginnen. Bei
PowerShell Core setzt Microso die Versionszählung der Windows
PowerShell fort.
```

Seit Version 7.0 trägt nur noch den Namen "PowerShell" und versteht sich als
Zusammenführung von Windows PowerShell und PowerShell Core
[https://github.com/PowerShell/Power Shell/pull/ 9513 ]. Dennoch sind nicht
alle Funktionen aus der Windows PowerShell in der PowerShell 7.x enthalten.

```
HINWEIS: Während es für die Windows PowerShell 5.1 nur noch
Fehlerbehebungen und Sicherheitsupdates geben wird, arbeitet
Microso intensiv an der Weiterentwicklung der plattformneutralen
PowerShell 7.x. Die PowerShell Core 6.x wird von Microso nicht mehr
gepflegt.
```
1.3 Welche Varianten und Versionen der

PowerShell gibt es?

Es gibt mittlerweile vier Varianten der PowerShell:

```
die Windows PowerShell (in den Versionen 1.0 bis 5.1) sowie hierzu
passend den Editor Windows PowerShell Integrated Scripting
Environment (ISE)
die Windows PowerShell Core (nur Version 5.1) für Windows Nano
Server
die PowerShell Core (in den Versionen 6.0 bis 6.2)
die PowerShell (seit Version 7.0)
```

```
HINWEIS: Der Begriff "PowerShell" wird von Microso, in der
Nutzergemeinde und auch in diesem Buch nicht nur für die Versionen
ab 7.0, sondern als Oberbegriff für alle vier Varianten verwendet.
Microso fasst die Windows PowerShell und die Windows PowerShell
ISE als "Desktop Edition" zusammen und die Windows PowerShell
Core 5.1, die Power-Shell Core 6.x sowie die PowerShell 7.x als "Core
Edition".
```
1.4 Windows PowerShell versus PowerShell

Core versus PowerShell 7.x

Die Windows PowerShell 5.1 war weit mächtiger als die PowerShell Core 6.x,
weil die Power-Shell Core einen Neustart des PowerShell-
Entwicklungsprojekts im Hinblick auf Plattformunabhängigkeit darstellt. In
PowerShell Core fehlten viele Commandlets und Funktionen der
Grundausstattung der Windows PowerShell, und viele der verfügbaren
PowerShell-Erweiterungsmodule liefen nicht in der PowerShell Core.

Die PowerShell 7.x versteht sich als gemeinsamer Nachfolger von Windows
PowerShell 5.1 und PowerShell Core 6.2. Das PowerShell-Entwicklungsteam
ist damit schon Vorreiter bei der Zusammenführung von klassischer
Produktlinie und Core-Produktlinie. Analog hat das .NET-Entwicklungsteam
.NET Framework und .NET Core zu .NET vereint.

Mit PowerShell 7.0 hat sich der Funktionsabstand zur Windows PowerShell
deutlich reduziert, weil das moderne .NET, die Basis von PowerShell 6.x und
7.x, funktional stark aufgeholt hat. Aber weiterhin gilt, dass einige
Commandlets und Funktionen der Windows PowerShell sowie einige
Erweiterungsmodule nicht verfügbar sind. Und es gilt insbesondere:
PowerShell 7.x auf Linux und macOS kann weit weniger als PowerShell 7.x
auf Windows.

Details zu den Funktionseinschränkungen der PowerShell Core lesen Sie im
Kapitel "Power-Shell 7 für Windows, Linux und macOS".


```
HINWEIS: Für die meisten Windows-Administratoren wird die
Windows Power-Shell weiterhin die erste Wahl bleiben, denn diese
Variante der PowerShell ist in Windows bereits vorhanden. Es gibt nur
wenige neue Befehle in PowerShell 7.x gegenüber Windows
PowerShell 5.1, während andererseits in Version 7.x Befehle aus der
Windows PowerShell 5.1 fehlen. Der Anreiz einer Zusatzinstallation ist
also nicht sehr groß. In einigen Unternehmen sind solche
Zusatzinstallationen auf Servern auch gar nicht möglich.
```
Unter Linux und macOS gibt es keine Windows PowerShell. Hier können Sie
die PowerShell 7.x verwenden. Der Wert der PowerShell Core unter Linux und
macOS liegt in den mächtigen Pipelining- sowie Ein- und Ausgabe-
Commandlets. Für konkrete Zugriffe auf das Betriebssystem gibt es hingegen
für die PowerShell Core unter macOS und Linux noch fast keine
Commandlets. Man wird also hier immer klassische Linux- und macOS-
Kommandozeilenbefehle mit zeichenkettenbasierter Verarbeitung in die
PowerShell einbinden. Wie dies geht, wird im Kapitel "PowerShell 7 für
Windows, Linux und macOS" erklärt.


Tabelle 1.1 Vergleich der PowerShell-Varianten

```
Windows
PowerShell
```
```
Windows
PowerShell
Core
```
```
PowerShell
Core
```
```
PowerShell
```
```
Versionen 1.0 bis 5.1 5.1 6.0 bis 6.2 Ab 7.0
```
```
Edition Desktop Core Core Core
```
```
Basis .NET
Framework
```
```
.NET Core .NET Core .NET Core
(7.0) bzw.
.NET (seit
7.1)
```
```
Unterstützte
Betriebssysteme
```
```
Windows
Client ab 7,
Windows
Server ab
2012
```
```
Windows
Nano
Server
```
```
Windows,
Linux,
macOS
```
```
Windows,
Linux,
macOS
```
```
Wird
weiterentwickelt
```
```
Nein Nein Nein Ja
```
```
Start ohne
Setup
```
```
In aktuellen
Windows-
Versionen:
ja, sonst
nein
```
```
Ja in Nano
Server
```
```
Ja, möglich
(Self
Contained
App in
Archivdatei)
```
```
Ja, möglich
(Self
Contained
App in
Archivdatei)
```

Bild 1.1 Logos im Vergleich: Windows PowerShell 5.1, Windows PowerShell ISE, sowie PowerShell 7.x

1.5 Motivation zur PowerShell

Falls Sie eine Motivation brauchen, sich mit der PowerShell zu beschäigen,
wird dieses Kapitel sie Ihnen liefern. Es stellt die Lösung für eine typische
Scripting-Aufgabe sowohl im "alten" Windows Script Host (WSH) als auch in
der "neuen" PowerShell vor.

Zur Motivation, sich mit der PowerShell zu beschäigen, soll folgendes
Beispiel aus der Praxis dienen. Es soll ein Inventarisierungsskript für Soware
erstellt werden, das die installierten MSI-Pakete mit Hilfe der Windows
Management Instrumentation (WMI) von mehreren Computern ausliest und
die Ergebnisse in einer CSV-Datei (sowareinventar.csv) zusammenfasst. Die


Namen (oder IP-Adressen) der abzufragenden Computer sollen in einer
Textdatei (computernamen.txt) stehen.

Die Lösung mit dem WSH benötigt 90 Codezeilen (inklusive Kommentare und
Parametrisierungen). In der PowerShell lässt sich das Gleiche in nur 13 Zeilen
ausdrücken. Wenn man auf die Kommentare und die Parametrisierung
verzichtet, dann reicht sogar genau eine Zeile. Das PowerShell-Skript läu in
der Windows PowerShell und auch in der PowerShell 6/7 unter Windows,
aber nicht unter Linux und macOS, da es dort noch keine Implementierung
des für den Zugriff auf die installierte Soware notwendigen Web Based
Enterprise Management (WBEM) und des Common Information Model (CIM)
für die PowerShell gibt.


Listing 1.1 Sowareinventarisierung – Lösung 1 mit dem WSH
[3_Einsatzgebiete/Soware/Soware_Inventory.vbs]

```
' ------------------------------------------
' Skriptname: Software_inventar.vbs
' Autor: Dr. Holger Schwichtenberg
' ------------------------------------------
' Dieses Skript erstellt eine Liste
' der installierten Software
' ------------------------------------------
Option Explicit
```
```
' --- Einstellungen
Const Trennzeichen = ";" ' Trennzeichen für Spalten in der Ausgabedat
ei
Const Eingabedateiname = "computernamen.txt"
Const Ausgabedateiname = "softwareinventar.csv"
Const Bedingung = "SELECT * FROM Win32_Product where not Vendor like
'%Microsoft%'"
```
```
Dim objFSO ' Dateisystem-Objekt
Dim objTX ' Textdatei-Objekt für die Liste der zu durchsuchenden comp
uter
Dim i ' Zähler für Computer
Dim computer ' Name des aktuellen computers
Dim Eingabedatei' Name und Pfad der Eingabedatei
```

Dim Ausgabedatei' Name und Pfad der Ausgabedatei

' --- Startmeldung
WScript.Echo "Softwareinventar.vbs"
WScript.Echo "(C) Dr. Holger Schwichtenberg, [http://www.Windows-Scrip](http://www.Windows-Scrip)
ting.de"

' --- Global benötigtes Objekt
Set objFSO = CreateObject("Scripting.FileSystemObject")

' --- Ermittlung der Pfade
Eingabedatei = GetCurrentPfad & "\" & Eingabedateiname
Ausgabedatei = GetCurrentPfad & "\" & Ausgabedateiname

' --- Auslesen der computerliste
Set objTX = objFSO.OpenTextFile(Eingabedatei)

' --- Meldungen
WScript.Echo "Eingabedatei: " & Eingabedatei
WScript.Echo "Ausgabedatei: " & Ausgabedatei

' --- Überschriften einfügen
Ausgabe _
"computer" & Trennzeichen & _
"Name" & Trennzeichen & _
"Beschreibung" & Trennzeichen & _
"Identifikationsnummer" & Trennzeichen & _
"Installationsdatum" & Trennzeichen & _
"Installationsverzeichnis" & Trennzeichen & _
"Zustand der Installation" & Trennzeichen & _
"Paketzwischenspeicher" & Trennzeichen & _
"SKU Nummer" & Trennzeichen & _
"Hersteller" & Trennzeichen & _
"Version"

' --- Schleife über alle Computer
Do While Not objTX.AtEndOfStream


computer = objTX.ReadLine
i = i + 1
WScript.Echo "=== Computer #" & i & ": " & computer

GetInventar computer

Loop

' --- Eingabedatei schließen
objTX.Close
' --- Abschlußmeldung
WScript.echo "Softwareinventarisierung beendet!"

' === Softwareliste für einen computer erstellen
Sub GetInventar(computer)

Dim objProduktMenge
Dim objProdukt
Dim objWMIDienst

' --- Zugriff auf WMI
Set objWMIDienst = GetObject("winmgmts:" &_
"{impersonationLevel=impersonate}!\\" & computer &_
"\root\cimv2")
' --- Liste anfordern
Set objProduktMenge = objWMIDienst.ExecQuery _
(Bedingung)
' --- Liste ausgeben
WScript.Echo "Auf " & computer & " sind " & _
objProduktMenge.Count & " Produkte installiert."
For Each objProdukt In objProduktMenge
Ausgabe _
computer & Trennzeichen & _
objProdukt.Name & Trennzeichen & _
objProdukt.Description & Trennzeichen & _
objProdukt.IdentifyingNumber & Trennzeichen & _
objProdukt.InstallDate & Trennzeichen & _


objProdukt.InstallLocation & Trennzeichen & _
objProdukt.InstallState & Trennzeichen & _
objProdukt.PackageCache & Trennzeichen & _
objProdukt.SKUNumber & Trennzeichen & _
objProdukt.Vendor & Trennzeichen & _
objProdukt.Version
WScript.Echo objProdukt.Name
Next
End Sub

' === Ausgabe
Sub Ausgabe(s)
Dim objTextFile
' Ausgabedatei öffnen
Set objTextFile = objFSO.OpenTextFile(Ausgabedatei, 8, True)
objTextFile.WriteLine s
objTextFile.Close
'WScript.Echo s
End Sub

' === Pfad ermitteln. in dem das Skript liegt
Function GetCurrentPfad
GetCurrentPfad = objFSO.GetFile (WScript.ScriptFullName).ParentFolder
End Function


```
Listing 1.2 Sowareinventarisierung – Lösung 2 als PowerShell-Skript
[3_Einsatzgebiete/Soware/SowareInventory_WMI_Script.ps1]
# Einstellungen
$InputFileName = "computernamen.txt"
$OutputFileName = "softwareinventar.csv"
$Query = "SELECT * FROM Win32_Product where not Vendor like '%Microso
ft%'"
```
```
# Eingabedatei auslesen
$Computers = Get-Content $InputFileName
```
```
# Schleife über alle Computer
$Software = $Computers | foreach { Get-CimInstance -query $Query -com
putername $_ }
# Ausgabe in CSV
$Software | select Name, Description, IdentifyingNumber, InstallDate,
InstallLocation, InstallState, SKUNumber, Vendor, Version | export-cs
v
$OutputFileName -notypeinformation
```
```
Listing 1.3 Sowareinventarisierung – Lösung 3 als PowerShell-Pipeline-Befehl
[3_Einsatzgebiete/Soware/SowareInventory_WMI_Pipeline.ps1]
Get-Content "computers.txt" | foreach {Get-CimInstance -computername
$_ - query
"SELECT * FROM Win32_Product where not Vendor like '%Microsoft%'" } |
export-csv
"Softwareinventory.csv" - notypeinformation
```
1.6 Betriebssysteme mit vorinstallierter

PowerShell

Die folgende Tabelle zeigt, in welchen Betriebssystemen welche Version der
PowerShell mitgeliefert wird bzw. wo sie nachträglich installierbar ist.


Tabelle 1.2 Verfügbarkeit der PowerShell auf verschiedenen Betriebssystemen

```
Betriebssystem Mitgelieferte PowerShell- Nachträglich
installierbare
PowerShell
```
```
Windows 2000,
Windows 9 x,
Windows ME,
Windows NT 4.0
```
```
PowerShell nicht enthalten Nachträgliche
Installation nicht von
Microso unterstützt
```
```
Windows XP PowerShell nicht enthalten PowerShell 1.0 und
PowerShell 2.0
```
```
Windows Server
2003
```
```
PowerShell nicht enthalten PowerShell 1.0 und
PowerShell 2.0
```
```
Windows Server
2003 R 2
```
```
PowerShell nicht enthalten PowerShell 1.0 und
PowerShell 2.0
```
```
Windows Vista PowerShell nicht enthalten PowerShell 1.0 und
PowerShell 2.0
```
```
Windows Server
2008
```
```
PowerShell 1.0 enthalten als
optionales Feature
```
```
PowerShell 2.0,
PowerShell 3.0
```
```
Windows Server
2008 R 2
```
```
PowerShell 1.0 enthalten PowerShell 2.0,
PowerShell 3.0
```
```
Windows 7 PowerShell 2.0 enthalten PowerShell 3.0,
PowerShell 4.0,
PowerShell 5.0,
PowerShell 5.1,
PowerShell Core 6.x,
PowerShell 7
```
```
Windows Server
2008 R 2
```
```
PowerShell 2.0 enthalten PowerShell 3.0,
PowerShell 4.0,
PowerShell 5.0,
```

```
PowerShell 5.1,
PowerShell Core 6.x,
PowerShell 7
```
Windows Server
2008 Core

```
PowerShell nicht enthalten PowerShell 3.0,
PowerShell Core 6.x,
PowerShell 7
```
Windows Server
2008 R 2 Core

```
PowerShell 2.0 enthalten als
optionales Feature
```
```
PowerShell Core 6.x,
PowerShell 7
```
Windows 8.0 PowerShell 3.0 enthalten Achtung: PowerShell
4.0 und 5.0/5.1
können nur durch ein
(vorheriges) Update
auf Windows 8.1
nachgerüstet werden.

Windows Server
2012 inkl. Core

```
PowerShell 3.0 enthalten PowerShell 4.0,
PowerShell 5.0,
PowerShell 5.1,
PowerShell Core 6.x,
PowerShell 7
```
Windows 8.1 PowerShell 4.0 enthalten PowerShell 5.0,
PowerShell 5.1,
PowerShell Core 6.x,
PowerShell 7

Windows Server
2012 R 2 inkl.
Core

```
PowerShell 4.0 enthalten PowerShell 5.0,
PowerShell 5.1,
PowerShell Core 6.x,
PowerShell 7
```
Windows 10 PowerShell 5.0 enthalten PowerShell Core 6.x,
PowerShell 7

Windows 10 seit PowerShell 5.1 enthalten PowerShell Core 6.x,


Creators Update
(Redstone 2,
Version 1703,
April 2017)

```
PowerShell 7
```
Windows 11 PowerShell 5.1 enthalten PowerShell Core 6.x,
PowerShell 7

Windows Server
2016

```
PowerShell 5.1 enthalten PowerShell Core 6.x,
PowerShell 7
```
Windows Server
1709

```
PowerShell 5.1 enthalten PowerShell Core 6.x,
PowerShell 7
```
Windows Nano
Server 2016

```
Reduzierte PowerShell Core
5.1 enthalten
```
```
PowerShell Core 6.x,
PowerShell 7
```
Windows Nano
Server seit
Version 1709

```
PowerShell Core wurde aus
dem
Standardinstallationsumfang
entfernt, vgl.
docs.microso.com/de-
de/windows-server/get-
started/nano-in-semi-annual-
channel
```
```
PowerShell Core 5.1,
PowerShell Core 6.x,
PowerShell 7
```
Windows Server
2019

```
PowerShell 5.1 enthalten PowerShell Core 6.x,
PowerShell 7
```
Windows Server
2022

```
PowerShell 5.1 enthalten PowerShell Core 6.x,
PowerShell 7
```
OpenSUSE-
Linux ab Version
42.3

- PowerShell Core 6.x,
    PowerShell 7

Ubuntu-Linux
ab Version 16.04

- PowerShell Core 6.x,
    PowerShell 7


```
macOS/X ab
Version 10.12
```
- PowerShell Core 6.x,
    PowerShell 7

```
Debian ab
Version 9
```
```
PowerShell Core 6.x,
PowerShell 7
```
```
Red Hat
Enterprise Linux
(RHEL) ab
Version 7
```
```
PowerShell Core 6.x,
PowerShell 7
```
```
Fedora ab
Version 30
```
```
PowerShell Core 6.x,
PowerShell 7
```
```
CentOS ab
Version 7
```
```
PowerShell Core 6.x,
PowerShell 7
```
```
Alpine ab
Version 3.9
```
```
PowerShell 7
```
```
Raspberry Pi OS
(Raspbian) ab
Version 2
```
```
PowerShell 7
```
Es gibt außerdem noch PowerShell 7.x-Unterstützung für andere Linux-
Derivate (z. B. Kali, Arch) durch Projekte außerhalb von Microso, vgl.
https://docs.microso.com/en-us/powershell/scripting/install/community-
support]

1.7 Support der PowerShell

Ein Produkt, das von Microso offiziell als "unterstützt" gilt, bekommt
Updates für Fehler und Sicherheitslücken und die Kunden können den
technischen Support von Microso bei Problemen kontaktieren.


Die Windows PowerShell wird solange unterstützt wie das Betriebssystem,
mit dem die Power-Shell ausgeliefert wurde.

Für die moderne PowerShell gilt die "Microso Modern Lifecycle Policy"
[https://docs.microso.com/en-us/lifecycle/policies/modern]. Diese Richtlinie
unterscheidet zwischen "Long-Term-Support" (LTS) und "Current-Version",
neuerdings auch Short Term Support (STS) genannt.

Microso hat die Wartung und den Support der PowerShell Core Versionen
6.x bereits beendet.

Die Unterstützung der Version 7.x können Sie hier nachlesen:
https://docs.microso.com/en-us/powershell/scripting/install/powershell-
support-lifecycle

Bild 1.2 Unterstützung der modernen PowerShell in Windows, Stand 15. 3. 2022


Bild 1.3 Unterstützung der modernen PowerShell in macOS, Stand 15. 3. 2022

Bild 1.4 Unterstützung der modernen PowerShell in Ubuntu, Stand 15. 3. 2022

Weitere Linux-Distributionen sind hier nicht wiedergegeben, um Platz zu
sparen. Sie finden den aktuellen Status unter https://docs.microso.com/en-
us/powershell/scripting/install/powershell-support-lifecycle.


```
TIPP: Man muss immer die aktuellste Patch-Version der PowerShell
installiert haben, um Support zu bekommen!
```
1.8 Einflussfaktoren auf die Entwicklung

der PowerShell

Die PowerShell ist eine Symbiose aus:

```
dem klassischen Windows-Kommandozeilenfenster,
den bekannten Skript- und Shell-Sprachen wie Perl, Ruby, ksh und bash,
dem .NET Framework und
der Windows Management Instrumentation (WMI).
```
Die PowerShell ist implementiert auf dem .NET Framework. Sie ist jedoch
kein .NET Runtime Host mit der Möglichkeit, Befehle der Common
Intermediate Language (CIL) auf der Common Language Runtime (CLR)
auszuführen.

Die PowerShell verwendet ein völlig anderes Host-Konzept mit
Commandlets, Objekt-Pipelines und einer neuen Sprache, die von Microso
als PowerShell Language (PSL) bezeichnet wird. Sie ist Perl, Ruby, C# und
einigen Unix-Shell-Sprachen sehr ähnlich, aber mit keiner Unix-Shell
kompatibel. Nutzer der WMI Command Shell (wmic.exe), die mit Windows XP
eingeführt wurde, werden sich in der PowerShell schnell zurechtfinden.


Bild 1.5 Einflussfaktoren auf die Architektur und die Umsetzung der PowerShell

```
ACHTUNG: Die PowerShell ist angetreten, vom Administrator weniger
Kenntnisse in Objektorientierung und über Sowarekomponenten zu
verlangen, als dies der Vorgänger Windows Script Host (WSH) tat.
Tatsächlich kann man in der PowerShell viel erreichen, ohne sich mit
dem zu Grunde liegenden .NET Framework zu beschäigen. Dennoch:
Wer alle Möglichkeiten der PowerShell nutzen will, braucht dann aber
doch etwas Verständnis für objektorientiertes Programmieren und
Erfahrung mit dem .NET Framework.
Wenn Sie sich hier noch nicht auskennen, lesen Sie bitte zuerst in
diesem Buch Anhang A Crashkurs "Objektorientierung" und Anhang B
Crashkurs ".NET".
```
1.9 Anbindung an Klassenbibliotheken


Die Version 1.0 der PowerShell enthielt sehr viele Commandlets für die
Pipelining-Infrastruktur, aber nur sehr wenige Befehle, die tatsächlich
Bausteine des Betriebssystems in die Pipeline werfen. Prozesse,
Systemdienste, Dateien, Zertifikate und Registrierungsdatenbankeinträge
sind die magere Ausbeute beim ersten Blick in die Commandlet-Liste. Drei
Commandlets eröffnen der PowerShell aber neue Dimensionen: New-Object
(für .NET- und COM-Objekte) und Get-WmiObject bzw. Get-CimInstance (für
WMI-Objekte). Seit Version 2.0 gibt es – zumindest in Verbindung mit neueren
Betriebssystemen – mehr PowerShell-Befehle, die tatsächlich auf das
Betriebssystem zugreifen.

```
HINWEIS: Die Option, nicht nur alle WMI-Klassen, sondern auch alle
.NET-Klassen direkt benutzen zu können, ist Segen und Fluch
zugleich. Ein Segen, weil dem Skriptentwickler damit mehr
Möglichkeiten als jemals zuvor zur Verfügung stehen. Ein Fluch, weil
nur der Skriptentwickler die PowerShell-Entwicklung richtig
beherrschen kann, der auch das .NET Framework kennt. Um die
Ausmaße von .NET zu beschreiben, sei die Menge der Klassen
genannt. In .NET 2.0 waren es 6358, in. NET 3.5 sind es 10 758, in .NET
4.7 sind es 13 526.
```
1.10 PowerShell versus WSH

Administratoren fragen sich o, wie sich die PowerShell im Vergleich zum
Windows Script Host (WSH) positioniert, womit man neue Scripting-Projekte
beginnen sollte und ob der WSH bald aus Windows verschwinden wird. Die
folgende Tabelle trägt Fakten zusammen und bewertet auch die beiden
Scripting-Plattformen.

Tabelle 1.3 Vergleich WSH und PowerShell






# 2 Erste Schritte mit der

# PowerShell

In diesem Kapitel lernen Sie erste Schritte mit der PowerShell –
zunächst mit der Windows PowerShell 5.1 und dann mit der
plattformneutralen PowerShell 7.

## 2.1 Windows PowerShell

## herunterladen und auf anderen

## Windows-Betriebssystemen

## installieren

Die Windows PowerShell 5.1 ist in Windows 10 (ab Anniversary
Update), Windows 11 und Windows Server 2016/2019/2022
(einschließlich den Zwischenversionen 1709/1909) bereits im
Standard installiert.

Wenn Sie nicht Windows 10/11 oder einen der oben genannten
aktuellen Windows Server benutzen, müssen Sie die PowerShell


5.1 erst installieren.

Die nachträgliche Installation der Windows PowerShell 5.1 ist auf
folgenden Betriebssystemen möglich:

```
Windows Server 2012 R 2
Windows Server 2012
Windows 2008 R 2
Windows 8.1
Windows 7
```
Die Windows PowerShell 5.1 wird auf diesen Betriebssystemen
als Teil des Windows Management Framework 5.1 (WMF)
installiert [http://www.microso.com/en-
us/download/details.aspx?id= 54616 ].

Bei der Installation ist zu beachten, dass jeweils das .NET
Framework 4.5.2 oder höher vorhanden sein muss. Auch mit .NET
Framework 4.6.x und 4.7 funktioniert die PowerShell 5.1.

Das WMF-5.1-Installationspaket betrachtet sich als Update für
Windows (KB 3191566 für Windows 7 und Windows Server 2008
R 2 bzw. KB 3191564 für Windows 8.1 und Windows Server 2012 R 2
sowie KB 3191565 für Server 2012).


Bild 2.1 Installationspaket für PowerShell 5.1 als Erweiterung

Installationsordner

Die Windows PowerShell installiert sich in folgendes Verzeichnis:
%systemroot%\system 32 \WindowsPowerShell\V1.0 (für 32-Bit-
Systeme).

```
ACHTUNG: Dabei ist das V1.0 im Pfad tatsächlich richtig:
Microso hat dies seit Version 1.0 nicht verändert.
Geplant war wohl eine "Side-by-Side"-Installationsoption
wie beim .NET Framework. Doch später hat sich Microso
dazu entschieden, dass eine neue PowerShell immer die
alte überschreibt.
```
Auf 64-Bit-Systemen gibt es die PowerShell zweimal, einmal als
64-BitVersion in
%systemroot%\system 32 \WindowsPowerShell\V1.0 und einmal als
32-Bit-Version. Letztere findet man unter


%systemroot%\Syswow 64 \WindowsPowerShell\V1.0. Die 32-Bit-
Version braucht man, wenn man eine Bibliothek nutzen will, für
die es keine 64 Bit-Version gibt, z. B. für den Zugriff auf Microso-
Access-Datenbanken.

Es handelt sich auch dabei nicht um einen Tippfehler: Die 64-Bit-
Version befindet sich in einem Verzeichnis, das "32" im Namen
trägt, und die 32-Bit-Version in einem Verzeichnis mit "64" im
Namen!

Die 32-Bit-Version und die 64-Bit-Version der PowerShell sieht
man im Startmenü: Die 32-Bit-Version hat den Zusatz "(x86)". Die
64-Bit-Version hat keinen Zusatz. Auch den Editor "ISE" gibt es in
einer 32- und einer 64-Bit-Version.

Bild 2.2 PowerShell-Einträge im Windows-10-Startmenü


```
TIPP: Unter Windows 8.x empfiehlt sich der Einsatz der
Erweiterung http://www.classicshell.net, die das klassische
Startmenü in Windows 8.x zurückbringt. Der Rückgriff auf
ein Startmenü hat nicht nur mit Nostalgie zu tun, sondern
auch ganz handfeste praktische Gründe: Der
kachelbasierte Startbildschirm von Windows 8.x findet
leider zum Suchbegriff "PowerShell" weder die
PowerShell ISE noch die 32-Bit-Variante der PowerShell.
```
Bild 2.3 Versagen auf ganzer Linie: Der kachelbasierte Startbildschirm von Windows
8.x findet leider zum Suchbegriff "PowerShell" weder die ISE noch die 32-Bit-Variante
der PowerShell. Seit Windows 10 ist das behoben.

Unter Windows 8.x geht es mit Classic Shell:


Bild 2.4 Die Classic Shell findet alle Einträge zur Windows PowerShell.

Ereignisprotokoll "PowerShell"

Durch die Installation der PowerShell wird in Windows auch ein
neues Ereignisprotokoll "PowerShell" angelegt, in dem die
PowerShell wichtige Zustandsänderungen protokolliert.


Bild 2.5 Ereignisprotokoll "Windows PowerShell"

Deinstallation

Falls man die PowerShell deinstallieren möchte, muss man dies
in der Systemsteuerung unter "Programme und
Funktionen/Installierte Updates anzeigen" tun und dort das
"Microso Windows Management Framework" deinstallieren.


Bild 2.6 Deinstallation der PowerShell durch Deinstallation des WMF

###### 2.2 Die Windows PowerShell testen

Dieses Kapitel stellt einige Befehle vor, mit denen Sie die
PowerShell-Funktionalität ausprobieren können. Die PowerShell
verfügt über zwei Modi (interaktiver Modus und Skriptmodus),
die hier getrennt behandelt werden.

2.2.1 PowerShell im interaktiven Modus

Der erste Test verwendet die PowerShell im interaktiven Modus.

Starten Sie bitte die PowerShell. Es erscheint ein leeres
PowerShell-Konsolenfenster. Auf den ersten Blick ist kein großer
Unterschied zur herkömmlichen Konsole zu erkennen. Allerdings
steckt in der PowerShell mehr Kra – im wahrsten Sinne des
Wortes.


Bild 2.7 Leeres PowerShell-Konsolenfenster. Die Windows PowerShell 5.1 begrüßt
den Nutzer mit Werbung für die Nachfolger. (Der Link hat auch in einem aktuellen
Windows 10 noch "PSCore6" im Namen, wird aber umgeleitet auf PowerShell 7.
Microso hat einfach vergessen, den Link via Windows Update zu aktualisieren.)

Bild 2.8 In Windows 11 ist der Link geändert, führt aber auch nicht zur Startseite von
PowerShell 7, sondern zu einem Migrationsdokument [https://docs.microso.com/en-
us/powershell/scripting/whats-new/migrating-from-windows-powershell- 51 - to-
powershell- 7 ].

Geben Sie an der Eingabeaufforderung "Get-Process" ein (wobei
die Groß-/Kleinschreibung irrelevant ist. Das gilt nicht nur für
Windows, sondern auch macOS und Linux!) und drücken Sie
dann die Enter-Taste. Es erscheint eine Liste aller Prozesse, die
auf dem lokalen Computer laufen. Dies war Ihre erste
Verwendung eines einfachen PowerShell-Commandlets.


```
HINWEIS: Beachten Sie bitte, dass die
Groß-/Kleinschreibung keine Rolle spielt, da PowerShell
keine Unterschiede zwischen groß- und
kleingeschriebenen Commandlet-Namen macht.
```
Geben Sie an der Eingabeaufforderung "Get-Service i*" ein. Jetzt
erscheint eine Liste aller installierten Dienste auf Ihrem
Computer, deren Namen mit dem Buchstaben "i" beginnen. Hier
haben Sie ein Commandlet mit einem Parameter verwendet.


Bild 2.9 Die Liste der Prozesse ist das Ergebnis nach Ausführung des Commandlets
"Get-Process".


Bild 2.10 Eine gefilterte Liste der Windows-Dienste

Geben Sie "Get-" ein und drücken Sie dann mehrmals die Tab-
Taste. Die PowerShell zeigt nacheinander alle Commandlets an,
die mit dem Verb "get" beginnen. Microso bezeichnet diese
Funktionalität als "Tabulatorvervollständigung". Halten Sie bei
"Get-Eventlog" an. Wenn Sie Enter drücken, fordert die
PowerShell einen Parameter namens "LogName" an. Bei
"LogName" handelt es sich um einen erforderlichen Parameter
(Pflichtparameter). Nachdem Sie "Application" eingetippt und
die Enter-Taste gedrückt haben, erscheint eine lange Liste der
aktuellen Einträge in Ihrem Anwendungsereignisprotokoll.

Bild 2.11 PowerShell fragt einen erforderlichen Parameter ab.

Der letzte Test bezieht sich auf die Pipeline-Funktionalität der
PowerShell. Auch geht es darum, die Listeneinträge aus dem


Windows-Ereignisprotokoll aufzulisten, doch dieses Mal sind nur
bestimmte Einträge interessant. Die Aufgabe besteht darin, die
letzten zehn Ereignisse abzurufen, die sich auf das Drucken
beziehen. Geben Sie den folgenden Befehl ein, der aus drei
Commandlets besteht, die über Pipes miteinander verbunden
sind:

```
Get-EventLog system | Where-Object { $_.source -eq "print"
} | Select-Object -first 10
```
Die PowerShell scheint einige Sekunden zu hängen, nachdem die
ersten zehn Einträge ausgegeben wurden. Dieses Verhalten ist
korrekt, da das erste Commandlet (Get-EventLog) alle Einträge
empfängt. Dieses Filtern geschieht durch aufeinanderfolgende
Commandlets (Where-Object und Select-Object). Leider besitzt
Get-EventLog keinen integrierten Filtermechanismus.

Bild 2.12 Die Einträge des Ereignisprotokolls filtern

2.2.2 Installierte Version ermitteln


Die Windows PowerShell gibt bei ihrem Start ihre
Versionsnummer nicht direkt preis.

Die Versionsinformation ermittelt man durch den Abruf der
eingebauten Variablen $PSVersionTable. Neben der PowerShell-
Version erhält man auch Informationen über die Frameworks
und Protokolle, auf denen die PowerShell aufsetzt.

Die "CLRVersion" steht dabei für die Version der "Common
Language Runtime" (CLR), die Laufzeitumgebung des Microso
.NET Framework. Es fehlt in der Versionstabelle leider die
Information, dass die PowerShell 5.1 zwar mit der CLR-Version
4.0 zufrieden ist, aber die .NET-Klassenbibliothek in der Version
4.5.2 oder höher benötigt, was eine Installation des .NET
Frameworks 4.5.2 oder höher voraussetzt.

PowerShell Core 6.0 erfordert .NET Core 2.0. PowerShell Core 6.1
erfordert .NET Core 2.1. Allerdings braucht man .NET Core nicht
separat zu installieren: Es wird beim Installationspaket von
PowerShell Core mitgeliefert.


Bild 2.13 Abruf der Versionsinformationen zur Windows PowerShell 5.1 (hier unter
Windows 11, Update-Stand 17. 03. 2022)

Bild 2.14 Abruf der Versionsinformationen zur Windows PowerShell 5.1 (hier unter
Windows 10, Update-Stand 17. 03. 2022)

2.2.3 PowerShell im Skriptmodus


Bei einem PowerShell-Skript handelt es sich um eine Textdatei,
die Commandlets und/oder Elemente der PowerShell-
Skriptsprache (PSL) umfasst. Das zu erstellende Skript legt ein
neues Benutzerkonto auf Ihrem lokalen Computer an.

2.2.4 Skript eingeben

Öffnen Sie den Windows-Editor "Notepad" (oder einen anderen
Texteditor) und geben Sie die folgenden Skriptcodezeilen ein, die
aus Kommentaren, Variablendeklarationen, COM-
Bibliotheksaufrufen und Shell-Ausgabe bestehen:


Listing 2.1 Ein Benutzerkonto erstellen
[1_Basiswissen/ErsteSchritte/LocalUser_Create.ps1]

```
### PowerShell-Script
### Lokales Benutzerkonto anlegen
### (C) Holger Schwichtenberg
```
```
# Eingabewerte
$Name = "Dr. Holger Schwichtenberg"
$Accountname = "HolgerSchwichtenberg"
$Description = "Autor dieses Buchs / Website: http://www.powersh
ell-doktor.de"
$Password = "secret+123"
$Computer = "localhost"
```
```
"Anlegen des Benutzerkontos $Name auf $Computer"
```
```
# Zugriff auf Container mit der COM-Bibliothek "Active Dir
ectory Service Interface"
$Container = [ADSI] "WinNT://$Computer"
```
```
# Benutzer anlegen
$objUser = $Container.Create("user", $Accountname)
$objUser.Put("Fullname", $Name)
$objUser.Put("Description", $Description)
# Kennwort setzen
$objUser.SetPassword($Password)
# Änderungen speichern
$objUser.SetInfo()
```
```
"Benutzer angelegt: $Name auf $Computer"
```

Speichern Sie die Textdatei unter dem Namen "createuser.ps1" in
einem Ordner auf der Festplatte, z. B. w:\Skripte. Beachten Sie,
dass die Dateinamenserweiterung ".ps1" lauten muss.

```
HINWEIS: Im Kapitel "Lokale Benutzer und Gruppen"
werden Sie lernen, dass es seit PowerShell 5.1 auch einen
eleganteren Weg zum Anlegen lokaler Benutzer per
Commandlet New-LocalUser gibt.
```
2.2.5 Skript starten

Starten Sie die PowerShell-Konsole. Versuchen Sie dort nun, das
Skript zu starten. Geben Sie dazu

```
w:\Skripte\createuser.ps 1
```
ein. Für die Ordner- und Dateinamen können Sie die
Tabulatorvervollständigung verwenden! Der Versuch scheitert
zunächst wahrscheinlich, da die Skriptausführung in der
PowerShell auf den meisten Windows-Betriebssystemversionen
standardmäßig nicht zulässig ist. Dies ist kein Fehler, sondern
eine Sicherheitsfunktionalität. Denken Sie an den "Love Letter"-
Wurm für den Windows Script Host!


Bild 2.15 Die Skriptausführung ist standardmäßig verboten.

```
HINWEIS: Bisher war die PowerShell-Skriptausführung
auf allen Betriebssystemen im Standard verboten.
Erstmals in Windows Server 2012 R 2 hat Microso sie im
Standard erlaubt, sofern das Skript auf der lokalen
Festplatte liegt. Entfernte Skripte können nur mit digitaler
Signatur gestartet werden. Diese Einstellung nennt sich
"RemoteSigned". In anderen Betriebssystemen gibt es
jedoch keine Änderung des Standards, der "Restricted"
lautet.
```
2.2.6 Skriptausführungsrichtlinie ändern

Um ein PowerShell-Skript auf Betriebssystemen wie Windows 7,
Windows 8.x und Windows 10/11, wo dies im Standard nicht
erlaubt ist, überhaupt starten zu können, müssen Sie die Skript-
Ausführungsrichtlinie ändern. Später in diesem Buch lernen Sie,
welche Optionen es dafür gibt. Für den ersten Test wird die
Sicherheit ein wenig abgeschwächt, aber wirklich nur ein wenig.


Mit dem folgenden Befehl lässt man die Ausführung von Skripten
zu, die sich auf dem lokalen System befinden, verbietet aber
Skripten von Netzwerkressourcen (das Internet eingeschlossen)
die Ausführung, wenn diese keine digitale Signatur besitzen.

```
Set-ExecutionPolicy RemoteSigned
```
Später in diesem Buch lernen Sie, wie Sie PowerShell-Skripte
digital signieren. Außerdem erfahren Sie, wie Sie Ihr System auf
Skripte beschränken, die Sie oder Ihre Kollegen signiert haben.

Überprüfen Sie die vorgenommenen Änderungen mit dem
Commandlet Get-ExecutionPolicy.Es kann nun sein, dass Sie
Set-ExecutionPolicy gar nicht ausführen können und eine
Fehlermeldung wie die nachstehende sehen, dass die Änderung
in der Registrierungsdatenbank mangels Rechten nicht
ausgeführt werden konnte.

Bild 2.16 Die Benutzerkontensteuerung verbietet die Änderung der
Skriptausführungsrichtlinie.

Dies ist die Benutzerkontensteuerung, die Microso seit Windows
Vista in Windows mitliefert. Benutzerkontensteuerung (User


Account Control, UAC) bedeutet, dass alle Anwendungen seit
Windows Vista immer unter normalen Benutzerrechten laufen,
auch wenn ein Administrator angemeldet ist. Wenn eine
Anwendung höhere Rechte benötigt (z. B. administrative
Aktionen, die zu Veränderungen am System führen), fragt
Windows explizit in Form eines sogenannten Consent Interface
beim Benutzer nach, ob der Anwendung diese Rechte gewährt
werden sollen.

```
HINWEIS: Nur mit Windows Server ab Version 2012 startet
der eingebaute Administrator (Konto "Administrator") alle
Skripte, die Konsole und andere .exe-Anwendungen unter
vollen Rechten. Alle anderen Administratoren unterliegen
der Benutzerkontensteuerung.
```
Bild 2.17 Die besondere Einstellung für den eingebauten Administrator in den
Sicherheitsrichtlinien von Windows Server

Um die PowerShell mit vollen Rechten zu starten, wählen Sie aus
dem Startmenü (oder einer Verknüpfung, z. B. in der Taskleiste)


die PowerShell mit der rechten Maustaste aus und klicken auf
"Als Administrator ausführen".

Bild 2.18 PowerShell "Als Administrator ausführen"

Dass die PowerShell als Administrator gestartet ist, sehen Sie an
dem Zusatz "Administrator:" in der Fenstertitelzeile der Konsole.

Geben Sie in diesem Fenster erneut ein:

```
Set-ExecutionPolicy RemoteSigned
```
Dies sollte nun funktionieren, wie in der nachstehenden
Abbildung gezeigt.

Starten Sie nun das Skript erneut mit:

```
w:\skripte\createuser.ps 1
```
Jetzt sollte die Nachricht erscheinen, dass das Benutzerkonto
erstellt worden ist.


Bild 2.19 Erfolgreiches Ändern der Skriptausführungsrichtlinien und Start des Skripts
"LocalUser_Create.ps1"

Bild 2.20 Das neu erstellte lokale Benutzerkonto

2.2.7 Einrichtungsskript ausführen

In den Downloads zu diesem Buch finden Sie eine Skriptdatei


```
\Einrichten der Beispiele\Einrichten Laufwerk Beispiele und
Arbeitsdateien.ps 1
```
Diese erstellt ein Laufwerk x: zu dem Standort der Beispiele auf
Ihrer Festplatte. Hierzu ermittelt das Skript selbst den Standort
der Beispiele.

Das Skript erstellt zudem ein Laufwerk w: als Arbeitslaufwerk für
die Skripte in diesem Buch.

```
HINWEIS: Wenn Sie dieses Einrichtungsskript nicht
ausführen wollen, dann passen Sie bitte in allen
Beispielen in diesem Buch die Pfade auf Ihre Umgebung
an.
```

Listing 2.2 Das Einrichtungsskript
[\Einrichten der Beispiele\Einrichten Laufwerk Beispiele und Arbeitsdateien.ps1]

```
# PowerShell-Buch http://www.IT-Visions.de/PowerShellBuch
# (C) Dr. Holger Schwichtenberg
# Einrichtungsskript
```
```
# In diesem Buch wird für den Zugriff auf die Beispieldate
ien das X:-Laufwerk
verwendet.
# Bitte legen Sie entweder ein Laufwerk X: an, das zu den
Beispielen bei Ihnen führt,
# oder ändern Sie den Laufwerksbuchstaben in den Skripten.
```
```
(Get-Host).PrivateData.ErrorBackgroundColor = "white"
Write-host "Einrichten von Laufwerk x: für die Skripte im
Buch" - ForegroundColor
Yellow
$root = (get-item $PSScriptRoot).Parent.FullName
$root
New-PSDrive x -PSProvider FileSystem -root $root | ft
subst x: $root
```
```
# Das w:-Laufwerk wird für Arbeitsdateien verwendet. Leite
n Sie es zu einem leeren
Ordner
Write-host "Einrichten von Laufwerk w: für die Arbeitsdate
ien im Buch"
```
- ForegroundColor Yellow
$Arbeitsverzeichnis = "c:\PSBuch_Work" # Pfad ggf. anpasse
n!!!
if (-not (test-path $Arbeitsverzeichnis)) { md $Arbeitsver


```
zeichnis -ea
SilentlyContinue }
New-PSDrive w -PSProvider FileSystem -root $Arbeitsverzeic
hnis | ft
subst w: $Arbeitsverzeichnis
```
```
# Auflisten
Write-host "Eingerichtete Laufwerke:" - ForegroundColor Yel
low
subst
```
```
# ggf. später aufräumen:
# subst w: /d
# subst x: /d
# rd $Arbeitsverzeichnis -force -Recurse
```
Bild 2.21 Ausführen des Einrichtungsskripts


###### 2.3 Woher kommen die PowerShell-

###### Befehle?

In der PowerShell muss man drei Quellen für Befehle
(Commandlets einschließlich Funktionen – die Unterscheidung
zwischen diesen beiden Befehlsarten wird später im Buch noch
erklärt) unterscheiden:

```
Befehle, die zum Kern der PowerShell gehören und mit der
PowerShell-Installation ausgeliefert werden
Befehle, die zum jeweiligen Betriebssystem gehören und
nicht portabel auf andere Betriebssysteme sind
Befehle aus Zusatzmodulen, die man in der PowerShell
Gallery [www.powershellgallery.com] oder aus anderen
Quellen bekommt
```
Wenn man einmal nur die erste Gruppe zählt, dann findet man in
Windows 11 mit Windows PowerShell 5.1 325 Befehle aus zehn
Modulen. Zum Vergleich: Die Windows PowerShell umfasste in
der Version 1.0 nur 129 Commandlets (und Funktionen). In
PowerShell 2.0 waren es 236, in PowerShell 3.0 waren es 322 und
in PowerShell 4.0 waren es 328. Gezählt werden hier alle
Commandlets und Funktionen aus Modulen, die das Wort
"PowerShell" im Modulnamen tragen und in der Dokumentation
"Core Modules" genannt werden.

Die letzten beiden Zahlen in der folgenden Abbildung stellen die
Gesamtzahl der Module (79) und der darin enthaltenen Befehle
(1670) auf Windows 11 dar. Hierin ist dann die zweite oben
genannte Befehlsgruppe (Befehle, die zum jeweiligen
Betriebssystem gehören und nicht portabel auf andere


Betriebssysteme sind) enthalten. Mit Windows 7 bzw. Windows
Server 2008 R 2 hatte Microso begonnen, Zusatzmodule direkt
mit dem Betriebssystem auszuliefern. Diese Zusatzmodule
bringen in Windows 8.1 die Anzahl der Commandlets auf über

1000. In Windows 10 (Stand v 20 H1) sind es dann 1586.

Diese Zahl bezieht sich jeweils auf eine Grundinstallation von
Windows. Mehr PowerShell-Module mit weiteren Befehlen erhält
man, wenn man optionale Features wie Hyper-V, Internet
Information Services (IIS) oder die Remote Server Administration
Tools (RSAT) installiert.

Bild 2.22 Zählen der Module und Befehle (Commandlets und Funktionen) in
Windows PowerShell 5.1 unter Windows 11 v 21 H 2 (Grundinstallation)

Bild 2.23 Zählen der Module und Befehle (Commandlets und Funktionen) in
Windows PowerShell 5.1 unter Windows Server 2022 (Grundinstallation)


Bild 2.24 Zählen der Module und Befehle (Commandlets und Funktionen) in
Windows PowerShell 5.1 unter Windows 10 v 20 H 1 (Grundinstallation)

```
ACHTUNG: Anders als die Erweiterungsmodule, die es o
für mehrere (auch ältere) PowerShell-Versionen gibt, kann
man die zum Betriebssystem gehörenden Module nicht in
einem älteren Betriebssystem verwenden. In dem zum
Redaktionsschluss dieses Buchs aktuellen Stand der
PowerShell 7.2 kann man viele, aber noch nicht alle zum
Windows-Betriebssystem gehörenden PowerShell-
Module auch in PowerShell 7.2 unter Windows
verwenden.
```
###### 2.4 PowerShell Community

###### Extensions (PSCX) herunterladen

###### und installieren

Bei den "PowerShell Community Extensions" (kurz PSCX) handelt
es sich um ein Open Source-Projekt (ursprünglich auf
Codeplex.com, mittlerweile auf Github.com, siehe


[github.com/Pscx/Pscx]), das zusätzliche Funktionalität mit
Commandlets für die Windows Power-Shell realisiert, wie zum
Beispiel Get-DHCPServer, Get-DomainController, Get-MountPoint,
Get-TerminalSession, Set-VolumneLabel, Write-Tar und viele
weitere.

Früher wurden in regelmäßigen Abständen neue Versionen
veröffentlicht. Die aktuelle Version zum Reaktionsschluss dieses
Buchs ist die Version 4.0.0-beta 4 vom 8.1.2022. Diese Version
läu sowohl unter Windows PowerShell als auch unter
PowerShell 7.x.

```
TIPP: In diesem Buch werden an einigen Stellen
Commandlets aus den PSCX verwendet, da diese
zusätzliche Funktionen bieten, die nicht im Kern der
PowerShell enthalten sind. Daher sollten Sie die PSCX bei
sich installieren.
```
Die PSCX sind ein sehr beliebtes Modul (siehe Abrufstatistik links
in der folgenden Abbildung).


Bild 2.25 PowerShell-Gallery-Webseite zu den PSCX. Es gab 2019 und 2021 keine
neuen Versionen. [www.powershellgallery.com/packages/Pscx]

Die Installation der PSCX führt man heutzutage am einfachsten
über das Commandlet Install-Module aus. Dieses Commandlet
lädt das Modul aus der PowerShell Gallery
[www.powershellgallery.com], einem von Microso betriebenen


Online-Portal mit PowerShell-Erweiterungen, und installiert das
Modul. Alternativ dazu können Sie auf Github ein ZIP-Paket laden
[github.com/Pscx/Pscx/releases] und die Installation manuell
vornehmen.

Allerdings ist die Installation nicht ganz so trivial, wie man es sich
wünscht. Beim Aufruf von

```
Install-Module PSCX
```
kommt zuerst die Warnmeldung, dass der NuGet-Provider in
Windows nicht aktuell ist (das passiert sogar in einem
topaktuellen Windows 11 und Windows Server 2022). Die
PowerShell Gallery basiert auf dem Paketmanager NuGet (siehe
[http://www.NuGet.org).](http://www.NuGet.org).)

Wenn man dies bestätigt, kommt die Nachfrage, ob man der
PowerShell Gallery trauen möchte. Danach erscheint die
Fehlermeldung, dass in den PSCX einige Commandlet-Namen
implementiert sind, die es in der aktuellen PowerShell schon
gibt. (Dies hat historische Gründe: PSCX hat diese zuerst
implementiert, dann hat Microso später gleichnamige
Commandlets implementiert, die aber im Detail manchmal
etwas anders funktionieren.)

Man muss mit -AllowClobber bestätigen, dass man diesen
Zustand tolerieren will:

```
Install-Module PSCX -AllowClobber
```
Danach sieht man in der Modulliste, die man via

```
Get-Module PSCX -ListAvailable
```

bekommt, dass nur Version 3.3.2 aus dem Jahr 2018 installiert
wurde.

Wenn man nun aber die Version 4.0.0-Beta 4 aus dem Jahr 2022
haben möchte, soll man laut der Webseite in der PowerShell
Gallery den Parameter -AllowPrerelease ergänzen. Allerdings
merkt man schon bei der fehlenden Eingabehilfe, dass es den
nicht gibt. Es gibt zwar den Parameter -RequiredVersion, mit dem
man dies versuchen kann:

```
Install-Module -Name PSCX -RequiredVersion "4.0.0-beta4"
```
Das wiederum scheitert daran, dass man früher solche
Versionsnummern noch nicht bilden dure.

Grundproblem ist, dass auch im aktuellen Windows-Client und
Windows Server immer noch die total veraltete Version 1.0.0.1
des Moduls PowerShellGet mitgeliefert wird. Die aktuelle
Version laut
https://www.powershellgallery.com/packages/PowerShellGet ist
aber 2.2.5 (stabil) bzw. 3.0.12-beta (Prerelease).


Bild 2.26 Installation der PSCX in der aktuellen stabilen Version, die aber aus dem
Jahr 2018 stammt


Bild 2.27 PowerShellGet ist veraltet und kennt kein -AllowPrelease und keine
Versionsnummern mit Buchstaben.


Bild 2.28 PowerShellGet in der PowerShell Gallery
[https://www.powershellgallery.com/packages/PowerShellGet]

Nun also gilt es, zuerst einmal das Modul PowerShellGet auf den
aktuellen Stand zu bringen. Dazu aktualisiert man zur Sicherheit
erst einmal den NuGet-Treiber:


```
Install-PackageProvider -Name NuGet -Force
```
Danach führt man aus:

```
Install-Module -Name PowerShellGet -force
```
Der Zusatz -force ist notwendig, weil es das Modul ja schon gibt.
(Es gibt einen Befehl Update-Module, der funktioniert hier aber
nicht, weil PowerShellGet ein Systemmodul ist. Update-Module
lässt sich nur für von der PowerShell Gallery installierte Module
verwenden).

Danach hat man dann zwei Versionen von PowerShellGet.

Bild 2.29 Aktualisieren von PowerShellGet


```
TIPP: Nun gehen Sie ins Verzeichnis C:\Program
Files\WindowsPowerShell\Modules\ PowerShellGet und
löschen das Unterverzeichnis 1.0.0.1, um das alte Modul
loszuwerden! Tun Sie Gleiches, wenn es dieses
Unterverzeichnis in
C:\Windows\system 32 \WindowsPowerShell\v1.0\Modules\
PowerShellGet gibt. Prüfen Sie gegebenenfalls mit get-
module powershellget -ListAvailable, ob Sie noch
irgendwo eine alte Version haben!
Das Deinstallieren ganz alter Versionen geht nicht via
Uninstall-Module, weil es ein Systemmodul ist.
```
Nun endlich, wo Sie nur noch PowerShellGet in Version 2.2.5
haben, können Sie die PSCX-Betaversion installieren mit:

```
Install-Module PSCX -AllowPrerelease
```

Bild 2.30 Installation der PSCX in der aktuellen Beta-Version aus dem Jahr 2022

```
TIPP: Wenn Sie kein Freund von Beta-Versionen sind,
könnten Sie sich mit der stabilen Version 3.3.2
zufriedengeben und diese ganzen Modulupdates
vermeiden wollen. Bitte beachten Sie aber: Die Version
3.3.2 ist aus dem Jahr 2018. Die Version 4.0, die es bisher
nur als Beta gibt, löst insbesondere das Problem der
doppelten Commandlet-Namen. Daher brauchen Sie kein
```
- AllowClobber mehr bei der Installation der PSCX 4.0.
PSCX hat in Version 4.0 das Problem der historisch
bedingten doppelten Commandlet-Namen beseitigt,
indem man die PSCX-Commandlets umbenannt hat.


Bild 2.31 Auszug aus den Release Notes der PSCX 4.0
[https://github.com/Pscx/Pscx/blob/master/ReleaseNotes.txt]

Bevor Sie nun einen Befehl der PSCX ausführen können, müssen
Sie in jeder neuen Instanz der PowerShell den Import-Befehl für
die PSCX einmalig ausführen.

```
Import-Module PSCX
```
Sie lernen später in diesem Buch, wie man solche Befehle in der
PowerShell-Profildatei hinterlegt und dafür sorgt, dass diese
automatisch in jeder neuen Instanz ausgeführt werden.


Geben Sie nun Get-DomainController ein (wenn Ihr Computer
Mitglied einer Active Directory-Domäne ist) oder testen Sie die
PSCX mit dem Befehl Ping-Host, der auf jedem Computer im
Netzwerk funktioniert.

Wie Sie in der Abbildung an der Ausgabe zu Ping-Host lesen
können: Es ist ein Commandlet, für das es mittlerweile in der
PowerShell einen Ersatz (hier: Test-Connection) gibt. Daher
erhalten Sie eine Warnung, dass der Befehl obsolet sei.

Bild 2.32 PSCX-Befehle Get-DomainController und Ping-Host testen


###### 2.5 Den Windows PowerShell-Editor

###### "ISE" verwenden

Integrated Scripting Environment (ISE) ist der Name des
Skripteditors, den Microso seit der Windows PowerShell 2.0
mitliefert und der in Windows PowerShell 3.0 nochmals erheblich
verbessert wurde. Die ISE startet man mit dem Symbol
"PowerShell ISE" oder indem man in der PowerShell den Befehl
"ise" ausführt.

Die ISE verfügt über zwei Fenster: ein Skriptfenster (im Standard
oben, alternativ über "View"-Menü einstellbar rechts) und ein
interaktives Befehlseingabefenster (unten bzw. links). Optional
kann man ein drittes Fenster einblenden, das "Command Add-
On", in dem man Befehle suchen kann und eine Eingabehilfe für
Befehlsparameter erhält.

Geben Sie unten im interaktiven Befehlseingabefenster in der ISE
ein:

```
Get-Process
```
Nachdem Sie mindestens einen Buchstaben eingegeben haben,
können Sie die Eingabe mit der Tabulatortaste vervollständigen.
Alternativ können Sie STRG + Leertaste für eine Eingabehilfe mit
Auswahlfenster (IntelliSense) drücken. Die Ausgaben des
interaktiven Bereichs erscheinen dann direkt unter den Befehlen,
wie bei der PowerShell-Konsole. Einen dedizierten
Ausgabebereich wie in der ISE in PowerShell 2.0 gibt es nicht
mehr.


Bild 2.33 IntelliSense-Eingabehilfe

Um die ISE im Skriptmodus zu verwenden, erstellen Sie eine
neue Skriptdatei (Menü "File/New") oder öffnen Sie eine
vorhandene .ps 1 - Datei (Menü "File/Open"). Öffnen Sie als
Beispiel die Skriptdatei CreateUser.ps 1 , die Sie zuvor erstellt
haben. Es sind Zeilennummern zu sehen. Die verschiedenen
Bestandteile des Skripts sind in unterschiedlichen Farben
dargestellt. Auch hier funktioniert die Eingabeunterstützung mit
der Tabulatortaste und IntelliSense.

Um das Skript auszuführen, klicken Sie auf das Start-Symbol in
der Symbolleiste (siehe folgende Abbildung) oder drücken Sie F 5.
Auch hier wird das Ergebnis im interaktiven Bereich angezeigt.

```
TIPP: Stellen Sie sicher, dass Sie die ISE als Administrator
ausführen und dass das Benutzerkonto noch nicht
existiert, bevor Sie das Skript ausführen.
```

Bild 2.34 Die ISE im Skriptmodus

Eine hilfreiche Funktion der ISE ist das Debugging, mit dem Sie
ein Skript Zeile für Zeile durchlaufen und währenddessen den
Zustand der Variablen betrachten können.

Setzen Sie dafür den Cursor auf eine beliebige Zeile in Ihrem
Skript und tippen Sie dann auf F 9 (oder wählen Sie "Toogle
Breakpoint" im Kontextmenü oder im Menü "Debug"). Daraufhin
erscheint die Zeile in Rot – ein sogenannter "Haltepunkt".


Starten Sie das Skript nun mit F5. Die ISE stoppt in der Zeile mit
dem Haltepunkt, und diese wird orange. Mit der Taste F 10
springen Sie zum nächsten Befehl in der folgenden
auszuführenden Zeile. Diese wird dann gelb, und die Zeile mit
dem Haltepunkt wird wieder rot.

```
HINWEIS: Die gelbe Zeile ist immer die nächste Zeile, die
ausgeführt wird.
```
Bild 2.35 Skript-Debugging mit der ISE


Im interaktiven Bereich können Sie im Haltemodus den aktuellen
Zustand der Variablen abfragen, indem Sie dort z. B. eingeben

```
$Computer
```
oder

```
$Container
```
Man kann auch Werte interaktiv ändern. Um das Skript
fortzusetzen, drücken Sie wieder F 5. Über das Menü "Debug"
sind weitere Steuerbefehle möglich.

```
HINWEIS: Sie müssen den Debugger vorher beenden
(Menüpunkt "Debug/Stop Debugger"), wenn Sie das
Skript erneut ändern möchten.
```
###### 2.6 PowerShell 7 installieren und

###### testen

Dieses Unterkapitel behandelt die Installation der
plattformneutralen PowerShell 7 auf Windows, Linux und
macOS. Die PowerShell 7 wird bislang mit keinem
Betriebssystem direkt ausgeliefert. Auch in Windows 11 ist nur
die Windows PowerShell 5.1 im Standard enthalten.


Bild 2.36 Nur Windows PowerShell 5.1 in Windows 11

```
TIPP: Sie können dieses Unterkapitel überspringen, wenn
Sie nur die klassische Windows PowerShell einsetzen
wollen. Details zur PowerShell 7 lesen Sie in Kapitel 13
"PowerShell 7 für Windows, Linux und macOS".
```
2.6.1 Basis für PowerShell 7


Die verschiedenen Versionen der PowerShell 7 basieren auf
verschiedenen Versionen des modernen .NET:

```
PowerShell 7.0 basiert auf .NET Core 3.1.
PowerShell 7.1 basiert auf .NET 5.0.
PowerShell 7.2 basiert auf .NET 6.0.
PowerShell 7.3 basiert auf .NET 7.0.
```
```
HINWEIS: Die jeweilige .NET-Version wird bei der
PowerShell bereits mitgeliefert. Die passende .NET-
Version braucht vorher also nicht installiert zu werden.
Man nennt dies eine "Self-Contained App" (SCA).
```
2.6.2 Installation und Test auf Windows

Für Windows wird die PowerShell 7 auf folgenden Wegen
geliefert:

```
Windows Store
Installationsprogramm (MSI)
ZIP-Datei
.NET SDK CLI-Erweiterung
```

TIPP: Die PowerShell 7 kann man parallel zu den
bisherigen Windows PowerShell-Installationen auf einem
Windows-Rechner betreiben. Mit allen bisherigen Power-
Shell-Aktualisierungen war so ein Parallelbetrieb nicht
möglich.

Zudem kann man beliebig viele Versionen und Varianten
(Release und Preview) parallel installieren. Und man kann
aus den verschiedenen oben genannten Quellen parallel
installieren. Dies führt dann dazu, dass Sie im Startmenü
und im Menü des "Windows Terminal" viele verschiedene
Einträge sehen (siehe Abbildung). Bitte prüfen Sie
genau, ob Sie damit klarkommen, bevor Sie so was
machen.


Bild 2.37 Download-Übersicht von PowerShell 7.2.1 auf GitHub
[https://github.com/PowerShell/powershell/releases]

2.6.2.1 Nutzung der Archivdatei

Die niedrigste Installationshürde bietet die Nutzung der
PowerShell 7 aus einem ZIP-Archiv, das Sie unter
https://github.com/PowerShell/powershell/releases bekommen.
Auch das ZIP-Archiv enthält alle benötigten Dateien von .NET 6.0,
das die Basis von PowerShell 7.2 ist (man nennt dies in .NET eine
"Self-Contained App" ‒ SCA).


Man entpackt das Archiv und startet dort dann einfach vom
Windows Explorer oder von der klassischen Kommandozeile oder
der klassischen PowerShell aus die ausführbare Datei pwsh.exe.

```
ACHTUNG: In der Windows PowerShell war der Name der
Programmdatei powershell.exe. Microso hat den Namen
gegenüber Windows PowerShell 5.1 bewusst geändert,
um den Parallelbetrieb einfacher zu machen. Auf einem
Windows mit Windows PowerShell 5.1 und PowerShell 6/7
startet man also per Eingabe von powershell.exe immer
die Windows PowerShell und durch Eingabe von pwsh.exe
immer die PowerShell 6 oder 7. Es können zudem
mehrere Versionen der Power-Shell 6 und 7 auf einem
System koexistieren. So eine Versionskoexistenz war mit
der Windows PowerShell nicht möglich.
```
Bild 2.38 So meldet sich die PowerShell 7.2 auf Windows.

2.6.2.2 MSI-basierte Installation

Auch das MSI-Paket für die PowerShell 7 bekommen Sie auf
GitHub [https://github.com/PowerShell/powershell/releases].


Für die jeweils aktuelle Release-Version des MSI-Pakets gibt es
eine Portalseite: https://docs.microso.com/en-
us/powershell/scripting/install/installing-powershell-on-
windows in der Dokumentation,

Das MSI-basierte Installationsprogramm installiert die
PowerShell im Standard im Pfad c:\ Program Files\PowerShell\.
Dieser Pfad lässt sich bei der Installation ändern. In diesem Pfad
wird ein Unterordner für die Version erstellt, z. B. "/7" zwischen
"/7-Preview" für Preview-Versionen. In diesem Ordner befinden
sich dann alle Dateien der PowerShell inklusive der benötigten
Dateien von .NET.

```
TIPP: Die MSI-basierte Installation hat den Vorteil, dass es
einige Installationsoptionen gibt (siehe folgende
Abbildungen), um z. B. den Zielpfad der Installation
automatisch zur Umgebungsvariablen %Path% zu
ergänzen, sodass man nun pwsh.exe ohne Voranstellen
eines Pfadnamens starten kann. Außerdem entsteht ein
Eintrag im Startmenü.
```

Bild 2.39 Installation der PowerShell 7 mit dem MSI-Paket

Bild 2.40 Optionen bei der Installation der PowerShell 7 mit dem MSI-Paket


```
HINWEIS: Per MSI-Paket installierte Versionen der
PowerShell 7 werden seit Version 7.2 über "Microso
Update" (nicht "Windows Update", denn PowerShell 7 ist
kein Teil von Windows!) von Microso aktualisiert. Dies ist
die Standardeinstellung im Setup, sie kann aber
deaktiviert werden.
```
2.6.2.3 Installation per Microso Store

Die moderne PowerShell 7 lässt sich auch aus dem Microso
Store installieren. Man sucht in der Store-App nach "PowerShell".


```
HINWEIS: Im Windows Store gibt es die PowerShell 7
zweimal: einmal als aktuelle Release-Version und einmal
als "Preview" mit den neusten, noch nicht stabilen
Features. Die beiden Varianten unterscheiden sich auch
durch das Symbol (siehe folgende Abbildung).
```
Bild 2.41 Die moderne PowerShell 7 im Microso Store (hier unter Windows 11)


Bild 2.42 Installieren der Release-Version der PowerShell 7 aus dem Microso Store
(hier unter Windows 11)

Durch die Installation landet die PowerShell (je nach Rechten) in
diesem Verzeichnis:

```
C:\Users\xy\AppData\Local\Microsoft\WindowsApps\Microsoft.
PowerShell_8wekyb 3 d 8 bbwe\ pwsh.exe
```
oder

```
C:\Program Files\WindowsApps\Microsoft.PowerShell_8wekyb 3 d
8 bbwe\pwsh.exe
```
Aktualisierungen werden automatisch vom Microso Store
angeboten.


2.6.2.4 Installation der PowerShell 7 als

.NET SDK Global Tool

Wenn Sie das .NET Soware Development Kit (.NET SDK) auf
Ihrem System installiert haben, können Sie die PowerShell (ab
Version 6.2) auch als ein sogenanntes .NET Core Global Tool über
einen kurzen Kommandozeilenbefehl mithilfe der .NET CLI
(dotnet.exe) installieren:

```
dotnet tool install --global powershell
```
Dies installiert die aktuelle RTM-Version der PowerShell. Zum
Redaktionsschluss dieses Buchs ist dies die Version 7.2.1. Um die
bestimmte Version der PowerShell zu installieren, müssen Sie
Folgendes schreiben:

```
dotnet tool install --global PowerShell --version 7.2.1
```
Sofern Sie schon eine frühere Version installiert haben, müssen
Sie so aktualisieren:

```
dotnet tool update --global PowerShell
```

```
HINWEIS: Da es .NET Core SDK für Linux, macOS und
Windows gibt, funktioniert diese Installation auf allen drei
Betriebssystemen. Durch die Installation als .NET Core
Global Tool steht dann die PowerShell in Form des
Kommandozeilenbefehls pwsh in allen Konsolenfenstern
zur Verfügung. Es wird aber kein Menüeintrag (Symbol)
erzeugt.
Ein .NET Global Tool wird von NuGet.org heruntergeladen.
Dort finden Sie die PowerShell unter der Webadresse
[www.nuget.org/packages/PowerShell].
```
Bild 2.43 Installation der PowerShell als .NET Core Global Tool: erst Version 7.1.0,
dann Update auf 7.2.1

```
HINWEIS: In den Docker Images des .NET SDK (ab Version
3.0), die Microso verbreitet, ist die PowerShell bereits
enthalten [https://hub.docker.com/_/microsodotnet-
core-sdk].
```

2.6.2.5 Docker-Images

Es gibt auch vorgefertigte Docker-Images von Microso, die
PowerShell 7 enthalten, siehe
[https://hub.docker.com/_/microso-powershell].

Wie Sie ein Docker-Image mit der PowerShell starten,
erfahren Sie im Kapitel "Docker-Container".

2.6.3 Test der PowerShell 7 auf Windows

Starten Sie die PowerShell 7 per Startmenüeintrag oder per
Ausführung von pwsh.exe, z. B. innerhalb der cmd.exe oder
powershell.exe.

```
HINWEIS: Man kann die PowerShell 7 aber nicht
innerhalb der Windows Power-Shell ISE starten.
```
Wie bei der klassischen Windows PowerShell gibt es auch unter
PowerShell 7 Versions- und Systeminformationen über die
eingebaute Variable $psversiontable.

Unter PowerShell Core hat Microso einige Anzeigen der
Versionstabelle geändert. Am auffälligsten sind der Wert "Core"
statt "Desktop" bei "PSEdition" sowie die hinzugefügten Einträge
"Platform" und "OS" für das aktuelle Betriebssystem. Platform
hat die Werte Win 32 NT, macOSX und Unix. Die "CLRVersion" wird
hier nicht mehr angezeigt. Microso verbirgt hier leider, welche
Version von .NET Core bei PowerShell Core mitgeliefert wird.


Bild 2.44 Abruf der Versionsinformationen zur modernen PowerShell (hier installiert
per Windows Store, unter Windows 11)

Bild 2.45 Abruf der Versionsinformationen zur PowerShell Core 7.3.0 (unter Windows
10)


2.6.4 Installation und Test auf Ubuntu

Linux

PowerShell 7 wird für Ubuntu als .deb-Datei ausgeliefert
[github.com/PowerShell/PowerShell/releases], die sich über
"Ubuntu Soware" (Ubuntu ab Version 16.04) installieren lässt.

Bild 2.46 Download der Linux-Version für Ubuntu


Bild 2.47 Installation der PowerShell 7 auf Ubuntu Linux (hier Version 21.04)

Alternativ geht dies nach einem manuellen Download per
Kommandozeile:

```
sudo apt install /home/hs/Downloads/v7.2.1/powershell-lts_
7.2.2-1.deb_
amd64.deb
sudo apt-get install –f
```

```
HINWEIS: Lassen Sie sich nicht verunsichern, wenn
Warnungen bezüglich Abhängigkeiten beim ersten Befehl
erscheinen. Diese Probleme werden durch den zweiten
Befehl geheilt.
```
Zum Start der PowerShell 7 gibt man im Terminal-Fenster pwsh
(nicht powershell oder powershell.exe!) ein.

Bild 2.48 Start der PowerShell 7 auf Ubuntu-Linux

```
TIPP: Sofern pwsh nicht gefunden wird, müssen Sie noch
den Installationspfad in der Umgebungsvariablen $PATH in
der Datei /etc/environment ergänzen und dann das
System neu starten.
```

2.6.5 Installation der PowerShell 7 auf

anderen Linux-Varianten

Für Debian und Kali gibt es ebenfalls eine .deb-Datei. Red Hat
Enterprise Linux, OpenSUSE und CentOS werden durch .rpm-
Dateien unterstützt. Für andere Linux-Distributionen gibt es eine
Archiv-Datei (.gz).

2.6.6 Installation und Test auf macOS

Für die Installation auf macOS stellt Microso unter
[github.com/PowerShell/PowerShell/releases] eine .pkg-Datei
(Apple Soware Package) oder alternativ ein Archiv (.gz) bereit.

```
HINWEIS: Seit PowerShell-Version 7.2 wird auch macOS
mit Apple M1-Prozessor unterstützt! Die Datei für x 64
heißt powershell-7.x.y-osx-x64.pkg und für M 1 dann
powershell-7.x.y-osx-arm64.pkg.
```

Bild 2.49 Download und Start der .pgk-Datei für macOS

Zum Start der PowerShell 7 auf OS/X gibt man im bash-basierten
Terminal-Fenster pwsh (nicht "powershell"!) ein.


Bild 2.50 Start der PowerShell 7 auf macOS


TIPP: Microso verwendet auch unter macOS
verschiedene Farben an der Konsole, die aber in einigen
Fällen (z. B. Commandlet-Namen und
Klassenmitgliedernamen) hell sind und auf einem weißen
Hintergrund nicht genug Kontrast bieten. Stellen Sie
daher für das macOS-Terminal-Fenster ein Farbschema
mit einem dunkleren Hintergrund ein. Gut eignet sich das
Farbschema "Ocean". Sie ändern das Farbschema in dem
Terminal-Fenster im Menü "Terminal/Einstellungen" in
der Registerkarte "Profile".

Bild 2.51 Einstellung des Farbschemas "Ocean" für das macOS-Terminal-
Fenster


2.6.7 Editor für PowerShell 7

PowerShell ISE ist nur mit Windows PowerShell verwendbar. Für
PowerShell 6/7 müssten Sie den kostenfreien plattformneutralen
Editor Visual Studio Code [https://code.visualstudio.com]
zusammen mit der Erweiterung "PowerShell"
[https://marketplace.visualstudio.com/items?itemName=ms-
vscode.PowerShell] einsetzen, der ebenfalls getrennt
herunterzuladen und zu installieren ist. Er ist auf Windows, Linux
und macOS installierbar.

Visual Studio Code ist zunächst auf die PowerShell 7 zu
konfigurieren. Dazu sind einige Schritte notwendig, die Sie in
Kapitel 13 "PowerShell 7 für Windows, Linux und macOS"
kennenlernen.


# 3 Einzelbefehle der

# PowerShell

Die PowerShell kennt folgende Arten von Einzelbefehlen:

```
Commandlets (inkl. Funktionen)
Aliase
Ausdrücke
Externe Befehle
Dateinamen
```
## 3.1 Commandlets

Ein "normaler" PowerShell-Befehl heißt Commandlet (kurz:
Cmdlet) oder Funktion (Function). Eine Funktion ist eine
Möglichkeit, in der PowerShell selbst wieder einen Befehl zu
erstellen, der funktioniert wie ein Commandlet. Da die
Unterscheidung zwischen Commandlets und Funktionen aus
Nutzersicht zum Teil akademischer Art ist, erfolgt hier zunächst


keine Differenzierung: Das Kapitel spricht allgemein von
Commandlets und meint damit auch Funktionen.

3.1.1 Aufbau eines Commandlets

Ein Commandlet besteht typischerweise aus drei Teilen:

```
einem Verb,
einem Substantiv und
einer (optionalen) Parameterliste.
```
Verb und Substantiv werden durch einen Bindestrich "-"
voneinander getrennt, die optionalen Parameter durch
Leerzeichen. Daraus ergibt sich der folgende Aufbau:

```
Verb-Substantiv [-Parameterliste]
```
Die Groß- und Kleinschreibung ist bei den Commandlet-Namen
nicht relevant.

3.1.2 Aufruf von Commandlets

Ein einfaches Beispiel ohne Parameter lautet:

```
Get-Process
```
Dieser Befehl liefert eine Liste aller laufenden Prozesse im
System.

Ein zweites Beispiel ist:


```
Get-ChildItem
```
Dieser Befehl liefert Unterelemente des aktuellen Standorts.
Meist ist der aktuelle Standort ein Dateisystempfad. In der
PowerShell kann der aktuelle Standort aber auch in der
Registrierungsdatenbank, dem Active Directory und vielen
anderen (persistenten) Speichern liegen.

Ein drittes Beispiel ist:

```
Get-Service
```
Dieser Befehl liefert alle Windows-Systemdienste. Dies ist ein
Commandlet, dass es nur unter Windows gibt, nicht in Linux und
macOS.

Das waren alles Commandlets, die Informationen liefern.
Commandlets, die Aktionen ausführen (z. B. Prozesse beenden,
Dateien löschen, Dienste anhalten), kommen in der Regel nicht
ohne Parameter aus, da sie sonst ja global auf alle Ressourcen
eines Typs angewendet würden, z. B. alle Prozesse beenden, alle
Dateien löschen und alle Dienste anhalten. Das ist absichtlich
nicht so implementiert. Solche Befehle, die Parameter erfordern,
kommen werden im nächsten Unterkapitel behandelt.


```
TIPP: Die Tabulatorvervollständigung in der PowerShell-
Konsole funktioniert bei Commandlets, wenn man das
Verb und den Strich bereits eingegeben hat, z. B. Export-
Tab. Auch Platzhalter kann man dabei verwenden. Die
Eingabe Get-?e* Tab liefert Get-Help Tab Get-Member Tab
Get-Service. Andere Editoren wie das ISE bieten auch
IntelliSense-Eingabeunterstützung für Commandlet-
Namen an.
```
```
TIPP: Commandlets, die mit dem Wort Get- beginnen,
kann man abkürzen, indem man das Get- weglässt; also z.
B. einfach Service statt Get-Service schreibt. Ob man dies
so erlauben möchte, sollte das Unternehmen als
Richtlinie festlegen.
```
3.1.3 Commandlet-Parameter

Durch Angabe eines Parameters können die Commandlets
Informationen für die Befehlsausführung erhalten, z. B. ist bei
Get-Process ein Filtern über den Prozessnamen möglich.

Durch

```
Get-Process i*
```
werden nur diejenigen Prozesse angezeigt, deren Name auf das
angegebene Muster (Name beginnt mit dem Buchstaben "i")


zutri:

Ein weiteres Beispiel für einen Befehl mit Parameter ist:

```
Get-ChildItem w:\daten
```
Get-ChildItem listet alle Unterobjekte des angegebenen
Dateisystempfads (w:\daten) auf, also alle Dateien und Ordner
unterhalb dieses Dateiordners.

Ein drittes Beispiel ist:

```
Stop-Service BITS
```
Dieser Befehl führt eine Aktion aus: Der Windows-
Hintergrundübertragungsdienst (Background Intelligent Transfer
Service ‒ BITS) wird angehalten.

Ein viertes Beispiel ist:

```
Remove-Item w:\temp\*.log
```
Dieser Befehl löscht alle Dateien mit der
Dateinamenserweiterung "log" aus dem Ordner w:\temp.

Parameter werden als Zeichenkette aufgefasst – auch wenn sie
nicht explizit in Anführungszeichen stehen. Die
Anführungszeichen sind optional. Man muss Anführungszeichen
um den Parameterwert nur dann verwenden, wenn Leerzeichen
vorkommen, denn das Leerzeichen dient als Trennzeichen
zwischen Parametern:

```
Get-ChildItem "c:\Program Files"
```

Einige Commandlets erlauben für einen Parameter nicht nur
einen einzelnen Wert, sondern auch eine Menge von Werten. Die
Einzelwerte sind dann durch ein Komma zu trennen.

Beispiel: Prozesse, die mit dem Buchstaben a beginnen oder
enden oder mit x beginnen oder enden

Get-Process "a*","*a","x*","*x"

Bild 3.1 Get-Process mit einer Liste von Namen

Commandlets haben aber in der Regel nicht nur einen, sondern
zahlreiche Parameter, die durch Position oder einen
Parameternamen voneinander unterschieden werden. Ohne die
Verwendung von Parameternamen werden vordefinierte
Standardattribute belegt, d. h., die Reihenfolge ist entscheidend.

Beispiel: Auflisten von Dateien in einem Dateisystempfad, die
eine bestimmte Datennamenserweiterung besitzen. Dies erfüllt
der Befehl:

```
Get-ChildItem w:\temp *.doc
```
Wenn ein Commandlet mehrere Parameter besitzt, ist die
Reihenfolge der Parameter entscheidend oder der Nutzer muss
die Namen der Parameter mit angeben. Bei der Angabe von


Parameternamen kann man die Reihenfolge der Parameter
ändern:

```
Get-ChildItem -Filter *.doc -Path w:\temp
```
Alle folgenden Befehle sind daher gleichbedeutend:

```
Get-ChildItem w:\temp *.doc
Get-ChildItem -Path w:\temp -Filter *.doc
Get-ChildItem -Filter *.doc -Path w:\temp
```
Hingegen ist Folgendes falsch und funktioniert nicht wie
gewünscht, weil die Parameter nicht benannt sind und die
Reihenfolge falsch ist:

```
Get-ChildItem *.doc w:\temp
```
Diesen Versuch beantwortet die PowerShell mit einer
Fehlermeldung ("Das zweite Pfadfragment darf kein Laufwerk
oder UNC-Name sein.") in roter Schri (siehe nächste
Bildschirmabbildung).


Bild 3.2 Fehlermeldung bei falscher Parameterreihenfolge. Die Fehlermeldungen in
der modernen PowerShell sind o prägnanter

Schalter-Parameter (engl. Switch) sind Parameter, die keinen
Wert haben. Durch die Verwendung des Parameternamens wird
die Funktion aktiviert, z. B. das rekursive Durchlaufen durch
einen Dateisystembaum mit -recurse:

```
Get-ChildItem w:\demo\powershell –recurse
```
```
TIPP: Wenn man einen Schalter deaktivieren möchte,
weil er im Standard aktiv ist oder weil man sehr explizit
darauf hinweisen möchte, dass er nicht aktiv sein soll,
kann man $false mit Doppelpunkt getrennt angeben, z.
B.
```
```
Get-ChildItem w:\demo\powershell -recurse:$false
```
Parameter können berechnet, d. h. aus Teilzeichenketten
zusammengesetzt sein, die mit einem Pluszeichen verbunden


werden. (Dies macht insbesondere Sinn in Zusammenhang mit
Variablen, die aber erst später in diesem Buch eingeführt
werden.)

Der folgende Ausdruck führt jedoch nicht zum gewünschten
Ergebnis, da auch hier das Trennzeichen vor und nach dem + ein
Parametertrenner ist.

```
Get-ChildItem "c:\" + "Windows" *.dll -Recurse
```
Auch ohne die beiden Leerzeichen vor und nach dem + geht es
nicht. In diesem Fall muss man durch eine runde Klammer dafür
sorgen, dass die Berechnung erst ausgeführt wird:

```
Get-ChildItem ("c:\" + "Windows") *.dll -Recurse
```
Es folgt dazu noch ein Beispiel, bei dem Zahlen berechnet
werden. Der folgende Befehl liefert den Prozess mit der ID 2900:

```
Get-Process -id ( 2800 + 100 )
Get-Service -exclude "[k-z]*"
```
zeigt nur diejenigen Systemdienste an, deren Name nicht mit den
Buchstaben "k" bis "z" beginnt.

Auch mehrere Parameter können der Einschränkung dienen. Der
folgende Befehl liefert nur die Benutzereinträge aus einem
bestimmten Active-Directory-Pfad. (Das Beispiel setzt die
Installation der PSCX voraus.)

```
Get-ADObject -dis "LDAP://Server 123 /ou=agents,DC=FBI,DC=ne
t" - class user
```

```
TIPP: Tabulatorvervollständigung klappt auch bei
Parametern. Versuchen Sie einmal folgende Eingabe an
der PowerShell-Konsole: Get-ChildItem -Tab
```
3.1.4 Platzhalter bei den Parameterwerten

An vielen Stellen sind Platzhalter bei den Parameterwerten
erlaubt. Ein Stern steht für beliebig viele Zeichen. Eine Liste aller
Prozesse, die mit einem "i" anfangen, erhält man so:

```
Get-Process i*
```
Eine Liste aller Prozesse, die mit einem "i" anfangen und auf
"ore" enden, erhält man so:

```
Get-Process i*ore
```
Ein Fragezeichen steht für genau ein beliebiges Zeichen. Eine
Liste aller Prozesse, die mit einem "v" anfangen, gefolgt von
einem einzigen beliebigen Zeichen und auf "mms" enden, erhält
man so:

```
Get-Process v?mms
```
Eine eckige Klammer steht für genau ein Zeichen aus einer
Auswahl. Alle Prozesse, die mit s oder t anfangen, erhält man so:

```
Get-Process [st]*
```

Alle Prozesse, die mit s oder t anfangen und bei denen dann ein v
oder f folgt, erhält man so:

```
Get-Process [st][vf]*
```
Bild 3.3 Beispiele für das Ergebnis des obigen Befehls mit Platzhaltern

3.1.5 Abkürzungen für Parameter

Parameternamen dürfen abgekürzt werden, solange sie noch
eindeutig sind.

Statt

```
Get-ChildItem -Filter *.txt -Path w:\temp
```
darf man schreiben

```
Get-ChildItem -Fi *.txt -Pa w:\temp
```
Nicht möglich ist in diesem Fall die Reduzierung auf einen
Buchstaben:


```
Get-ChildItem -F *.txt -P w:\temp
```
Darauf reagiert die PowerShell mit der Fehlermeldung

```
Der Parameter kann nicht verarbeitet werden, da der Parame
tername "F" nicht eindeutig
ist. Mögliche Übereinstimmungen: - Filter -Force
```
und

```
Der Parameter kann nicht verarbeitet werden, da der Parame
tername "P" nicht eindeutig
ist. Mögliche Übereinstimmungen: - Path –PipelineVariable
```

```
ACHTUNG: Bitte beachten Sie aber, dass abgekürzte
Parameter auch eine Gefahr bedeuten: Was heute eine
eindeutige Abkürzung ist, könnte in einer zukünigen
Version doppeldeutig sein, wenn Microso weitere
Parameter zu einem Commandlet ergänzt. Tatsächlich
gab es in der Vergangenheit auch schon kuriose Fälle,
dass die Abkürzungen in verschiedenen Windows-
Installationen verschieden interpretiert wurden, wie die
nachstehenden Bildschirmabbildungen beweisen. Zudem
sind abgekürzte Parameter nicht so "sprechend" wie die
Langparameter. Für abgekürzte Parameter spricht aber,
dass Befehle dadurch kürzer und übersichtlicher werden.
Trotz allem werden Sie auch abgekürzte Parameter in
diesem Buch finden, da der Autor dieses Buchs eben auch
ein Mensch ist, der sich im Alltag manche Tipparbeit
gerne erspart.
```
Bild 3.4 Verhalten auf Windows Server 2008 R 2 und Windows 8 mit PowerShell 3.0

Bild 3.5 Verhalten auf Windows 7 und Windows 8.1 mit PowerShell 4.0


Bild 3.6 Verhalten auf allen Windows 10/11 und Windows Server 2019/2022 mit
PowerShell 5.1

3.1.6 Allgemeine Parameter (Common

Parameters)

Es gibt einige Parameter, die in vielen (aber nicht allen)
Commandlets vorkommen. Es folgt eine vollständige Liste dieser
Parameter. Eine genauere Beschreibung folgt aber aus
didaktischen Gründen an geeigneter Stelle im Buch, da viele
allgemeine Parameter mit dem Pipelining und der
Fehlerbehandlung zu tun haben, die erst in späteren Kapiteln
besprochen wird.

- Force: Eine Aktion wird erzwungen, z. B. eine Datei wird mit
    Remove-Item gelöscht, obwohl die Datei einen Schreibschutz
    gesetzt hat. Ein weiteres Beispiel: Remove-SmbShare fragt
    immer vor dem Löschen nach, wenn –force nicht gesetzt ist.
- Whatif ("Was wäre wenn"): Die Aktion wird nicht ausgeführt,
    es wird nur ausgegeben, was passieren würde, wenn man
    die Aktion ausführt. Das ist z. B. in einem Befehl mit
    Platzhaltern wie dem Folgenden sinnvoll, damit man weiß,
    welche Dienste nun gestoppt würden:


```
Get-Service | Where {$_.servicename -like "*SQL*"}
| Foreach { stop-service $_.servicename -whatif}
```
oder

```
Stop-Service -name "*sql*" - whatif
```
Bild 3.7 Operationen mit Platzhaltern können schlimme Konsequenzen haben –
whatif zeigt, welche Dienste betroffen wären.

- Confirm: Der Benutzer erhält eine Nachfrage für jede
    Änderungsaktion (siehe Bildschirmabbildung), z. B.

```
get-service | where {$_.servicename -like "A*"}
| foreach { stop-service $_.servicename –confirm }.
```
```
Innerhalb der Nachfrage kann der Benutzer in einen
Suspend-Modus gehen, in dem er andere Befehle eingeben
kann, z. B. um zu prüfen, ob er nun ja oder nein antworten
will. Der Suspend-Modus wird mit drei Pfeilen >>> angezeigt
und ist durch exit zu verlassen (siehe Bildschirmabbildung).
```

Bild 3.8 Confirm und Suspend

- ErrorAction (abgekürzt -ea) und -WarningAction (-wa):
    Festlegung, wie ein Skript sich verhalten soll, wenn es auf
    einen Fehler tri. Dieser Parameter wird im Abschnitt 7.19
    "Fehlerbehandlung" näher erklärt.
- Verbose: Das Commandlet liefert eine detaillierte
    Bildschirmausgabe.
- Debug: Das Commandlet liefert eine sehr detaillierte
    Bildschirmausgabe.
- OutVariable: Das Commandlet liefert alle Objekte nicht nur
    in die Pipeline, sondern legt sie zusätzlich auch in einer
    Variablen ab.


- PipelineVariable: Das Commandlet liefert das aktuelle
    Objekt nicht nur in die Pipeline, sondern legt es zusätzlich
    auch in einer Variablen ab.
- ErrorAction: Festlegung, wie sich das Commandlet bei
    Fehlern verhält
- ErrorVariable: speichert eine Fehlermeldung des
    Commandlets zusätzlich in einer Variablen
- WarningAction: Festlegung, wie sich das Commandlet bei
    Warnungen verhält. Der Standard ist "continue", was
    bedeutet, dass die Meldung ausgegeben wird. Mit
    "silentlycontinue"kann die Ausgabe unterdrückt werden.
    Mit "stop" wird ein Befehl nach der Warnung abgebrochen.
    Mit "inquire" fragt die PowerShell nach, wie fortzufahren ist.
- WarningVariable: speichert eine Warnung des Commandlets
    zusätzlich in einer Variablen
- OutBuffer: stellt ein, dass die angegebene Anzahl von
    Objekten in der Pipeline gepuffert werden sollen, bevor sie
    in der Pipeline weitergegeben werden. Normalerweise
    werden alle Objekte sofort in der Pipeline weitergegeben.


ACHTUNG: Leider beachten nicht alle Commandlets alle
allgemeinen Parameter. Erschwerend kommt hinzu, dass
sie keine Fehlermeldung liefern, sondern den Parameter
einfach ignorieren. Ein Beispiel ist New-SmbShare zum
Anlegen einer Dateisystemfreigabe. Die folgenden Befehle
werden trotz -whatif bzw. - confirm sofort und ohne
Nachfrage ausgeführt.

```
New-SmbShare -Name Temp -Path w:\temp -WhatIf
New-SmbShare -Name Temp -Path w:\temp -confirm
```
Sie werden sich fragen, warum dies so ist. Das
Fehlverhalten liegt hier bei dem Entwickler des
Commandlets. Jeder Commandlet-Entwickler muss daran
denken, die allgemeinen Parameter zu behandeln. Denkt
er nicht daran, sind die Nutzer seines Commandlets die
Leidtragenden. Es wäre natürlich besser, wenn Microso
mit seiner Programmierschnittstelle für Commandlets die
Commandlet-Entwickler zwingen würde, die Parameter
zu behandeln oder zumindest eine Fehlermeldung zu
liefern, wenn man die Parameter einsetzt. Leider hat
Microso diesen Vorschlag bisher nicht aufgegriffen –
auch wenn Microso ja sehr offensichtlich nicht mal seine
eigenen Commandlet-Entwickler im Griff hat.


```
ACHTUNG: Leider gibt es bei den PowerShell-
Commandlets, die gravierende Aktionen ausführen, einige
Unterschiede im Grundverhalten und in der Verwendung
der obigen Commandlets. Einige Commandlets führen im
Standard die Aktion aus (z. B. Remove-Item). Andere
Commandlets (z. B. Remove-ADUser und Remove-SmbShare)
fragen immer nach vor dem Löschen. Das ist bei
automatisierten Skripten natürlich unsinnig und daher
gibt es auch eine Möglichkeit, diesen Commandlets das
abzugewöhnen. Diese sieht jedoch omals verschieden
aus. Bei Remove-ADUser muss man –confirm:$false als
Parameter angeben; bei Remove-SmbShare ist es hingegen
ein -force. Schade, dass Microso hier nicht einheitlich
sein konnte.
```
Standardvorgaben für allgemeine Parameter

In den eingebauten Variablen $WhatIfPreference,
$VerbosePreference, $DebugPreference, $ConfirmPreference und
$ErrorActionPreference ist festgelegt, wie sich die PowerShell im
Standard in Bezug auf -WhatIf, - Verbose, - Debug, - Confirm und -
ErrorAction verhält. Dort ist hinterlegt:

```
WhatIfPreference: False
VerbosePreference: SilentlyContinue
DebugPreference: SilentlyContinue
ErrorActionPreference: Continue
```

ConfirmPreference: High

Variablen werden erst später in diesem Buch (Kapitel 7
"PowerShell-Skriptsprache") behandelt. An dieser Stelle soll aber
schon mit einem Beispiel gezeigt werden, wie man
$WhatIfPreference auf $true setzt und damit erreicht, dass alle
Commandlets, die -whatif unterstützen, nun nur noch sagen,
was sie machen würden – zumindest solange man nicht explizit -
whatif:$false als Parameter angibt.

Ausgabe der aktuellen Einstellung von $WhatIfPreference. Sollte
$false sein

```
Write-host "WhatIfPreference = $WhatIfPreference" - Foregro
undColor Yellow
```
Neustart des Dienstes wird tatsächlich ausgeführt

```
Restart-Service BITS -Verbose
```
Nun $WhatIfPreference aktivieren

```
$WhatIfPreference = $true
```
Ausgabe der aktuellen Einstellung von $WhatIfPreference. Sollte
$true sein

```
Write-host "WhatIfPreference = $WhatIfPreference" - Foregro
undColor Yellow
```
Neustart des Dienstes wird NICHT ausgeführt

```
Restart-Service BITS -Verbose
```

Neustart des Dienstes wird tatsächlich ausgeführt

```
Restart-Service BITS -WhatIf:$false -Verbose
```
Nun $WhatIfPreference zurücksetzen

```
$WhatIfPreference = $false
```
Bild 3.9 Verwendung von $WhatIfPreference

3.1.7 Dynamische Parameter

Einige Commandlets besitzen die Fähigkeit, verschiedene
Parameter abhängig von bereits eingegebenen Parametern
anzubieten.


Bild 3.10 Get-ChildItem (alias dir) in Verbindung mit einem Dateisystempfad (hier mit
Intelli-Sense in PowerShell ISE)

Bild 3.11 Get-ChildItem (alias dir) in Verbindung mit einem Pfad im
Zertifikatsspeicher (hier mit IntelliSense in PowerShell ISE)

3.1.8 Zeilenumbrüche

Wenn man die Eingabe-Taste drückt, wird ein PowerShell-Befehl
direkt ausgeführt. Möchte man einen Befehl über mehrere Zeilen
erstrecken, muss man die unvollständige Zeile mit dem Gravis
(Accent Grave) [`] beenden.


Bild 3.12 Einsatz des Gravis für Zeilenumbrüche im Befehl

```
TIPP: In der PowerShell-Konsole kann man SHIFT +
EINGABE drücken. Auch dann zeigt die Standardkonsole
mit >>> an, dass weitere Eingaben erwartet werden.
Allerdings wird dann ein eigenständiger Befehl erwartet
und nicht der vorherige fortgesetzt!
```
3.1.9 PowerShell-Module

Schon seit PowerShell 2.0 sind die Commandlets und Funktionen
in Modulen organisiert. Während der Benutzer in PowerShell 2.0
ein Modul noch explizit mit Import-Module aktivieren musste,
bevor man die Befehle aus dem Modul nutzen konnte, erledigt
dies die Power-Shell seit Version 3.0 bei Bedarf automatisch
(Module Auto-Loading). Sowohl Konsole als auch ISE zeigen alle
verfügbaren Commandlets und Funktionen aller vorhandenen
Module in der Vorschlagsliste und beim Aufruf von Get-Command
bereits an. Der eigentliche Import des Moduls erfolgt dann beim
ersten Aufruf eines Befehls aus einem Modul.


In der PowerShell sind auch alle Kernbefehle der PowerShell in
Modulen organisiert, diese zeigt die folgende Tabelle.

Tabelle 3.1 Die vier wichtigsten Module der PowerShell mit Beispielen für
Commandlets in diesem Modul

```
Modul Beispiele für
Commandlets in
diesem Modul
```
```
Microso.PowerShell.Diagnostics Get-WinEvent, Get-
Counter, Import-
Counter, Export-Counter
```
...

```
Microso.PowerShell.Management Add-Content, Clear-
Content, Clear-
ItemProperty, Join-Path,
Get-Process, Get-Service
```
...

```
Microso.PowerShell.Security Get-Acl, Set-Acl, Get-
PfxCertificate, Get-
Credential...
```
```
Microso.PowerShell.Utility Format-List, Format-
Custom, Format-Table,
Format-Wide, Where-
Object...
```
3.1.10 Prozessmodell


Die PowerShell erzeugt beim Start einen einzigen Prozess. In
diesem Prozess laufen alle ausgeführten Commandlets. Dies ist
ein Unterschied zum DOS-ähnlichen Windows-
Kommandozeilenfenster, bei dem die ausführbaren Dateien
(.exe) in eigenen Prozessen laufen. Es ist in der PowerShell aber
auch möglich, Hintergrundaufgaben auszuführen (siehe Kapitel
25 "Hintergrundauräge").

```
TIPP: Mit STRG+C kann man einen laufenden Befehl in
der PowerShell abbrechen.
```
3.1.11 Aufruf von Commandlets aus

anderen Prozessen heraus

PowerShell-Commandlets kann man aus einem beliebigen
Prozess heraus aufrufen, indem man powershell.exe aufru und
das Commandlet als Parameter übergibt.

Beispiel: powershell.exe "get-service a*"

Damit die Parameter des Commandlets dem Commandlet und
nicht powershell.exe zugeordnet werden, muss man das
Commandlet und seine Parameter in Anführungszeichen setzen.
Falls der PowerShell-Commandlet-Parameter seinerseits
Anführungszeichen erfordert, muss man dafür einfache
Anführungszeichen verwenden:

```
powershell.exe "get-service 'a*'"
```

Bild 3.13 Aufruf eines PowerShell-Commandlets aus einer klassischen Windows-
Konsole (CMD) heraus mit powershell.exe (im Bild in Windows 10)

3.1.12 Namenskonventionen

Man beachte, dass bei den Commandlets das Substantiv im
Singular steht, auch wenn eine Menge von Objekten abgerufen
wird. Das Ergebnis muss nicht immer eine Objektmenge sein.
Beispielsweise liefert

```
Get-Location
```
nur ein Objekt mit dem aktuellen Pfad. Mit

```
Set-Location c:\windows
```
wechselt man den aktuellen Pfad. Diese Operation liefert gar kein
Ergebnis.


```
HINWEIS: Die Groß- und Kleinschreibung der
Commandlet-Namen und der Parameternamen ist
irrelevant.
```
Gemäß der PowerShell-Konventionen soll es nur eine begrenzte
Menge wiederkehrender Verben geben: Get, Set, Add, New, Remove,
Clear, Push, Pop, Write, Export, Select, Sort, Update, Start, Stop,
Invoke usw. Außer diesen Basisoperationen gibt es auch
Ausgabekommandos mit Verben wie Out und Format. Auch
Bedingungen werden durch diese Syntax abgebildet (Where-
Object).

###### 3.2 Aliase

Durch sogenannte Aliase kann die Eingabe von Commandlets
verkürzt werden. So ist ps als Alias für Get-Process oder help für
Get-Help vordefiniert. Statt Get-Process i* kann also auch
geschrieben werden: ps i*.


```
HINWEIS: Manche PowerShell-Experten betrachten den
Einsatz von Aliasen als schlechten Stil, der die Lesbarkeit
von PowerShell-Skripten erschwert. Auf der anderen Seite
ersparen Aliase eben Tipparbeit. Ob man vordefinierte
und ggf. auch selbst definierte PowerShell-Aliase
erlauben möchte, sollte man im Unternehmen als
Richtlinie festlegen. Ich halte Alias insbesondere dann für
kein Problem, wenn man die von Microso vordefinierten
Aliase verwenden. Auch lokal innerhalb einer Skriptdatei
selbstdefinierte Aliase sollten erlaubt sein, denn sie
haben den Stellenwert von selbstdefinierten Funktionen,
die sicherlich auch erlaubt sein müssen. Problematisch
finde ich hingegen selbstdefinierte globale Aliase, denn
diese setzen voraus, dass die Aliase auf jedem System, auf
dem ein Skript ausgeführt werden soll, auch wirklich
definiert sind und alle Administratoren, die die Skripte
lesen und bearbeiten können sollen, diese Aliase auch
kennen.
```
3.2.1 Aliase auflisten

Durch Get-Alias (oder den entsprechenden Alias aliases) erhält
man eine Liste aller vordefinierten Abkürzungen in Form von
Instanzen der Klasse System. Management.Automation. AliasInfo.

Durch Angabe eines Namens bei Get-Alias erhält man die
Bedeutung eines Alias:


```
Get-Alias pgs
```
Möchte man zu einem Commandlet alle Aliase wissen, muss man
allerdings schreiben:

```
Get-Alias | Where-Object { $_.definition -eq "Get-Process"
}
```
Dies erfordert schon den Einsatz einer Pipeline, die erst im
nächsten Kapitel besprochen wird.


Tabelle 3.2 Vordefinierte Aliase in der PowerShell

Alias Commandlet

% ForEach-Object

? Where-Object

ac Add-Content

asnp Add-PSSnapIn

cat Get-Content

cd Set-Location

chdir Set-Location

clc Clear-Content

clear Clear-Host

clhy Clear-History

cli Clear-Item

clp Clear-ItemProperty

cls Clear-Host

clv Clear-Variable

cnsn Connect-PSSession


compare Compare-Object

copy Copy-Item

cp Copy-Item

cpi Copy-Item

cpp Copy-ItemProperty

cvpa Convert-Path

dbp Disable-PSBreakpoint

del Remove-Item

diff Compare-Object

dir Get-ChildItem

dnsn Disconnect-PSSession

ebp Enable-PSBreakpoint

echo Write-Output

epal Export-Alias

epcsv Export-CSV

epsn Export-PSSession

erase Remove-Item


etsn Enter-PSSession

exsn Exit-PSSession

fc Format-Custom

fl Format-List

foreach ForEach-Object

 Format-Table

fw Format-Wide

gal Get-Alias

gbp Get-PSBreakpoint

gc Get-Content

gci Get-ChildItem

gcm Get-Command

gcs Get-PSCallStack

gdr Get-PSDrive

ghy Get-History

gi Get-Item

gjb Get-Job


gl Get-Location

gm Get-Member

gmo Get-Module

gp Get-ItemProperty

gps Get-Process

group Group-Object

gsn Get-PSSession

gsnp Get-PSSnapIn

gsv Get-Service

gu Get-Unique

gv Get-Variable

gwmi Get-WmiObject

h Get-History

history Get-History

icm Invoke-Command

iex Invoke-Expression

ihy Invoke-History


ii Invoke-Item

ipal Import-Alias

ipcsv Import-CSV

ipmo Import-Module

ipsn Import-PSSession

irm Invoke-RestMethod

ise powershell_ise.exe

iwmi Invoke-WMIMethod

iwr Invoke-WebRequest

kill Stop-Process

lp Out-Printer

ls Get-ChildItem

man help

md mkdir

measure Measure-Object

mi Move-Item

mount New-PSDrive


move Move-Item

mp Move-ItemProperty

mv Move-Item

nal New-Alias

ndr New-PSDrive

ni New-Item

nmo New-Module

npssc New-PSSessionConfigurationFile

nsn New-PSSession

nv New-Variable

ogv Out-GridView

oh Out-Host

popd Pop-Location

ps Get-Process

pushd Push-Location

pwd Get-Location

r Invoke-History


rbp Remove-PSBreakpoint

rcjb Receive-Job

rcsn Receive-PSSession

rd Remove-Item

rdr Remove-PSDrive

ren Rename-Item

ri Remove-Item

rjb Remove-Job

rm Remove-Item

rmdir Remove-Item

rmo Remove-Module

rni Rename-Item

rnp Rename-ItemProperty

rp Remove-ItemProperty

rsn Remove-PSSession

rsnp Remove-PSSnapin

rujb Resume-Job


rv Remove-Variable

rvpa Resolve-Path

rwmi Remove-WMIObject

sajb Start-Job

sal Set-Alias

saps Start-Process

sasv Start-Service

sbp Set-PSBreakpoint

sc Set-Content

select Select-Object

set Set-Variable

shcm Show-Command

si Set-Item

sl Set-Location

sleep Start-Sleep

sls Select-String

sort Sort-Object


sp Set-ItemProperty

spjb Stop-Job

spps Stop-Process

spsv Stop-Service

start Start-Process

sujb Suspend-Job

sv Set-Variable

swmi Set-WMIInstance

tee Tee-Object

trcm Trace-Command

type Get-Content

where Where-Object

wjb Wait-Job

write Write-Output

3.2.2 Neue Aliase anlegen


Einen neuen Alias definiert der Nutzer mit Set-Alias oder New-
Alias, z. B.:

```
Set-Alias procs Get-Process
New-Alias procs Get-Process
```
Der Unterschied zwischen Set-Alias und New-Alias ist marginal:
New-Alias erstellt einen neuen Alias und liefert einen Fehler,
wenn der zu vergebende Alias schon existiert. SetAlias erstellt
einen neuen Alias oder überschreibt einen Alias, wenn der zu
vergebende Alias schon existiert. Mit dem Parameter –
description kann man jeweils auch einen Beschreibungstext
setzen.

Man kann einen Alias nicht nur für Commandlets, sondern auch
für klassische Anwendungen vergeben, z. B.:

```
Set-Alias np notepad.exe
```
```
ACHTUNG: Beim Anlegen eines Alias wird nicht geprü,
ob das zugehörige Commandlet bzw. die Anwendung
überhaupt existiert. Der Fehler würde erst beim Aufruf des
Alias aureten.
Beim Anlegen eines Alias muss man zudem aufpassen,
dass man keine bestehenden Namen überschreibt, denn
Aliase haben Priorität. Wenn man Set-Alias notepad dir
eingibt, führt ab dann die Eingabe von notepad nicht mehr
zu notepad.exe, sondern zum Commandlet Get-ChildItem
(für das dir ein Alias ist). notepad ist dann also ein Alias für
einen Alias.
```

Man kann in Aliasdefinitionen keinen Parameter mit Werten
vorbelegen. Möchten Sie zum Beispiel definieren, dass die
Eingabe von "Temp" die Aktion "Get-ChildItem c:\Temp"
ausführt, brauchen Sie dafür eine Funktion. Mit einem Alias geht
das nicht.

```
Function Temp { Get-ChildItem w:\temp }
```
Funktionen werden später (siehe Kapitel 6 "PowerShell-Skripte")
noch ausführlich besprochen. Die PowerShell enthält zahlreiche
vordefinierte Funktionen, z. B. c:, d:, e: sowie mkdir und help.

Die neu definierten Aliase gelten jeweils nur für die aktuelle
Instanz der PowerShell-Konsole. Man kann die eigenen Alias-
Definitionen exportieren mit Export-Alias und später wieder
importieren mit Import-Alias. Als Speicherformate stehen das
CSV-Format und das Power-Shell-Skriptdateiformat (.ps 1 – siehe
spätere Kapitel) zur Verfügung. Bei dem ps1-Format ist zum
späteren Reimport der Datei das Skript mit dem Punktoperator
(engl. "Dot Sourcing") aufzurufen.

Dateiformat CSV Dateiformat .ps 1

```
Speichern Export-Alias
x:\meinealias.csv
```
```
Export-Alias
x:\meinealias.ps 1 - as
script
```
```
Laden Import-Alias
x:\meinealias.csv
```
. x:\meinealias.ps 1

Die Anzahl der Aliase ist im Standard auf 4096 beschränkt. Dies
kann durch die Variable $MaximumAliasCount geändert werden.


3.2.3 Aliase entfernen

Aliase entfernen aus der aktuellen PowerShell kann man mit
Remove-Item alias:\AliasName, also z. B.

```
Remove-Item alias:\np
```
Um den zuvor angelegten Alias zum Start von Notepad wieder zu
löschen.

Seit PowerShell Core 6.0 gibt es auch das Commandlet Remove-
Alias zu diesem Zweck:

```
Remove-Alias np
```
3.2.4 Aliase für Eigenschaen

Aliase sind auch auf Ebene von Eigenschaen definiert. So kann
man statt

```
Get-Process processname, workingset
```
auch schreiben:

```
Get-Process name, ws
```
Diese Aliase der Attribute sind definiert in der Datei types.ps 1 xml
im Installationsordner der PowerShell.


Bild 3.14 types.ps 1 xml


```
ACHTUNG: Die types.ps 1 xml-Datei wird ab PowerShell 5.1
nicht mehr von der PowerShell verwendet, da das
Einlesen der Datei die Startgeschwindigkeit der
PowerShell-Konsolen negativ beeinflusst hat. Die
Informationen liegen nun im C#-Code der Commandlets
vor. Die types.ps 1 xml ist noch für den PowerShell 2.0-
Kompatibilitätsmodus vorhanden.
```
###### 3.3 Ausdrücke

Ebenfalls als Befehl direkt in die PowerShell eingeben kann man
Ausdrücke, z. B. mathematische Ausdrücke wie

```
10 * ( 8 + 6 )
```
oder Zeichenkettenausdrücke wie

```
"www." + "IT-Visions" + ".de"
```
Microso spricht hier vom Expression Mode der PowerShell im
Kontrast zum Command Mode, der verwendet wird, wenn man

```
Write-Output ( 10 * ( 8 + 6 ))
```
aufru.


Bild 3.15 Bei Write-Output (alias: echo) ist die Klammerung wichtig, sonst versteht
die PowerShell 10*(8+6) als zwei getrennte Ausdrücke

Die PowerShell kennt zwei Verarbeitungsmodi für Befehle: einen
Befehlsmodus (Command Mode) und einen Ausdrucksmodus
(Expression Mode). Im Befehlsmodus werden alle Eingaben als
Zeichenketten behandelt. Im Ausdrucksmodus werden Zahlen
und Operationen verarbeitet. Als Faustregel gilt: Wenn eine Zeile
mit einem Buchstaben oder den Sonderzeichen kaufmännisches
Und [&], Punkt [.] oder Schrägstrich [\] beginnt, dann ist die Zeile
im Befehlsmodus. Wenn die Zeile mit einer Zahl, einem
Anführungszeichen (["] oder [']), einer runden Klammer [(] oder
dem [@]-Zeichen ("Klammeraffe") beginnt, dann ist die Zeile im
Ausdrucksmodus.

Befehls- und Ausdrucksmodus können gemischt werden. Dabei
muss man in der Regel runde Klammern zur Abgrenzung
verwenden. In einen Befehl kann ein Ausdruck durch Klammern
eingebaut werden. Außerdem kann eine Pipeline mit einem
Ausdruck beginnen. Die folgende Tabelle zeigt verschiedene
Beispiele zur Erläuterung. Echo ist der Alias für Write-Output.


Tabelle 3.3 Ausdrücke in der PowerShell

Beispiel Bedeutung

2 + (^3) Ein Ausdruck – die PowerShell führt die
Berechnung aus und liefert 5.
echo 2 + (^3) Ein reiner Befehl. "2+3" wird als
Zeichenkette angesehen und ohne
Auswertung auf dem Bildschirm
ausgegeben.
echo ( 2 + 3 ) Ein Befehl mit integriertem Ausdruck. Auf
dem Bildschirm erscheint 5.
2 + 3 | echo Eine Pipeline, die mit einem Ausdruck
beginnt. Auf dem Bildschirm erscheint 5.
echo 2 + 3 | 7 + (^6) Eine unerlaubte Eingabe. Ausdrücke
dürfen in der Pipeline nur als erstes
Element auauchen.
$a = Get-Process Ein Ausdruck mit integriertem Befehl. Das
Ergebnis wird einer Variablen zugewiesen.
$a | Get-Process Eine Pipeline, die mit einem Ausdruck
beginnt. Der Inhalt von $a wird als
Parameter an Get-Process übergeben.
Get-Process | $a Eine unerlaubte Eingabe. Ausdrücke
dürfen in der Pipeline nur als erstes
Element auauchen.


```
"Anzahl der
laufenden
Prozesse: (Get-
Process). Count"
```
```
Es ist wohl nicht das, was gewünscht ist,
denn die Ausgabe ist: Anzahl der
laufenden Prozesse: (Get-Process).Count
```
```
"Anzahl der
laufenden
Prozesse:
$((Get-
Process).Count)"
```
```
Jetzt ist die Ausgabe "Anzahl der
laufenden Prozesse: 95", weil $( ... )
einen Unterausdruck (Subexpression)
einleitet und dafür sorgt, dass Get-Process
ausgeführt wird.
```
###### 3.4 Externe Befehle (klassische

###### Kommandozeilenbefehle)

Viele moderne Soware besitzt leider noch keine PowerShell-
Commandlets, sondern nur sehr altertümliche
Kommandozeilenwerkzeuge, die lediglich Textausgeben statt
strukturierter Objekte liefern und die – verglichen mit der
PowerShell – sehr inkonsistent in ihrem Verhalten sind.
Besonders schlimme Beispiele sind die
Kommandozeilenwerkzeuge von Docker (Docker-CLI: docker.exe)
und Git (Git-CLI: git.exe). Aber für auch die Verwaltung der
Azure-Cloud stellt Microso nicht für alle Aufgaben PowerShell-
Commandlets bereit, sondern manchmal nur klassische
Kommandozeilenbefehle (Azure-CLI: az.cmd).

Alle Eingaben in der PowerShell, die nicht als Commandlets,
Funktionsname, Laufwerksname oder mathematische Formeln
erkannt werden, werden als externe Anwendungen behandelt. Es
können sowohl klassische Kommandozeilenbefehle (wie


ping.exe, docker.exe, az.exe, git.exe, ipconfig.exe und netstat.exe)
als auch Windows-Anwendungen ausgeführt werden.

Die Eingabe c:\Windows\Notepad.exe ist daher möglich, um den
"beliebten" Windows-Editor zu starten. Auf gleiche Weise können
auch WSH-Skripte aus der PowerShell heraus gestartet werden.

Die folgende Bildschirmabbildung zeigt den Aufruf von
netstat.exe. Im Beispiel kommt zusätzlich das Commandlet
Select-String zum Einsatz, das nur die Zeilen filtert, die das Wort
"mapi" enthalten. Sonst wird die Ausgabeliste sehr lang.

Bild 3.16 Ausführung von netstat

Wenn ein Leerzeichen im Pfad zu einer .exe-Datei vorkommt,
dann kann man die Datei so nicht aufrufen (hier wird nach einem
Befehl "X:\data\soware\Windows" gesucht):

```
X:\data\software\Windows Tools\ImageEditor.exe
```
Auch die naheliegende Lösung der Verwendung von
Anführungszeichen funktioniert nicht (hier wird die Zeichenkette
ausgegeben):


```
"X:\data\software\Windows Tools\ImageEditor.exe"
```
Korrekt ist die Verwendung des kaufmännischen Und (&), das
dafür sorgt, dass der Inhalt der Zeichenkette als Befehl
betrachtet und ausgeführt wird:

```
& "X:\data\software\Windows Tools\ImageEditor.exe"
```
```
ACHTUNG: Grundsätzlich könnte es passieren, dass ein
interner Befehl der Power-Shell (Commandlet, Alias oder
Function) genauso heißt wie ein externer Befehl. Die
PowerShell warnt in einem solchen Fall nicht vor der
Doppeldeutigkeit, sondern die Ausführung erfolgt nach
folgender Präferenzliste:
Aliase
Funktionen
Commandlets
Externe Befehle
```
###### 3.5 Dateinamen

Beim direkten Aufruf von Datendateien (z. B. .doc-Dateien) wird
entsprechend den Windows-Einstellungen in der
Registrierungsdatenbank die Standardanwendung gestartet und
damit das Dokument geladen.


```
HINWEIS: Dateinamen und Ordnerpfade müssen nur in
Anführungszeichen (einfache oder doppelte) gesetzt
werden, falls sie Leerzeichen enthalten.
```
Bild 3.17 Anführungszeichen bei Pfadangaben


# 4 Hilfefunktionen

Dieses Kapitel beschreibt die Hilfefunktionen der PowerShell.

## 4.1 Auflisten der verfügbaren

## Befehle

Die Liste aller verfügbaren Befehle (PowerShell-Commandlets,
PowerShell-Funktionen, Power-Shell-Aliase und klassische
ausführbare Dateien) erhält man in der PowerShell auch durch
das Commandlet Get-Command.

Die Eingabe

```
Get-Command
```
liefert aber im Standard nur die ersten drei o. g. Befehlsarten.

Erst mit

```
Get-Command -CommandType Application
```
bekommt man auch die klassischen ausführbaren Dateien


Bild 4.1 Gruppierung nach Befehlstypen

Bei Get-Command sind auch Muster erlaubt.

```
Get-Command Get-* liefert alle Befehle, die mit "get"
anfangen.
Get-Command [gs]et-* liefert alle Befehle, die mit "get" oder
"set" anfangen.
Get-Command *-Service liefert alle Befehle, die das Substantiv
"Service" besitzen.
Get-Command –noun Service liefert ebenfalls alle Befehle, die
das Substantiv "Service" besitzen.
Get-Command *wmi* liefert alle Befehle, die die
Buchstabenfolge "wmi" enthalten (und mutmaßlich mit der
Windows Management Instrumentation zu tun haben).
Get-Command | Where-Object { $_.name -like "*cim*" - or
$_.name -like "*wmi*" } liefert alle Befehle, die die
Buchstabenfolge "wmi" oder "cmi" enthalten. Ohne ein
weiteres Commandlet Where-Object, das erst im nächsten
Kapitel näher erläutert wird, ist diese Abfrage nicht
machbar.
```

```
Das Commandlet Get-Command kann auch verwendet werden,
um die Information zu erhalten, was die PowerShell unter
einem Befehl versteht. Get-Command sucht nach angegebenen
Namen in Commandlets, Aliasen, Funktionen, Skriptdateien
und ausführbaren Dateien (siehe nächste Abbildung).
Get-Command *.exe zeigt eine Liste aller direkt aufrufbaren
EXE-Dateien.
```
Bild 4.2 Beispiele zum Einsatz von Get-Command

###### 4.2 Praxistipp: Den Standort eines

###### Kommandozeilenbefehls suchen

Gibt man nach Get-Command den Namen einer .exe-Datei an, zeigt
die PowerShell, in welchem Pfad die ausführbare Datei gefunden


werden kann. Gesucht wird dabei nur in den Pfaden gemäß der
Umgebungsvariablen %Path%.

```
HINWEIS: Dies entspricht der Funktion des klassischen
Windows-Befehls "where. exe" (wobei man bei Get-
Command nicht nur den Pfad, sondern direkt ein Objekt mit
mehr Informationen erhält, siehe nächste Abbildung).
Man kann "where.exe" auch in der PowerShell
verwenden, muss aber unbedingt "where.exe" mit
Dateinamenserweiterung angeben. Die einfache Eingabe
"where" würde die PowerShell als Aufruf des
Commandlets Where-Object verstehen, dessen Alias
"where" ist.
```
Bild 4.3 Suche des Standorts einer EXE-Datei mit Get-Command oder Where.exe

###### 4.3 Anzahl der Befehle


Windows 11 mit PowerShell 5.1 bietet 1670 Commandlets,
Windows Server 2022 bietet 1799 Commandlets. Die rasante
Fortentwicklung der Funktionalität der Windows PowerShell,
aber auch der Einbruch beim Umstieg auf die Core Editionen seit
PowerShell 6.0 sowie die gravierende Abhängigkeit ihrer
Mächtigkeit von dem jeweils installierten Betriebssystem, zeigt
die folgende Tabelle.


Tabelle 4.1 Änderung der Mächtigkeit der PowerShell zwischen den verschiedenen
Versionen

```
PowerShell-
Version
```
```
Betriebssystem Anzahl der
Commandlets und
Funktionen in der
Grundinstallation
```
```
PowerShell
7.2
```
Windows 1507

```
PowerShell
7.2
```
Linux und macOS 286

```
PowerShell
Core 6.2
```
Windows 1439

```
PowerShell
Core 6.1
```
Windows 1436

```
PowerShell
Core 6.0
```
Windows 425

```
PowerShell
5.1
```
Windows 10 1586

```
PowerShell
5.1
```
Windows 11 1670

```
PowerShell
5.1
```
```
Windows Server
2022
```
1799

PowerShell Windows 10 1404


```
5.0 (Threshold 1,
Ursprungsversion
vom 29. 05. 2016)
```
```
PowerShell
4.0
```
```
Windows Server
2012 R 2
```
1376

```
PowerShell
4.0
```
Windows 8.1 1132

```
PowerShell
4.0
```
Windows 7 573

```
PowerShell
3.0
```
Windows 8 945

```
PowerShell
3.0
```
Windows 7 561

```
PowerShell
2.0
```
Windows 7 273

```
PowerShell
1.0
```
Alle 163

Ermitteln kann man diese Zahlen mit:

```
(Get-Command | Sort-Object Name | Get-Unique).Count
```
Get-Command liefert unter PowerShell seit 2.0 sowohl
Commandlets als auch eingebaute Funktionen (deren
Handhabung o der von Commandlets entspricht, nur die Art der


Implementierung ist anders). Unter PowerShell 1.0 musste man
die Funktionen separat zählen mit:

```
(dir function:).count
```
Wenn Sie wissen möchten,

```
welche Commandlets zwischen zwei Versionen
hinzugekommen sind, oder
hinsichtlich welcher Commandlets sich zwei Systeme
unterscheiden,
```
können Sie dies wie folgt ermitteln:

Auf dem einen System exportieren Sie eine Liste der
Commandlets in eine Textdatei. Auf einem System mit
PowerShell 1.0/2.0/3.0 führen Sie folgende Befehle aus, um
Commandlets und Funktionen zu exportieren:

```
# PowerShell bis einschließlich 3.0, hier am Beispiel 3.0
Get-Command | ft name -hide | out-file w:\ps3_commandlets.
txt
dir function: | ft Name -hide | out-file w:\ps3_commandlet
s.txt -Append
```
Auf einem System mit PowerShell ab Version 4.0 brauchen Sie
nur einen Befehl (dieser exportiert Commandlets und
Funktionen):


```
# PowerShell ab 4.0, z.B. für PowerShell 5.1
Get-Command | sort-Object name | get-unique | foreach {
([string]$_.name).Trim() }|
out-file w:\ps51_commandlets.txt
```
```
# PowerShell ab 4.0, z.B. für PowerShell 7.x
Get-Command | sort-Object name | get-unique | foreach {
([string]$_.name).Trim() }|
out-file w:\ps70_commandlets.txt
```
```
HINWEIS: Get-Unique ist hier erforderlich, weil
Commandlets in verschiedenen Versionen eines Moduls
doppelt vorkommen könnten. Es ist möglich, dass auf
einem System ein Modul in mehreren Versionen in
verschiedenen Verzeichnissen existiert.
```
Dann führt man beide Textdateien auf einem System zusammen
und führt dort aus:


```
# Laden der Dateien für Vergleich
$wps 51 = Get-content w:\ps51_Commandlets.txt | sort
$ps 70 = Get-content w:\ps70_Commandlets.txt | sort
```
```
# Vergleich: Befehle nur in WPS 5.1
compare-object $wps 51 $ps 70 - syncwindow 2000 | where sidei
ndicator -eq "<=" #
optional: | out-file w:\ps70_Commandlets_fehlend.txt
```
```
# Vergleich: Befehle nur in PS 7.x
compare-object $wps 51 $ps 70 - syncwindow 2000 | where sidei
ndicator -eq "=>" #
optional: | out-file w:\ps70_Commandlets_neu.txt
```
###### 4.4 Volltextsuche

Get-Command sucht nur in den Commandletnamen. Mit Get-Help
kann man unter Angabe einer beliebigen Zeichenkette in den
Hilfedateien suchen.

Beispiel:

```
Get-Help "Local user account"
```

Bild 4.4 Volltextsuche mit Get-Help

###### 4.5 Erläuterungen zu den Befehlen

Einen Hilfetext zu einem Commandlet bekommt man über Get-
Help commandletname, z. B.:

```
Get-Help Get-Process
```
Dabei kann man durch die Parameter -detailed, - example und -
full mehr Hilfe erhalten. Die Hilfe erscheint abhängig von der
installierten Sprachversion der PowerShell. Der Autor dieses
Buchs verwendet jedoch primär englische Betriebssysteme und
Anwendungen.


Bild 4.5 Ausschnitt aus dem Hilfetext zum Commandlet Get-Process

```
TIPP: Alternativ zum Aufruf von Get-Help kann man auch
den allgemeinen Parameter -? an das Commandlet
anhängen, z. B. Get-Process -?. Dann erhält man die
Kurzversion der Hilfe, hat aber keine Option für die
ausführlicheren Versionen.
```
###### 4.6 Hilfe zu Parametern


Um zu sehen, welche Parameter ein Befehl bietet, kann man Get-
Help mit dem Parameter -Parameter verwenden:

```
Get-Help Get-Process -parameter "*" | ft name, type
```
Einige Commandlets (z. B. New-Button aus dem WPK (Windows
Presentation Foundation (WPF) PowerShell Kit), siehe Kapitel 64
"Grafische Benutzeroberflächen") haben sehr viele Parameter (in
diesem Fall 180!). Hier kann man auch filtern:

```
Get-Help New-Button -parameter "on_*" | ft name, type
```
Genauere Hilfe zu einem einzelnen Parameter erhält man, wenn
man nach -parameter den Namen angibt und die weitere
Formatierung weglässt. Die folgende Abbildung zeigt, wie man
Hilfe zu dem Parameter -Foregroundcolor im Commandlet Write-
Host erhält. Neben den möglichen Farbwerten sagt die Hilfe
auch, dass

```
die Angabe einer Farbe nicht erforderlich ist
die Farbangabe nicht über die Position des Parameters
gebunden wird, d. h., dass immer der Parametername
anzugeben ist
der Farbwert auch nicht aus der Pipeline eingelesen werden
kann
im Farbwert keine Platzhalter erlaubt sind
```

Bild 4.6 Hilfe zu dem Parameter -ForeGroundColor beim Commandlet Write-Host

Schaut man sich hingegen die Hilfe zum Parameter -Name beim
Commandlet Get-Service an, sieht man zwar weniger Text, aber
mehr Möglichkeiten:

```
Es kann nicht nur eine feste Menge von Zeichenketten,
sondern eine beliebige Zeichenkette übergeben werden.
Dies zeigt der Typ <string> an.
Genau genommen steht da <string[]>. Die eckigen
Klammern bedeuten "Menge", es kann also nicht nur eine
Zeichenkette, sondern auch eine Menge von Zeichenketten
```

```
übergeben werden (Beispiel: Dienste, die mit dem
Buchstaben a beginnen oder enden oder mit x beginnen
oder enden: Get-Service -name "a*","*a","x*","*x").
Der Wert kann über seine Position (0 bedeutet: an erster
Stelle) übergeben werden. Daher kann man -name
weglassen, sofern man den Wert für den Parameter an erster
Stelle übergibt: Get-Service "a*","*a","x*","*x"
Der Werte (oder die Werte) für den Parameter -name kann
auch als Wert aus der Pipeline gelesen werden. Möglich ist
also "a*" | Get-Service oder "a*","*a","x*","*x" | Get-
Service
```
Bild 4.7 Hilfe zu dem Parameter -Name beim Commandlet Get-Service

```
HINWEIS: Leider sind dynamische (d. h. von anderen
Parametern abhängige) Parameter zu Commandlets nicht
in der Hilfe verzeichnet.
```

###### 4.7 Hilfe mit Show-Command

Die PowerShell ist kommandozeilenorientiert. Vor der
PowerShell 3.0 gab es in der Power-Shell nur zwei Befehle, die
eine grafische Benutzeroberfläche zeigten: Out-GridView (zur
Ausgabe von Objekten in einer filter- und sortierbaren Tabelle)
und Get-Credential (zur Abfrage von Benutzername und
Kennwort).

Seit PowerShell 3.0 kann sich der PowerShell-Nutzer mit dem
Commandlet Show-Command für jedes PowerShell-Commandlet
und jede Function eine grafische Eingabemaske zeigen lassen.

```
ACHTUNG: Die grafische Benutzeroberfläche, die das
Commandlet zeigt, basiert auf der Windows Presentation
Foundation (WPF). Da es die WPF nur unter Windows gibt,
funktioniert dieses Commandlet nicht in PowerShell
unter Linux und macOS.
```
Die nächste Abbildung zeigt Show-Command für das Commandlet
Stop-Service. Ziel von Show-Command ist es, insbesondere
Einsteigern die Erfassung der Parameter zu erleichtern.
Pflichtparameter sind mit einem Stern gekennzeichnet. Ein Klick
auf die "Copy"-Schaltfläche legt den erzeugten Befehl in die
Zwischenablage, ohne ihn auszuführen.


```
TIPP: Das Fenster "Befehls-Add-On" in dem ISE ist eine
modifizierte Version von Show-Command.
```
Bild 4.8 Show-Command bietet Eingabehilfen für Einsteiger.

###### 4.8 Hilfefenster


Seit PowerShell 3.0 kann man auch aus der PowerShell-Konsole
heraus ein eigenständiges Hilfefenster starten, indem man bei
Get-Help den Parameter -ShowWindow verwendet.

```
Get-Help "Set-PrintConfiguration" - ShowWindow
```
Das Hilfefenster nutzt zur Hervorhebung fette Schri, bietet eine
Zoomfunktion und eine Volltextsuche an (vgl. die nachstehende
Abbildung).

```
HINWEIS: Get-Help bietet in PowerShell unter Linux und
macOS keinen Parameter -ShowWindow, da dieses Fenster
auf der Windows Presentation Foundation (WPF) basiert,
die es in .NET Core für Linux und macOS nicht gibt.
```

Bild 4.9 Hilfefenster, das Get-Help durch den Parameter -ShowWindow startet

Eine grafische Hilfedatei im .chm-Dateiformat zur PowerShell gab
es nur für die PowerShell 1.0 und 2.0 als Zusatz.


Bild 4.10 Hilfe zum Transfer von VBScript nach PowerShell

###### 4.9 Allgemeine Hilfetexte

Die PowerShell enthält auch einige allgemeine Hilfetexte. Diese
Dokumente beginnen mit "about". Man findet sie mit Get-Help
about_. Ein konkretes Dokument ru man dann unter Angabe des
kompletten Dokumentennamen ab: z. B. Get-Help about_arrays.


Bild 4.11 Ausschnitt aus der Liste der "About"-Dokumente

###### 4.10 Aktualisieren der Hilfedateien

Die Hilfeinformationen, die durch Get-Help ausgelesen werden
können, sind in XML-Dateien gespeichert. Das verwendete XML-
Format heißt Microso Assistance Markup Language (MAML). Die
Hilfe-Dateien sind den einzelnen Modulen zugeordnet.


Bild 4.12 Ausschnitt aus der Hilfedatei
Microso.PowerShell.Commands.Management.dll-help.xml

Mit PowerShell 3.0 hatte Microso die Möglichkeit eingeführt, die
Hilfe-Dateien aus der laufenden PowerShell heraus zu
aktualisieren ("Updatable Help System"). Die Ausführung des
Commandlets Update-Help kontaktiert den Microso-
Downloadserver (download.microso.com) und aktualisiert im
laufenden Betrieb die Hilfedateien. Auch wenn es sich um relativ
kleine Dateien handelt (aktuell insgesamt nur rund 10 MB),
dauert der Download über eine 50-MBit-Leitung zwei bis drei
Minuten. Der Download besteht für jedes PowerShell-Modul aus
einer sogenannten Help-Info-Datei, die als wesentliche
Information die Sprache und die Versionsnummer enthält, sowie
einer komprimierten Datei (ZIP-Format,
Dateinamenserweiterung ist aber CAB), die nur heruntergeladen
wird, wenn die lokalen Hilfeinformationen nicht auf dem
aktuellen Stand sind.


Bild 4.13 Aktualisieren der Hilfe mit Update-Help

```
HINWEIS: Die Aktualisierung der Hilfedateien für alle
Standardmodule, die sich im
c:\Windows\System 32 \WindowsPowerShell-Verzeichnis
befinden, ist nur mit administrativen Rechten möglich.
```
```
Listing 4.1 Beispiel für eine Help-Info-Datei
<?xml version="1.0" encoding="utf-8"?>
<HelpInfo xmlns="http://schemas.microsoft.com/powershell/h
elp/ 2010 /05">
<HelpContentURI>http://go.microsoft.com/fwlink/?linkid= 210
601 </HelpContentURI>
<SupportedUICultures>
<UICulture>
<UICultureName>en-US</UICultureName>
<UICultureVersion>3.1.0.0</UICultureVersion>
</UICulture>
</SupportedUICultures>
</HelpInfo>
```
Update-Help kann durch Angabe eines Modulnamens im
Parameter –Module die Hilfe für ein einzelnes Modul aktualisieren.


Update-Help kann durch Angabe eines Pfads im Parameter –
SourcePath die Hilfedateien von einem lokalen Dateisystempfad
oder Netzwerkpfad laden. Zu diesem Zweck kann man mit Save-
Help die Help-Info-Dateien und die CAB-Dateien herunterladen.
Größere Unternehmen können so die Hilfedateien zentral für alle
Nutzer im Unternehmensnetzwerk bereitstellen.

```
TIPP: Die Aktualisierung der Hilfedateien kann auch im
Editor "ISE" im Menü "Hilfe" ausgelöst werden.
```
###### 4.11 Online-Hilfe

Die Dokumentation der PowerShell findet man hier:
https://docs.microso.com/de-de/powershell/

Die zusätzlichen betriebssystemabhängigen PowerShell-Module
sind hier dokumentiert: https://docs.microso.com/de-
de/powershell/module/

Sie werden aber feststellen, dass dort jedes Commandlet einzeln
beschrieben ist. Es gibt aber leider keine Dokumente, die das
komplexere Zusammenspiel von Commandlets erklären oder die
Vorgehensweise anhand von Praxisgebieten beschreiben wie in
diesem Buch.


```
HINWEIS: Neu seit PowerShell 3.0 ist der Parameter -
Online beim Commandlet Get-Help, der für ein
Commandlet direkt die passende Seite in der Online-Hilfe
öffnet.
```
Eine Online-Hilfe des Buchautors ist die Website [http://www.dotnet-](http://www.dotnet-)
lexikon.de, wo Sie zu vielen Begriffen rund um PowerShell und
.NET Erklärungstexte sowie ein Abkürzungsverzeichnis finden.


Bild 4.14 Hilfe zu den Fachbegriffen und Abkürzungen auf der Website [http://www.dotnet-](http://www.dotnet-)
lexikon.de

###### 4.12 Fehlende Hilfetexte

Leider gibt es nicht zu allen Commandlets eine Hilfe. Microso
wird in seinem Sowareentwicklungsprozess immer agiler und
vernachlässigt dabei leider die Dokumentation. So gibt es zum
Beispiel zu einigen bereits in PowerShell 5.1 eingeführten
Commandlets wie Test-FileCatalog einige Jahre später, zum


Redaktionsschluss dieses Buchs immer noch keine adäquaten
Hilfetexte, auch nicht in Windows 11. So zeigt Get-Help hier genau
wie die Webseite nur die im Commandlet automatisch
verfügbaren Metadaten über die Parameter, aber keinerlei
Erläuterungstexte und keine Beispiele.

Bild 4.15 Keine Hilfetexte zum Commandlet und zu den Parametern bei Test-
FileCatalog


Bild 4.16 Auch auf der Website https://docs.microso.com/en-
us/powershell/module/microso.powershell.security/test-filecatalog gibt es keine
Hilfetexte zum Commandlet und zu den Parametern bei Test-Filecatalog

###### 4.13 Dokumentation der

###### .NETKlassen

Informationen zu den .NET-Klassen, mit denen die PowerShell
arbeitet, finden Sie an folgenden Stellen:


```
PowerShell-Dokumentation für den Namensraum
System.Management.Automation
Dokumentation der .NET-Klassenbibliothek in den Microso
Docs unter https://docs.microso.com/de-de/dotnet/api/.
Produktspezifische Dokumentationen, z. B. Exchange-Server-
Dokumentation oder System-Center-Dokumentation
```
Die Dokumentation zeigt die verfügbaren Klassenmitglieder
(Attribut, Methoden, Ereignisse, Konstruktoren). Die folgende
Abbildung zeigt die Dokumentation der Klasse Process im
Namensraum System.Diagnostics. In dem Baum links erkennt
man die verschiedenen Arten von Mitgliedern: Methoden
(Methods), Eigenschaen (Properties) und Ereignisse (Events).


Bild 4.17 Ausschnitt aus der Dokumentation der .NET-Klasse
System.Diagnostics.Process (hier in der Online-Variante)


HINWEIS: Da die Dokumentation der .NET-Klassen für
Sowareentwickler geschrieben wurde, ist sie häufig zu
detailliert und nicht adäquat für PowerShell-Anwender. Es
sind auch keine Beispiele in PowerShell-Syntax
vorhanden. Leider hat Microso bisher noch nie eine für
die Bedürfnisse von Administratoren angepasste Version
der Klassenbibliotheksdokumentation veröffentlicht.

TIPP: Die englische Dokumentation ist der deutschen
vorzuziehen, weil es in den deutschen Übersetzungen
viele Übersetzungsfehler gibt, die das Verständnis
erschweren.


### 5 Objektorientiertes Pipelining

Ihre Mächtigkeit entfaltet die PowerShell erst durch das
objektorientierte Pipelining, also durch die Weitergabe von
strukturierten Daten von einem Commandlet zum anderen.

```
HINWEIS: Dieses Kapitel setzt ein Grundverständnis des
Konzepts der Objektorientierung voraus. Wenn Sie diese
Grundkenntnisse nicht besitzen, lesen Sie bitte zuvor im
Anhang den Crashkurs "Objektorientierung" sowie den
Crashkurs ".NET Framework" oder vertiefende Literatur.
```
5.1 Befehlsübersicht

Die folgende Tabelle zeigt eine Übersicht der wichtigsten
Commandlets, die Basisoperationen auf Pipelines ausführen. Diese
Commandlets werden in den folgenden Kapiteln genau besprochen.


Tabelle 5.1 Übersicht über die wichtigsten Pipelining-Commandlets

```
Commandlet
(mit Aliasen)
```
Bedeutung

```
Where-
Object
(where, ?)
```
Filtern mit Bedingungen

```
Select-Object
(select)
```
```
Abschneiden der Ergebnismenge vorne/hinten
bzw. Reduktion der Attribute der Objekte. Auch:
Eliminieren von Duplikaten
```
```
Sort-Object
(sort)
```
Sortieren der Objekte

```
Group-Object
(group)
```
Gruppieren der Objekte

```
Foreach-
Object { $_...
} (%)
```
```
Schleife über alle Objekte. Der Befehlsblock {... }
wird für jedes Objekt in der Pipeline einmal
ausgeführt.
```
```
Get-Member
(gm)
```
Ausgabe der Metadaten (Reflection)

```
Measure-
Object
(measure)
```
Berechnung: - min -max -sum -average

```
Compare-
Object
(compare,
diff)
```
Vergleichen von zwei Objektmengen


5.2 Pipeline-Operator

Für eine Pipeline wird – wie auch in Unix-Shells üblich und in der
normalen Windows-Konsole möglich – der vertikale Strich "|"
(genannt "Pipe" oder "Pipeline Operator") verwendet.

```
Get-Process | Format-List
```
bedeutet, dass das Ergebnis des Get-Process-Commandlets an
Format-List weitergegeben werden soll. Die Standardausgabeform
von Get-Process ist eine Tabelle. Durch Format-List werden die
einzelnen Attribute der aufzulistenden Prozesse untereinander statt in
Spalten ausgegeben.

Die Pipeline kann beliebig lang sein, d. h., die Anzahl der
Commandlets in einer einzigen Pipeline ist nicht begrenzt. Man muss
aber jedes Mal den Pipeline-Operator nutzen, um die Commandlets zu
trennen.

Ein Beispiel für eine komplexere Pipeline lautet:

```
Get-ChildItem w:\daten –r -filter *.doc
| Where-Object { $_.Length -gt 40000 }
| Select-Object Name, Length
| Sort-Object Length
| Format-List
```
Get-ChildItem ermittelt alle Microso-Word-Dateien im Ordner
w:\daten und in seinen Unterordnern. Durch das zweite Commandlet
(Where-Object) wird die Ergebnismenge auf diejenigen Objekte
beschränkt, bei denen das Attribut Length größer ist als 40 000. $_ ist
dabei der Zugriff auf das aktuelle Objekt in der Pipeline. Der Ausdruck
$_. Length -gt 40 000 ru aus dem aktuellen Objekt die Eigenscha
Length ab und vergleicht, ob diese größer (-gt) als 40 000 ist. Select-
Object beschneidet alle Attribute aus Name und Length. Durch das


vierte Commandlet in der Pipeline wird die Ausgabe nach dem
Attribut Length sortiert. Das letzte Commandlet schließlich erzwingt
eine Listendarstellung.

Nicht alle Aneinanderreihungen von Commandlets ergeben einen
Sinn. Einige Aneinanderreihungen sind auch gar nicht erlaubt. Die
Reihenfolge der einzelnen Befehle in der Pipeline ist nicht beliebig.
Keineswegs kann man im obigen Befehl die Sortierung hinter die
Formatierung setzen, weil nach dem Formatieren zwar noch ein
Objekt existiert, dieses aber einen Textstrom repräsentiert. Where-
Object und Sort-Object könnte man vertauschen; aus Gründen des
Ressourcenverbrauchs sollte man aber erst einschränken und dann
die verringerte Liste sortieren. Ein Commandlet kann aus
vorgenannten Gründen erwarten, dass es bestimmte Arten von
Eingabeobjekten gibt. Am besten sind aber Commandlets, die jede Art
von Eingabeobjekt verarbeiten können.

Eine automatische Optimierung der Befehlsfolge wie in der
Datenbankabfrage SQL gibt es bei PowerShell nicht.

Seit PowerShell-Version 3.0 hat Microso für den Zugriff auf das
aktuelle Objekt der Pipeline zusätzlich zum Ausdruck $_ den Ausdruck
$PSItem eingeführt. $_ und $PSItem sind synonym. Microso hat
$PSItem eingeführt, weil einige Benutzer das Feedback gaben, dass $_
zu (Zitat) "magisch" sei.


```
ACHTUNG: Die PowerShell erlaubt beliebig lange Pipelines
und es gibt auch Menschen, die sich einen Spaß daraus
machen, möglichst viel durch eine einzige Befehlsfolge mit
sehr vielen Pipes auszudrücken. Solche umfangreichen
Befehlsfolgen sind aber meist für andere Menschen extrem
schlecht lesbar. Bitte befolgen Sie daher den folgenden
Ratschlag: Schreiben Sie nicht alles in eine einzige
Befehlsfolge, nur weil es geht. Teilen Sie besser die
Befehlsfolgen nach jeweils drei bis vier Pipe-Symbolen durch
den Einsatz von Variablen auf (wird in diesem Kapitel auch
beschrieben!) und lassen Sie diese geteilten Befehlsfolgen
dann besser als PowerShell-Skripte ablaufen (siehe das Kapitel
"PowerShell-Skripte").
```
5.3.NET-Objekte in der Pipeline

Objektorientierung ist die herausragende Eigenscha der PowerShell:
Commandlets können durch Pipelines mit anderen Commandlets
verbunden werden. Anders als Pipelines in Unix-Shells tauschen die
Commandlets der PowerShell keine Zeichenketten, sondern typisierte
.NET-Objekte aus. Das objektorientierte Pipelining ist im Gegensatz
zum in den Unix-Shells und in der normalen Windows-Shell (cmd.exe)
verwendeten zeichenkettenbasierten Pipelining nicht abhängig von
der Position der Informationen in der Pipeline.

Ein Commandlet kann auf alle Attribute und Methoden der .NET-
Objekte, die das vorhergehende Commandlet in die Pipeline gelegt
hat, zugreifen. Die Mitglieder der Objekte können entweder durch
Parameter der Commandlets (z. B. in Sort-Object Length) oder durch
den expliziten Verweis auf das aktuelle Pipeline-Objekt ($_) in einer


Schleife oder Bedingung (z. B. Where-Object { $_.Length -gt 40 000
}) genutzt werden.

In einer Pipeline wie

```
Get-Process | Where-Object {$_.name -eq "iexplore"} | Format-T
able ProcessName,
WorkingSet 64
```
ist das dritte Commandlet daher nicht auf eine bestimmte Anordnung
und Formatierung der Ausgabe von vorherigen Commandlets
angewiesen, sondern es grei über den sogenannten Reflection-
Mechanismus (den eingebauten
Komponentenerforschungsmechanismus des .NET Frameworks)
direkt auf die Eigenschaen der Objekte in der Pipeline zu.

```
HINWEIS: Genau genommen bezeichnet Microso das
Verfahren als "Extended Reflection" bzw. "Extended Type
System (ETS)", weil die PowerShell in der Lage ist, Objekte um
zusätzliche Eigenschaen anzureichern, die in der
Klassendefinition gar nicht existieren.
```
Im obigen Beispiel legt Get-Process ein .NET-Objekt der Klasse
System.Diagnostics. Process für jeden laufenden Prozess in die
Pipeline. System. Diagnostics.Process ist eine Klasse aus der .NET-
Klassenbibliothek. Commandlets können aber jedes beliebige .NET-
Objekt in die Pipeline legen, also auch einfache Zahlen oder
Zeichenketten, da es in .NET keine Unterscheidung zwischen
elementaren Datentypen und Klassen gibt. Eine Zeichenkette in die
Pipeline zu legen, wird aber in der PowerShell die Ausnahme bleiben,
denn der typisierte Zugriff auf Objekte ist wesentlich robuster
gegenüber möglichen Änderungen als die Zeichenkettenauswertung
mit regulären Ausdrücken.


Deutlicher wird der objektorientierte Ansatz, wenn man als Attribut
keine Zeichenkette heranzieht, sondern eine Zahl. WorkingSet 64 ist ein
64 Bit langer Zahlenwert, der den aktuellen Speicherverbrauch eines
Prozesses repräsentiert. Der folgende Befehl liefert alle Prozesse, die
aktuell mehr als 20 Megabyte verbrauchen:

```
Get-Process | Where-Object {$_.WorkingSet 64 - gt 20 * 1024 * 1024 }
```
Anstelle von 20*1024*1024 hätte man auch das Kürzel "20MB"
einsetzen können. Außerdem kann man Where-Object mit einem
Fragezeichen abkürzen. Die kurze Variante des Befehls wäre dann
also:

```
ps |? {$_.ws -gt 20 MB }
```
Wenn nur ein einziges Commandlet angegeben ist, dann wird das
Ergebnis auf dem Bildschirm ausgegeben. Auch wenn mehrere
Commandlets in einer Pipeline zusammengeschaltet sind, wird das
Ergebnis des letzten Commandlets auf dem Bildschirm ausgegeben.
Wenn das letzte Commandlet keine Daten in die Pipeline wir, erfolgt
keine Ausgabe.

5.4 Pipeline Processor

Für die Übergabe der .NET-Objekte zwischen den Commandlets sorgt
der PowerShell Pipeline Processor (siehe folgende Grafik). Die
Commandlets selbst müssen sich weder um die Objektweitergabe
noch um die Parameterauswertung kümmern.


Bild 5.1 Der Pipeline Processor befördert die Objekte vom Upstream-Commandlet zum
Downstream-Commandlet. Die Verarbeitung ist in der Regel asynchron.

Wie das obige Bild schon zeigt, beginnt ein nachfolgendes
Commandlet mit seiner Arbeit, sobald es ein erstes Objekt aus der
Pipeline erhält. Das Objekt durchläu die komplette Pipeline. Erst
dann wird das nächste Objekt vom ersten Commandlet abgeholt. Man
nennt dies "Streaming-Verarbeitung". Streaming-Verarbeitung ist
schneller als die klassische sequentielle Verarbeitung, weil die
folgenden Commandlets in der Pipeline nicht auf vorhergehende
warten müssen.

```
HINWEIS: Intern arbeitet die einem Thread, d. h. es findet
keine parallele Verarbeitung mehrerer Befehle statt. Erst seit
PowerShell 7.0 gibt es mit dem Parameter -parallel bei
Foreach-Command eine einfache Möglichkeit, jedes Objekt in
einem eigenen Thread zu verarbeiten.
```

Aber nicht alle Commandlets beherrschen die asynchrone Streaming-
Verarbeitung. Commandlets, die alle Objekte naturgemäß erst mal
kennen müssen, bevor sie überhaupt ihren Zweck erfüllen können (z.
B. Sort-Object zum Sortieren und Group-Object zum Gruppieren),
blockieren die asynchrone Verarbeitung.

```
HINWEIS: Es gibt auch einige Commandlets, die zwar
asynchron arbeiten könnten, aber leider nicht so
programmiert wurden, um dies zu unterstützen.
```
Bild 5.2 Sort-Object blockiert die direkte Weitergabe. Erst wenn alle Objekte angekommen
sind, kann das Commandlet sortieren.

Auch bei Commandlets, die Streaming-Verarbeitung unterstützen
kann der PowerShell- Nutzer mit dem allgemeinen Parameter -
OutBuffer (abgekürzt -ob), das jedes Commandlet anbietet, dafür


sorgen, dass eine bestimmte Anzahl von Objekten angesammelt wird
bevor eine Weitergabe an das nachfolgende Commandlet erfolgt.

Im Standard beginnt die Ausgabe der Ordner- und Dateinamen sofort:

```
dir c:\ - Recurse | ft name
```
In diesem Fall passiert lange nichts, bevor die Ausgabe beginnt:

```
dir c:\ - Recurse -OutBuffer:100000 | ft name
```
5.5 Pipelining von Parametern

Die Pipeline kann jegliche Art von Information befördern, auch
einzelne elementare Daten. Einige Commandlets unterstützen es, dass
auch die Parameter aus der Pipeline ausgelesen werden. Der folgende
Pipeline-Befehl führt zu einer Auflistung aller Windows-
Systemdienste, die mit dem Buchstaben "I" beginnen.

```
"i*" | Get-Service
```
Die folgende Abbildung zeigt einige Parameter des Commandlets Get-
Service. Diese Liste erhält man durch den Befehl Get-Help Get-
Service -Parameter *.


Bild 5.3 Hilfe zu den Parametern des Commandlets Get-Service

Interessant sind die mit Pfeil markierten Stellen. Nach "Accept
pipeline Input" kann man jeweils nachlesen, ob der Parameter des
Commandlets aus den vorhergehenden Objekten in der Pipeline
"befüttert" werden kann.

Bei "-Name" steht ByValue und ByPropertyName. Dies bedeutet, dass der
Name sowohl das ganze Objekt in der Pipeline sein darf als auch Teil
eines Objekts.

Im Fall von

```
"BITS" | Get-Service
```

ist der Pipeline-Inhalt eine Zeichenkette (ein Objekt vom Typ String),
die als Ganzes auf Name abgebildet werden kann.

Es funktioniert aber auch folgender Befehl, der alle Dienste ermittelt,
deren Name genauso lautet wie der Name eines laufenden Prozesses:

```
Get-Process | Get-Service -ea silentlycontinue | ft name
```
Dies funktioniert über die zweite Option (ByPropertyName), denn Get-
Process liefert Objekte des Typs Process, die ein Attribut namens Name
haben. Der Parameter Name von Get-Service wird auf dieses Name-
Attribut abgebildet.

Beim Parameter -InputObject ist hingegen nur "ByValue" angegeben.
Hier erwartet Get-Service gerne Instanzen der Klasse
ServiceController. Es gibt aber keine Objekte, die ein Attribut namens
InputObject haben, in dem dann ServiceController-Objekte stecken.

Zahlreiche Commandlets besitzen einen Parameter -InputObject,
insbesondere die allgemeinen Verarbeitungs-Commandlets wie
Where-Object, Select-Object und Measure-Object, die Sie im nächsten
Kapitel kennenlernen werden. Der Name - InputObject ist eine
Konvention.

Bild 5.4 Parameter des Commandlets Where-Object


Leider geht es nicht bei allen Commandlets so einfach mit der
Parameterübergabe. Man nehme zum Beispiel das Commandlet Test-
Connection, dass prü, ob ein Computer per Ping erreichbar ist.

Der normale Aufruf mit Parameter ist:

```
Test-Connection -computername Server 123
```
oder ohne benannten Parameter

```
Test-Connection Server 123
```
Nun könnte man auf die Idee kommen, hier den Computernamen
genau so zu übergeben, wie den Namen bei Get-Service. Allerdings
liefert "Server123" | Test-Connection den Fehler: "The input object
cannot be bound to any parameters for the command either because
the command does not take pipeline input or the input and its
properties do not match any of the parameters that take pipeline
input.".

Warum das nicht geht, kann man in der Hilfe zum Parameter
ComputerName des Commandlets Test-Connection erkennen. Dort steht,
dass ComputerName nur als "ByPropertyName" akzeptiert wird und
nicht wie beim Parameter Name beim Commandlet Get-Service auch
"ByValue". Das bedeutet also, dass man erst ein Objekt mit der
Eigenscha ComputerName konstruieren und dann übergeben muss:

```
New-Object psobject -Property @{Computername="Server123"} | Te
st-Connection
```
Das funktioniert zwar, ist aber hässlich und umständlich. Warum Test-
Connection und einige andere Commandlets die Eingaben nicht
"ByValue" unterstützen, wusste übrigens das Power-Shell-
Entwicklungsteam auf Nachfrage auch nicht zu beantworten. Die
Schuld liegt hier vermutlich bei dem einzelnen Entwickler bei
Microso, der die Commandlets implementiert hat.


Bild 5.5 Hilfe zum Parameter ComputerName des Commandlets Test-Connection

5.6 Pipelining von klassischen Befehlen

Grundsätzlich dürfen auch klassische Kommandozeilenanwendungen
in der PowerShell verwendet werden. Wenn man einen Befehl wie
netstat.exe oder ping.exe ausführt, dann legen diese eine Menge von
Zeichenketten in die Pipeline: Jede Ausgabezeile ist eine Zeichenkette.

Diese Zeichenketten kann man sehr gut mit dem Commandlet Select-
String auswerten. Select-String lässt nur diejenigen Zeilen die
Pipeline passieren, die auf den angegebenen regulären Ausdruck
zutreffen.

```
TIPP: Die Syntax der regulären Ausdrücke in .NET wird im
Kapitel "PowerShell-Skriptsprache" noch etwas näher
beschrieben werden.
```
In dem folgenden Beispiel werden nur diejenigen Zeilen der Ausgabe
von netstat.exe gefiltert, die einen Doppelpunkt gefolgt von den
Ziffern 59 und zwei weiteren Ziffern enthalten.

Die Hervorhebung der Treffer durch Negativschri gibt es erst seit
PowerShell 7.0.


Bild 5.6 Einsatz von Select-String zur Filterung von Ausgaben klassischer
Kommandozeilenwerkzeuge

Ein weiteres Beispiel ist das Filtern der Ausgaben von ipconfig.exe.
Der nachfolgende Befehl liefert nur die Zeilen zum Thema IPV4:

```
ipconfig.exe /all | select-string IPV 4
```
Bild 5.7 Abbildung: Ausführung des obigen Befehls

Es gibt aber leider klassische Kommandozeilenbefehle, die inhaltliche
Informationen über Farben statt über Texte transportieren. Ein
schlechtes Beispiel ist hier:

```
git branch -a
```
Der Befehl git branch -a liefert eine Liste aller Git-Branches in einem
lokalen Git-Repository als farblich verschieden markierte Textzeilen.


Eine schwarze Ausgabe (erste beide Zeilen) bedeutet, dass es für den
Remote-Branch auch einen lokalen Branch gibt. Eine rote Ausgabe
(Zeile 3 bis 8, hier im Buch aufgrund des Schwarz-Weiß-Drucks leider
nicht zu sehen) bedeutet dabei, dass ein Remote-Branch noch kein
lokales Äquivalent besitzt.

Man kann diesen Befehl zwar in der PowerShell ausführen und sieht
dort auch die Farben. Aber eine Weiterverarbeitung per Pipeline mit
dem Ziel "Lege einen lokalen Branch an für alle Branches, die lokal
noch nicht existieren", ist nicht möglich.

Man kann lediglich git branch für alle ausführen. Hierbei muss man
nicht nur filtern, sondern auch mit Trim() die Leerzeichen zu Beginn
eliminieren:

```
git branch -a |? { $_ - like "*remotes*" - and $_ - notlike "*HE
AD*" }| % { git branch
--track ${remote#origin/} $_.Trim() }
```
oder

```
git branch -a | sls -pattern "remotes" | sls -pattern "HEAD" -
NotMatch | % { git
branch --track ${remote#origin/} $_.Line.Trim() }
```
Man bekommt aber immer eine Fehlermeldung für die schon
existierenden lokalen Branches.


5.7 Zeilenumbrüche in Pipelines

Wenn sich ein Pipeline-Befehl über mehrere Zeilen erstrecken soll,
kann man dies auf mehrere Weisen bewerkstelligen:

```
Man beendet die Zeile mit einem Pipe-Symbol [|] und drückt
EINGABE. PowerShell-Standardkonsole und PowerShell-ISE-
Konsole erkennen, dass der Befehl noch nicht abgeschlossen ist,
und erwarten weitere Eingaben. Die Standardkonsole zeigt dies
auch mit >>> an.
Man kann am Ende einer Zeile mit einem Gravis [`], ASCI-Code 96,
bewirken, dass die nächste Zeile mit zum Befehl hinzugerechnet
wird (Zeilenumbruch in einem Befehl). Das funktioniert in allen
PowerShell-Hosts und auch in PowerShell-Skripten.
```
Bild 5.8 Zeilenumbruch nach Pipeline-Symbol

5.8 Schleifen


Ein wichtiges Commandlet ist

```
Foreach-Object { $_... }
```
Alias:

```
% { $_... }
```
Foreach-Object führt eine Schleife (Iteration) über alle Objekte in der
Pipeline aus. Der Befehlsblock {... } wird für jedes Objekt in der
Pipeline einmal ausgeführt. Das jeweils aktuelle Objekt, das an der
Reihe ist, erhält man über die eingebaute Variable $_. $_ ist die
Abkürzung für $PSItem. Beide Schreibweisen haben die gleiche
Funktion.

5.8.1 Notwendigkeit für Foreach-Object

Der Einsatz von Foreach-Object ist in Pipelines nicht notwendig, wenn
das nachfolgende Commandlet die Objekte des vorherigen
Commandlets direkt verarbeiten kann.

Beispiele:

```
Get-ChildItem Bu* | Remove-Item
Get-Service BI* | Start-Service
Get-Process chrome | Stop-Process
```
Gleichwohl könnte man in diesen Fällen Foreach-Object einsetzen,
was den Befehl aber verlängert:

```
Get-ChildItem Bu* | Foreach-Object { Remove-item $_.FullName }
Get-Service BI* | Foreach-Object { Start-Service $_ }
Get-Process chrome | Foreach-Object { Stop-Process $_ }
```

Es liegt an den Eigenarten des jeweiligen Commandlets, ob sie als
Standardparameter das gesamte Objekt ($_) oder eine bestimmte
Eigenscha ($_.Fullname) erwarten.

In manchen Situationen ist der Einsatz von Foreach-Object aber auch
nicht möglich, denn man will mit Sort-Object die ganze Menge
sortieren und nicht jedes Objekt einzeln:

```
"------------ richtig:"
Get-Service x* | Sort-Object name
"------------ falsch:"
Get-Service x* | Foreach-Object { Sort-Object $_.Name }
```
Schließlich gibt es Fälle, in denen Foreach-Object zwingend eingesetzt
werden muss. Dies gilt insbesondere, wenn das nachfolgende
Commandlet die Objekte nicht verarbeiten kann. Zudem quittiert die
PowerShell diesen Befehl

```
Get-Service BI* | Write-Host $_.DisplayName -ForegroundColor y
ellow
```
mit dem Laufzeitfehler "The input object cannot be bound to any
parameters for the command either because the command does not
take pipeline input or the input and its properties do not".

Richtig ist:

```
Get-Service BI* | foreach-object { Write-Host $_.DisplayName -
ForegroundColor Yellow }
```
Ebenso ist Foreach-Object notwendig, wenn mehrere Befehle (also
ganzer Befehlsblock) ausgeführt werden sollen. Befehlsblöcke werden
in den Kapiteln "PowerShell-Skripte" und "PowerShell-Skriptspache"
erläutert.


```
Get-Service BI* | foreach-object {
if ($_.Status -eq "Stopped")
{
Write-Host "Beendet Dienst " $_.DisplayName -ForegroundC
olor Yellow
Start-Service $_
}
else
{
Write-Host "Starte Dienst " $_.DisplayName -ForegroundC
olor Yellow
Stop-Service $_
}
}
```
5.8.2 Parallelisierung mit Multithreading

In PowerShell 1.0 bis 6.2 erfolgt die Ausführung im Hauptthread der
PowerShell, d. h., die einzelnen Durchläufe erfolgen nacheinander.
Seit PowerShell 7.0 kann man mit dem Parameter -parallel die
Ausführung auf verschiedene Threads parallelisieren (via
Multithreading), sodass bei längeren Operationen in Summe das
Ergebnis schneller vorliegt.

```
ACHTUNG: Die Multithreading hat immer einigen Overhead.
Die Parallelisierung lohnt sich nur bei länger dauernden
Operationen. Bei kurzen Operationen ist der Zeitverlust durch
die Erzeugung und Vernichtung der Threads höher als der
Zeitgewinn durch die Parallelisierung.
```

Das folgende Beispiel zeigt zwei Varianten der Abfrage, ob die
Soware "Classic Shell" auf drei verschiedenen Computern installiert
ist. Bei der ersten Variante ohne -parallel wird die leider etwas
langwierige Abfrage der WMI-Klasse Win32_Product auf den drei
Computern nacheinander in dem gleichen Thread ausgeführt. Bei der
zweiten Variante mit -parallel wird die Abfrage parallel in drei
verschiedenen Threads gestartet! Die Parallelisierung ist erst möglich
seit PowerShell 7.0.

```
TIPP: Die Nummer des Threads fragt man ab mit der .NET-
Klasse Thread: [System.
Threading.Thread]::CurrentThread.ManagedThreadId
```

Listing 5.1 [\PowerShell\1_Basiswissen\Pipelining\Schleifen.ps1]

```
Write-Host "# ForEach-Object ohne -parallel" - ForegroundColor
Yellow
"E27","E29","E44" | ForEach-Object {
"Abfrage bei Computer $_ in Thread $([System.Threading.Thr
ead]::CurrentThread.
ManagedThreadId)"
$e = Get-CimInstance -Class Win32_
Product -Filter "Name='Classic Shell'" - computername $_
if ($e -eq $null) { "Kein Ergebnis bei $_!"}
else { $e }
}
Write-host ""
Write-host " # ForEach-Object mit -parallel" - ForegroundColor
Yellow
"E27","E29","E44" | ForEach-Object -parallel {
"Abfrage bei Computer $_ in Thread
$([System.Threading.Thread]::CurrentThread.
ManagedThreadId)"
$e = Get-CimInstance -Class Win32_
Product -Filter "Name='Classic Shell'" - computername $_
if ($e -eq $null) { "Kein Ergebnis bei $_!"}
else { $e }
}
# ohne Read-
Host würde das Skript die später eingehenden Ergebnisse nicht
mehr anzeigen!
read-host
```

Bild 5.9 Parallelität bei Foreach-Object in PowerShell 7

Die Anzahl der Threads, die Foreach-Object nutzen soll, kann man mit
dem Parameter -ThrottleLimit begrenzen:

```
1..20 | ForEach-Object -parallel {
Write-host "Objekt #$_ in Thread $([System.Threading.Threa
d]::CurrentThread.
ManagedThreadId)"
sleep -Seconds 2 } - ThrottleLimit 5
```
5.9 Zugriff auf einzelne Objekte aus

einer Menge

Es ist möglich, gezielt einzelne Objekte über ihre Position (Index) in
der Pipeline anzusprechen. Die Positionsangabe ist in eckige
Klammern zu setzen und die Zählung beginnt bei 0. Der Pipeline-
Ausdruck ist in runde Klammern zu setzen.

Beispiele:

Der erste Prozess:

```
(Get-Process)[ 0 ]
```

Der dreizehnte Prozess:

```
(Get-Process)[ 12 ]
```
Alternativ kann man dies auch mit Select-Object unter Verwendung
der Parameter -First und -Skip ausdrücken:

```
(Get-Process i* | Select-Object -first 1 ).name
(Get-Process i* | Select-Object -skip 12 - first 1 ).name
```
```
HINWEIS: Während (Get-Date)[ 0 ] in PowerShell vor Version
3.0 zu einem Fehler führt ("Unable to index into an object of
type System.DateTime."), weil Get-Date keine Menge liefert, ist
der Befehl seit PowerShell-Version 3.0 in Ordnung und liefert
das gleiche Ergebnis wie Get-Date, da die PowerShell seit
Version 3.0 ja aus Benutzersicht ein einzelnes Objekt und eine
Menge von Objekten gleich behandelt. (Get-Date)[ 1 ] liefert
dann natürlich kein Ergebnis, weil es kein zweites Objekt in der
Pipeline gibt.
```
Die Positionsangaben kann man natürlich mit Bedingungen
kombinieren. So liefert dieser Befehl den dreizehnten Prozess in der
Liste der Prozesse, die mehr als 20 MB Hauptspeicher brauchen:

```
(Get-Process | where-object { $_.WorkingSet 64 - gt 20 mb } )[ 12 ]
```

Bild 5.10 Zugriff auf einzelne Prozessobjekte

5.10 Zugriff auf einzelne Werte in

einem Objekt

Manchmal möchte man nicht ein komplettes Objekt bzw. eine
komplette Objektmenge verarbeiten, sondern nur eine einzelne
Eigenscha.

Oben wurde bereits gezeigt, wie man mit den Format-Commandlets
wie Format-Table auf einzelne Eigenschaen zugreifen kann:

```
Get-Process | Format-Table ProcessName, WorkingSet 64
```
Hat man nur ein einzelnes Objekt in Händen, geht das ebenfalls:

```
(Get-Process)[ 0 ] | Format-Table ProcessName, WorkingSet 64
```
Format-Table liefert aber immer eine bestimmte Ausgabe, eben in
Tabellenform mit Kopfzeile.


5.10.1 Punkt-Operator

Wenn man wirklich nur den Inhalt einer bestimmten Eigenscha eines
Objekts haben möchte, so verwendet man den in objektorientierten
Sprachen üblichen Punkt-Operator, d. h., man trennt das Objekt und
die abzurufende Eigenscha durch einen Punkt (Punktnotation).

Beispiele:

```
(Get-Process)[ 0 ].Processname
```
Die Ausgabe ist eine einzelne Zeichenkette mit dem Namen des
Prozesses.

```
(Get-Process)[ 0 ].WorkingSet 64
```
Die Ausgabe ist eine einzelne Zahl mit der Speichernutzung des
Prozesses.

Mit den Einzelwerten kann man weiterrechnen, z. B. errechnet man so
die Speichernutzung in Megabyte:

```
(Get-Process)[ 0 ].WorkingSet 64 / 1 MB
```
Bild 5.11 Ausgabe zu den obigen Beispielen

Weitere Anwendungsfälle seien am Beispiel Get-Date gezeigt. Date,
TimeOfDay, Year, Day, Month, Hour und Minute sind einige der zahlreichen


Eigenschaen der Klasse DateTime, die Get-Date liefert.

Bild 5.12 Zugriff auf einzelne Werte aus dem aktuellen Datum/der aktuellen Zeit

5.10.2 Null-Werte

Zu beachten ist, dass PowerShell-Objekte, wie in objektorientierten
Sprachen üblich, den Null-Wert (in PowerShell: $null) annehmen
können mit der Interpretation, dass ein Objekt nicht vorhanden ist.
Anders als in den meisten objektorientierten Sprachen führt die
Anwendung des Punkt-Operators auf Null-Werte aber nicht
zwangsläufig zu einem Laufzeitfehler. Die PowerShell ist sehr tolerant:


```
Wenn man einen Null-Wert ausgibt, bekommt man keine
Ausgabe.
Wenn man in der Pipeline auf einen Null-Wert den Punkt-Operator
anwendet, wird der Laufzeitfehler unterdrückt und man erhält
keine Ausgabe.
```
Die PowerShell ist aber nicht in allen Fällen gegenüber der
Anwendung des Punkt-Operators auf Variablen mit Wert $null tolerant
(siehe folgende Abbildung).

Bild 5.13 Null-Werte in der PowerShell

5.10.3 Einzelne Werte aus allen Objekten einer

Objektmenge

Wenn man einen einzelnen Wert aus allen Objekten aus einer
Objektmenge ausgeben wollte, so konnte man das bis PowerShell 2.0
nur über ein nachgeschaltetes Foreach-Object lösen, wobei innerhalb
von Foreach-Object mit $_ auf das aktuelle Objekt der Pipeline zu
verweisen war:


```
Get-Process | Foreach-Object {$_.Name }
```
Das geht seit PowerShell-Version 3.0 wesentlich prägnanter und
eleganter:

```
(Get-Process).Name
```
Oder

```
(Get-Process).WorkingSet
```
Weiterhin muss man Foreach-Object anwenden für eine kombinierte
Ausgabe:

```
Get-Process | Foreach-Object {$_.Name + ": " + $_.Workingset }
```
Mancher könnte denken, dass

```
(Get-Process).Name + ":" + (Get-Process).WorkingSet
```
auch als Schreibweise möglich wäre. Das liefert aber weder optisch
noch inhaltlich ein korrektes Ergebnis, denn die Prozessliste wird
zweimal abgerufen und könnte sich in der Zwischenzeit geändert
haben!

5.11 Methoden ausführen

Der folgende PowerShell-Pipeline-Befehl beendet alle Instanzen des
Internet Explorers auf dem lokalen System, indem das Commandlet
Stop-Process die Instanzen des betreffenden Prozesses von Get-
Process empfängt.

```
Get-Process iexplore | Stop-Process
```

Die Objekt-Pipeline der PowerShell hat noch weitere Möglichkeiten:
Gemäß dem objektorientierten Paradigma haben .NET-Objekte nicht
nur Attribute, sondern auch Methoden. In einer Pipeline kann der
Administrator daher auch die Methoden der Objekte aufrufen. Objekte
des Typs System. Diagnostics.Process besitzen zum Beispiel eine
Methode Kill(). Der Aufruf dieser Methode ist in der PowerShell
gekapselt in der Methode Stop-Process.

Wer sich mit dem .NET Framework gut auskennt, könnte die Kill()-
Methode auch direkt aufrufen. Dann ist aber eine explizite ForEach-
Schleife notwendig. Die Commandlets iterieren automatisch über alle
Objekte der Pipeline, die Methodenaufrufe aber nicht.

```
Get-Process iexplore | Foreach-Object { $_.Kill() }
```
Durch den Einsatz von Aliasen geht das auch kürzer:

```
ps |? { $_.name -eq "iexplore" } | % { $_.Kill() }
```
Und seit PowerShell-Version 3.0 kann man auf das Foreach-Object
bzw. % verzichten, also

```
(Get-Process iexplore).Kill()
```
oder

```
(ps iexplore).Kill()
```
schreiben.

Der Einsatz der Methode Kill() diente hier nur zur Demonstration,
dass die Pipeline tatsächlich Objekte befördert. Eigentlich ist die
gleiche Aufgabe besser mit dem eingebauten Commandlet Stop-
Process zu lösen.


```
ACHTUNG: Vergessen Sie beim Aufruf von Methoden nicht die
runden Klammern, auch wenn die Methoden keine Parameter
besitzen. Ohne die Klammern erhalten Sie Informationen über
die Methode, es erfolgt aber kein Aufruf.
```
```
Bild 5.14 Folgen des vergessenen Klammernpaars
```
Dies funktioniert aber nur dann gut, wenn es auch Instanzen des
Internet Explorers gibt. Wenn alle beendet sind, meldet Get-Process
einen Fehler. Dies kann das gewünschte Verhalten sein. Mit einer
etwas anderen Pipeline wird dieser Fehler jedoch unterbunden:

```
Get-Process | Where-Object { $_.Name -eq "iexplore" } |
Stop-Process
```
Die zweite Pipeline unterscheidet sich von der ersten dadurch, dass
das Filtern der Prozesse aus der Prozessliste nun nicht mehr von Get-
Process erledigt wird, sondern durch ein eigenes Commandlet mit
Namen Where-Object in der Pipeline selbst durchgeführt wird. Where-
Object ist toleranter als Get-Process in Hinblick auf die Möglichkeit,
dass es kein passendes Objekt gibt.

ps ist ein Alias für Get-Process, Kill für Stop-Process. Außerdem hat
Get-Process eine eingebaute Filterfunktion. Um alle Instanzen des
Internet Explorers zu beenden, kann man also statt


```
Get-Process | Where-Object { $_.Name -eq "iexplore" } |
Stop-Process
```
auch schreiben:

```
ps -name "iexplore" | kill
```
Weitere Beispiele für die Aufrufe von Methoden seien am Beispiel von
Get-Date gezeigt, das ja nur ein Objekt der Klasse DateTime liefert. Die
Klasse DateTime bietet zahlreiche Methoden an, um Datum und Zeit
auf bestimmte Weise darzustellen, z. B. GetShortDate String(),
GetLongDateString(), GetShortTimeString() und GetLongTimeString().
Die Ausgaben zeigt die folgende Abbildung.

Bild 5.15 Ausgaben der Methoden der Klasse DateTime

5.12 Analyse des Pipeline-Inhalts

Drei der größten Fragestellungen bei der praktischen Arbeit mit der
PowerShell sind:

```
Wie viele Objekte sind in der Pipeline? (Das wurde schon zuvor in
diesem Kapitel erörtert.)
```

```
Welchen Typ haben die Objekte, die ein Commandlet in die
Pipeline legt?
Welche Attribute und Methoden haben diese Objekte?
```
Die Hilfe der Commandlets ist hier nicht immer hilfreich. Bei Get-
Service kann man zwar lesen:

```
OUTPUTS
System.ServiceProcess.ServiceController
```
Bei anderen Commandlets aber heißt es nur wenig hilfreich:

```
OUTPUTS
Object
```
In keinem Fall sind in der PowerShell-Benutzerdokumentation (siehe
https://docs.microso.com/en-us/powershell/ und das Commandlet
Get-Help) die Attribute und die Methoden der resultierenden Objekte
genannt. Diese findet man nur in der .NET API-Dokumentation
[https://docs.microso.com/de-de/dotnet/api/].

Im Folgenden werden zwei hilfreiche Commandlets sowie zwei
Methoden und zwei Eigenschaen aus dem .NET Framework
vorgestellt, die im Alltag helfen, zu erforschen, was man in der
Pipeline hat:

```
Count und Length
ToString()
GetType()
Get-PipelineInfo
Get-Member
```

5.12.1 Anzahl der Objekte in der Pipeline mit

Count und Length

Viele Commandlets legen ganze Mengen von Objekten in die Pipeline
(z. B. Get-Process eine Liste der Prozesse und Get-Service eine Liste
der Dienste). Bei einer Objektmenge kann man, wie oben bereits
gezeigt, mit Where-Object filtern. Das Ergebnis kann ein Objekt, kein
Objekt oder eine Menge von Objekten sein.

Es kann aber auch sein, dass ein Commandlet, das normalerweise
eine Menge von Objekten liefert, im konkreten Fall (z. B. bei Einsatz
eines filternden Parameters) nur ein einzelnes Objekt liefert (z. B. Get-
Process idle). In diesem Fall liefert die PowerShell dem Benutzer
nicht eine Liste mit einem Objekt, sondern direkt das ausgepackte
Objekt.

Einige Commandlets legen aber immer nur einzelne Objekte in die
Pipeline. Ein Beispiel dafür ist Get-Date, das ein einziges Objekt des
Typs System.DateTime in die Pipeline legt. Ru man z. B. Get-Date ohne
Weiteres auf, werden das aktuelle Datum und die aktuelle Zeit
ausgegeben.

Zu differenzieren ist, ob die Pipeline ein Objekt direkt enthält oder
eine Menge, die aus einem Objekt besteht (siehe Abbildung).


Bild 5.16 Einzelobjekt versus Menge

Bis Version 2.0 der PowerShell war es so, dass man eine Liste durch
Zugriff auf Count oder Length nach der Anzahl der Elemente fragen
konnte, nicht aber ein einzelnes Objekt.

Das war also erlaubt:

```
(Get-Process).Count
```
Das führte aber zu keinem Ergebnis:

```
(Get-Process idle).Count
(Get-Date).Count
```
Seit PowerShell-Version 3.0 ist dieser Unterschied (in den meisten
Fällen) aufgehoben, man kann auch bei Einzelobjekten Count und
Length abfragen, und die PowerShell liefert dann eben bei
Einzelobjekten eine "1" zurück. Allerdings schlägt die Eingabehilfe der


PowerShell-Konsole und der PowerShell ISE weiterhin weder Count
noch Length als Möglichkeit vor!

Praxislösung: Wie viele Prozesse gibt es, die mehr als 100 MB
Hauptspeicher (RAM) verbrauchen?

```
(Get-Process | Where-Object WorkingSet 64 - gt 100 MB).Count
```
Bild 5.17 Aufruf von Count für eine Pipeline

Es gibt aber (mindestens) einen Fall, in denen Count auf einem
Einzelobjekt nicht funktioniert. Dieser Fall, der nicht dokumentiert,
mir aber in der Praxis ausgefallen ist, ist ein einzelnes PSCustomObject
in der Pipeline. Es kann sicherlich weitere solcher nicht-
dokumentierter Fälle geben. Wenn Sie Fälle kennen, schreiben Sie mir
bitte!

Das folgende Beispiel zeigt auch, wie Sie diese Anomalie umgehen: Mit
einem vorangestellten Komma macht man aus dem Einzelobjekt
(System.Management.Automation.PSCustom-Object) eine Menge mit
einem Objekt (System.Object[] mit einem System.Management.
Automation.PSCustomObject).


Listing 5.2 [\PowerShell\1_Basiswissen\Pipelining\Pipelining.ps1]

```
$prozesse = Get-Process | select -First 1
Write-Host "Anzahl Prozesse: " $prozesse.Count # 1
```
```
$zahlen = 123
Write-Host "Anzahl Zahlen: " $zahlen.Count # 1
```
```
$firma 1 = [PSCustomObject]@{
Firma = "www.IT-Visions.de"
Ort = "Essen"
}
```
```
Write-Host "Anzahl Firmen: " $firma1.Count # geht nicht! $null
$firma1.GetType().FullName # System.Management.Automation.PSCu
stomObject
if ($firma1.Count -eq $null) { Write-Warning "Count ist null!"
}
```
```
# Workaround für Anomalie: Das vorangestellte Komma macht aus
dem Einzelobjekt eine
Menge mit einem Objekt.
$firmen = , $firma 1
$firmen.GetType().FullName # System.Object[]
Write-Host "Anzahl Firmen: " $firmen.Count # 1
```

```
TIPP: Ob die Pipeline ein Einzelobjekt oder eine Menge
enthält, können Sie über den Aufruf von Count oder Length
nicht zuverlässig feststellen. Hierzu müssen Sie das der
PowerShell zu Grunde liegende .NET fragen, aus welcher
Klasse die Pipeline stammt. Dies erfolgt durch den Aufruf
.GetType().FullName. Wenn dieser Aufruf System.Object[]
liefert, ist der Inhalt ein "Array von Objekten", also eine Menge.
Die geschweien Klammern bedeuten in .NET ein "Array"
(Menge).
```
```
# Einzelobjekt
$pipeline = 1
$pipeline.GetType().FullName # System.Int 32
# Menge
$pipeline = 1,2
$pipeline.GetType().FullName # System.Object[]
```
```
Sie lernen dies im Detail noch im Kapitel "Verwendung von
.NET-Klassen".
```
5.12.2 Methode GetType()

Da jede PowerShell-Variable eine Instanz einer .NET-Klasse ist, besitzt
jedes Objekt in der Pipeline die Methode GetType(), die es von der
Mutter aller .NET-Klassen (System.Object) erbt. GetType() liefert ein
System.Type-Objekt mit zahlreichen Informationen. Meistens
interessiert man sich nur für den Klassennamen, den man aus
Fullname (mit Namensraum) oder Name (ohne Namensraum) auslesen
kann. GetType() ist eine Methode, und daher muss der Pipeline-Inhalt
in runden Klammern stehen.


Beispiele zeigt die folgende Abbildung:

Bild 5.18 Einsatz von GetType()

Erläuterung: "Name" ist der Name der Klasse, zu der die Objekte in der
Pipeline gehören. "BaseType" ist der Name der Oberklasse. .NET
unterstützt Vererbung, d. h., eine Klasse kann von einer anderen erben
(höchstens von einer anderen Klasse; Mehrfachvererbung gibt es
nicht!). Dies ist für die PowerShell jedoch zumeist irrelevant und Sie
können diese Information ignorieren.

Bei Get-Date() ist ein DateTime-Objekt in der Pipeline. Der zweite
Aufruf liefert nur die Information, dass eine Menge von Objekten in der
Pipeline ist. Bei der Anwendung von GetType() auf eine Objektmenge
in der Pipeline kann man leider noch nicht den Typ erkennen.
Hintergrund ist, dass in einer Pipeline Objekte verschiedener Klassen
sein können. Der dritte Aufruf, bei dem gezielt ein Objekt (das erste)
herausgenommen wird, zeigt dann wieder an, dass es sich um
Process-Objekte handelt. Den ganzen Klassennamen inklusive des
Namensraums bekommt man nur, wenn man explizit die Eigenscha
FullName abfragt.


5.12.3 Methode ToString()

Jedes .NET-Objekt bietet die Methode ToString(), weil diese Methode
von der Basisklasse aller .NET-Klassen System.Object an alle Klassen
vererbt wird. Das Standardverhalten von ToString() ist, dass der
Name der Klasse geliefert wird, zu der das Objekt gehört. Das heißt,
dass die Ausgabe für alle Instanzen der Klasse gleich ist.

Nur wenige Klassen überschreiben die Implementierung und liefern
eine Zeichenkette, die tatsächlich den Inhalt des Objekts wiedergibt.
Manchmal wird der Name des Objekts alleine (z. B. bei den Instanzen
der Klasse System. Diagnostics.Process, die das Commandlet Get-
Process liefert), manchmal der Name der Klasse mit dem
Objektnamen geliefert (z. B. bei den Instanzen der Klasse
System.Service.ServiceController, die das Commandlet Get-Service
liefert).

```
Listing 5.3 [Basiswissen\Pipelining\ToString.ps1]
(Get-Service).ToString() # System.Object[]
(Get-Service w*)[ 0 ].ToString() # W 32 Time
(Get-Process w*)[ 0 ].ToString() # System.Diagnostics.Process (w
ininit)
(Get-Host)[ 0 ].ToString() # System.Management.Automation.Intern
al.Host.InternalHost
(Get-Date).ToString() # liefert aktuelles Datum
```

HINWEIS: Die Konvertierung in den Klassennamen ist das
Standardverhalten, das von System. Object geerbt wird, und
dieses Standardverhalten ist leider auch üblich, da sich die
Entwickler der meisten .NET-Klassen bei Microso nicht die
"Mühe" gemacht haben, eine sinnvolle
Zeichenkettenrepräsentanz zu definieren.

ToString() ist üblicherweise keine Serialisierung des
kompletten Objektinhalts, sondern im besten Fall nur der
"Primärschlüssel" des Objekts. Theoretisch kann eine .NET-
Klasse bei ToString() alle Werte liefern. Das macht aber fast
keine .NET-Klasse. Bei vielen .NET-Klassen liefert ToString()
nur den Klassennamen.

Ob ToString() eine sinnvolle Ausgabe liefert, hängt von der
jeweiligen Klasse ab. Der Autor dieses Buchs und auch Sie als
Nutzer haben darauf keinen Einfluss für die Klassen, die
Microso und andere geschrieben haben. Sie können darauf
nur in den Klassen Einfluss nehmen, die Sie selbst schreiben.


Bild 5.19 Anwendung von ToString() auf Instanzen verschiedener Klassen

5.12.4 Get-PipelineInfo

Das Commandlet Get-PipelineInfo aus den PowerShell Extensions
von [http://www.IT-Visions.de](http://www.IT-Visions.de) liefert drei wichtige Informationen über die
Pipeline-Inhalte:

```
Anzahl der Objekte in der Pipeline (die Objekte werden
durchnummeriert)
Typ der Objekte in der Pipeline (ganzer Name der .NET-Klasse)
Zeichenkettenrepräsentation der Objekte in der Pipeline
```

Bild 5.20 Get-PipelineInfo liefert Informationen, dass sich in dem Dateisystemordner elf
Objekte befinden. Davon sind sieben Unterordner (Klasse DirectoryInfo) und vier Dateien
(Klasse FileInfo).

Das Stichwort Zeichenkettenrepräsentation (Spalte "String" in der
Abbildung) ist erklärungsbedürig: Dies ist die
Zeichenkettenrepräsentation mit ToString()

5.12.5 Get-Member

Das eingebaute Commandlet Get-Member (Alias: gm) ist sehr hilfreich: Es
zeigt den .NET-Klassennamen für die Objekte in der Pipeline sowie die
Attribute und Methoden dieser Klasse. Für GetProcess | Get-Member ist
die Ausgabe so lang, dass man dazu zwei Bildschirmabbildungen
braucht.

```
HINWEIS: Wenn sich mehrere verschiedene Objekttypen in der
Pipeline befinden, werden die Mitglieder aller Typen
ausgegeben, gruppiert durch die Kopfsektion, die mit
"TypeName:" beginnt.
```

Bild 5.21 Teil 1 der Ausgabe von Get-Process | Get-Member


Bild 5.22 Teil 2 der Ausgabe von Get-Process | Get-Member

Die Ausgabe zeigt, dass aus der Sicht der PowerShell eine .NET-Klasse
sieben Arten von Mitgliedern hat:

1. Method (Methode)
2. Property (Eigenscha)
3. PropertySet (Eigenschassatz)
4. NoteProperty (Notizeigenscha)
5. ScriptProperty (Skripteigenscha)


6. CodeProperty (Codeeigenscha)
7. AliasProperty (Aliaseigenscha)

```
HINWEIS: Von den oben genannten Mitgliedsarten sind nur
"Method" und "Property" tatsächliche Mitglieder der .NET-
Klasse. Alle anderen Mitgliedsarten sind Zusätze, welche die
PowerShell mittels des sogenannten Extended Type System
(ETS) dem .NET-Objekt hinzugefügt hat.
```
Die Ausgabe von Get-Member kann man verkürzen, indem man nur eine
bestimmte Art von Mitgliedern ausgeben lässt. Diese erreicht man
über den Parameter -Membertype (kurz: - m). Der folgende Befehl listet
nur die Properties auf:

```
Get-Process | Get-Member -Membertype Properties
```
Außerdem ist eine Filterung beim Namen möglich:

```
Get-Process | Get-Member *set*
```
Der obige Befehl listet nur solche Mitglieder der Klasse Process auf,
deren Name das Wort "set" enthält.

5.12.6 Methoden (Mitgliedsart Method)

Methoden (Mitgliedsart Method) sind Operationen, die man auf dem
Objekt aufrufen kann und die eine Aktion auslösen, z. B. beendet
Kill() den Prozess. Methoden können aber auch Daten liefern oder
Daten in dem Objekt verändern.


```
ACHTUNG: Beim Aufruf von Methoden sind immer runde
Klammern anzugeben, auch wenn es keine Parameter gibt.
Ohne die runden Klammern erhält man Informationen über die
Methode, man ru aber nicht die Methode selbst auf.
```
5.12.7 Eigenschaen (Mitgliedsart Property)

Eigenschaen (Mitgliedsart Property) sind Datenelemente, die
Informationen aus dem Objekt enthalten oder mit denen man
Informationen an das Objekt übergeben kann, z. B. MaxWorkingSet.

```
ACHTUNG: In PowerShell 1.0 sah die Aussage von Get-Member
noch etwas anders aus (siehe nächste Abbildung). Man sieht
dort, dass es zu jedem Property zwei Methoden gibt, z. B.
get_MaxWorkingSet() und set_MaxWorkingSet(). Die Ursache
dafür liegt in den Interna des .NET Frameworks: Dort werden
Properties (nicht aber sogenannte Fields, eine andere Art von
Eigenschaen) durch ein Methodenpaar abgebildet: eine
Methode zum Auslesen der Daten (genannt "Get-Methode"
oder "Getter"), eine andere Methode zum Setzen der Daten
(genannt "Set-Methode" oder "Setter"). Einige Anfänger störte
die "Aufblähung" der Liste durch diese Optionen. Seit
PowerShell 2.0 zeigte Get-Member die Getter-Methoden (get_)
und Setter-Methoden (set_) nur noch an, wenn man den
Parameter -force verwendet.
```

Bild 5.23 Anzeige der Getter und Setter in PowerShell 1.0

Fortgeschrittene Benutzer bevorzugen die Auflistung der Getter und
Setter. Man kann erkennen, welche Aktionen auf einem Property
möglich sind. Fehlt der Setter, kann die Eigenscha nicht verändert
werden (z. B. StartTime bei der Klasse Process). Fehlt der Getter, kann
man die Eigenscha nur setzen. Dafür gibt es kein Beispiel in der
Klasse Process. Dieser Fall kommt auch viel seltener vor, wird aber z.
B. bei Kennwörtern eingesetzt, die man nicht wiedergewinnen kann,
weil sie nicht im Klartext, sondern nur als Hash-Wert abgespeichert
werden.

Für den PowerShell-Nutzer bedeutet die Existenz von Gettern und
Settern, dass er zwei Möglichkeiten hat, Daten abzurufen. Über die
Eigenscha (Property):


```
Get-Process | Where-Object { $_.name -eq "iexplore" } | Foreac
h-Object
{ $_.PriorityClass }
```
oder die entsprechende "Get"-Methode:

```
Get-Process | Where-Object { $_.name -eq "iexplore" } | Foreac
h-Object
{ $_.get_PriorityClass() }
```
Analog gibt es für das Schreiben die Option über die Eigenscha:

```
Get-Process | Where-Object { $_.name -eq "iexplore" } | Foreac
h-Object
{ $_.PriorityClass = "High" }
```
oder die entsprechende "Set"-Methode:

```
Get-Process | Where-Object { $_.name -eq "iexplore" } | Foreac
h-Object
{ $_.set_PriorityClass("High") }
```

```
TIPP: Auch hier kann man wieder grundsätzlich die verkürzte
Schreibweise seit PowerShell-Version 3.0 anwenden, also:
```
```
(Get-Process | Where-Object { $_.name -eq "iexplore"
}).PriorityClass
(Get-Process | Where-Object { $_.name -eq "iexplore"
}).get_
PriorityClass()
(Get-Process | Where-Object { $_.name -eq "iexplore"
}).set_
PriorityClass("High")
```
Syntaktisch nicht erlaubt ist aber:

```
(Get-Process | Where-Object { $_.name -eq "iexplore"
}).PriorityClass = "
High"
```
Hier geht nur die o. g. Schreibweise mit Foreach-Object.

5.12.8 Eigenschassätze (PropertySet)

Eigenschassätze (PropertySet) sind eine Zusammenfassung einer
Menge von Eigenschaen unter einem gemeinsamen Dach.
Beispielsweise umfasst der Eigenschassatz psResources alle
Eigenschaen, die sich auf den Ressourcenverbrauch eines Prozesses
beziehen. Dies ermöglicht es, dass man nicht alle diesbezüglichen
Eigenschaen einzeln nennen muss, sondern schreiben kann:

```
Get-Process | Select-Object psResources | Format-Table
```

Die Eigenschassätze gibt es nicht im .NET Framework; sie sind eine
Eigenart der PowerShell und definiert in der Datei types.ps 1 xml im
Installationsordner der PowerShell.

Bild 5.24 Verwendung des Eigenschassatzes "psResources"


Bild 5.25 Definition der Eigenschassätze für die Klasse System.Diagnostics.Process in
types.ps 1 ml

5.12.9 Notizeigenschaen (NoteProperty)

Notizeigenschaen (NoteProperties) sind zusätzliche
Datenelemente, die nicht dem .NET-Objekt entstammen, sondern
welche die PowerShell-Infrastruktur hinzugefügt hat. Im Beispiel der
Ergebnismenge des Commandlets Get-Process ist dies __NounName, der
einen Kurznamen der Klasse liefert. Andere Klassen haben zahlreiche
Notizeigenschaen. Notizeigenschaen gibt es nicht im .NET
Framework; sie sind eine Eigenart der PowerShell.

```
HINWEIS: Man kann einem Objekt zur Laufzeit eine
Notizeigenscha hinzufügen, siehe das Kapitel "Dynamische
Objekte".
```

5.12.10 Skripteigenschaen (ScriptProperty)

Eine Skripteigenscha (ScriptProperty) ist eine berechnete
Eigenscha, also eine Information, die nicht im .NET-Objekt selbst
gespeichert ist. Dabei muss die Berechnung nicht notwendigerweise
eine mathematische Berechnung sein; es kann sich auch um den
Zugriff auf die Eigenschaen eines untergeordneten Objekts handeln.
Der Befehl

```
Get-Process | Select-Object name, product | where { $_.product
```
- ne "" - and $_.product
- ne $null }

listet alle Prozesse mit den Produkten auf, zu denen der Prozess
gehört (siehe folgende Abbildung). Dies ist gut zu wissen, wenn man
auf seinem System einen Prozess sieht, den man nicht kennt und von
dem man befürchtet, dass es sich um einen Schädling handeln
könnte.

```
TIPP: Nicht zu allen Prozessen bekommt man eine
Produktinfo. Manchmal liefert die Eigenscha $null,
manchmal eine leere Zeichenkette. Die obige Bedingung
schließt beides aus.
```
Die Information über das Produkt steht nicht in dem Prozess
(Windows listet diese Information im Taskmanager ja auch nicht auf),
aber in der Datei, die den Programmcode für den Prozess enthält. Das
.NET Framework bietet über die
MainModule.FileversionInfo.ProductName einen Zugang zu dieser
Information. Anstelle des Befehls


```
Get-Process | Select-Object name, Mainmodule.FileVersionInfo.P
roductName
```
bietet Microso durch die Skripteigenscha eine Abkürzung an. Diese
Abkürzung ist definiert in der Datei types.ps 1 xml im
Installationsordner der PowerShell.

Bild 5.26 Auflistung der berechneten Eigenscha "Product"


Bild 5.27 Definition einer Skripteigenscha in der types.ps 1 xml

Skripteigenschaen gibt es nicht im .NET Framework; sie sind eine
Eigenart der PowerShell. Man kann einem Objekt zur Laufzeit eine
Skripteigenscha hinzufügen, siehe das Kapitel "Dynamische Objekte".

5.12.11 Codeeigenschaen (Code Property)

Eine Codeeigenscha (CodeProperty) entspricht einer Script
Property, allerdings ist der Programmcode nicht als Skript in der
PowerShell-Sprache, sondern als .NET-Programmcode hinterlegt.

5.12.12 Aliaseigenscha (AliasProperty)

Eine Aliaseigenscha (AliasProperty) ist eine verkürzte Schreibweise
für ein Property. Dahinter steckt keine Berechnung, sondern nur eine
Verkürzung des Namens. Beispielsweise ist WS eine Abkürzung für
WorkingSet. Auch die Aliaseigenschaen sind in der Datei types.ps 1 xml
im Installationsordner der PowerShell definiert. Aliaseigenschaen
sind ebenfalls eine PowerShell-Eigenart.

5.12.13 Hintergrundwissen: Adapted Type

```
System (ATS)/Extended Type System
(ETS)
```

Als Extended Type System (ETS) bezeichnet Microso die Möglichkeit,
.NET-Klassen in der PowerShell um Klassenmitglieder zu erweitern,
ohne im klassischen Sinne der Objektierung von diesen Klassen zu
erben.

Als Adapted Type System (ATS) bezeichnet Microso die
grundsätzliche Anpassung von .NET-Klassen aus der .NET-
Klassenbibliothek auf die Bedürfnisse von PowerShell-Benutzern. Wie
bereits dargestellt, zeigt die PowerShell für viele .NET-Objekte mehr
Mitglieder an, als eigentlich in der .NET-Klasse definiert sind. In
einigen Fällen werden aber auch Mitglieder ausgeblendet.

Die Ergänzung von Mitgliedern per ATS wird verwendet, um bei
einigen .NET-Klassen, die Metaklassen für die eigentlichen Daten sind
(z. B. ManagementObject für WMI-Objekte, ManagementClass für WMI-
Klassen, DirectoryEntry für Einträge in Verzeichnisdiensten und
DataRow für Datenbankzeilen), die Daten direkt ohne Umweg dem
PowerShell-Nutzer zur Verfügung zu stellen.

Mitglieder werden ausgeblendet, wenn sie in der PowerShell nicht
nutzbar sind oder es bessere Alternativen durch die Ergänzungen gibt.

In der Dokumentation nimmt das PowerShell-Entwicklungsteam dazu
wie folgt Stellung:

Bild 5.28 Quelle: https://docs.microso.com/en-
us/powershell/scripting/developer/ets/overview

Dies heißt im Klartext, dass das PowerShell-Team mit der Arbeit des
Entwicklungsteams der .NET-Klassenbibliothek nicht ganz zufrieden


ist.

Das ATS verpackt grundsätzlich jedes Objekt, das von einem
Commandlet in die Pipeline gelegt wird, in ein PowerShell-Objekt des
Typs PSObject. Die Implementierung der Klasse PSObject entscheidet
dann, was für die folgenden Commandlets und Befehle sichtbar ist.

Diese Entscheidung wird beeinflusst durch verschiedene Instrumente:

```
PowerShell-Objektadapter, die für bestimmte Typen wie
ManagementObject, Management-Class, DirectoryEntry und DataRow
implementiert wurden,
die Deklarationen in der types.ps 1 xml-Datei,
in den Commandlets hinzugefügte Mitglieder,
mit dem Commandlet Add-Member hinzugefügte Mitglieder.
```
Die folgende Tabelle zeigt die .NET-Klassen, die im Standard per ATS
verändert werden:


Tabelle 5.2 .NET-Klassen mit ATS

```
PowerShell-
Wrapper
```
.NET Framework-Klasse

WMI Class System.Management.ManagementClass

WMI Object System.Management.ManagementObject

ADSI Object System.DirectoryServices.DirectoryEntry

```
ADO.NET
DataRowView
```
System.Data.DataRowView

```
ADO.NET
DataRow
```
System.Data.DataRow

XML System.Xml.XmlNode

PSObject System.Management.Automation.PSObject

PSMemberSet System.Management.Automation.PSMemberSet

COM Object System.__ComObject

.NET Object System.Object

5.13 Filtern

Nicht immer will man alle Objekte weiterverarbeiten, die ein
Commandlet liefert. Einschränkungskriterien sind Bedingungen (z. B.
nur Prozesse, bei denen der Speicherbedarf größer ist als 10 000 000
Byte) oder die Position (z. B. nur die fünf Prozesse mit dem größten


Speicherbedarf). Zur wertabhängigen Einschränkung verwendet man
das Commandlet WhereObject (Alias where).

```
Get-Process | Where-Object {$_.ws -gt 10000000 }
```
Einschränkungen über die Position definiert man mit dem Select-
Object (in dem nachfolgenden Befehl für das oben genannte Beispiel
ist zusätzlich noch eine Sortierung eingebaut, damit die Ausgabe
einen Sinn ergibt):

```
Get-Process | Sort-Object ws -desc | Select-Object -first 5
```
Analog dazu sind die kleinsten Speicherfresser zu ermitteln mit:

```
Get-Process | Sort-Object ws -desc | Select-Object -last 5
```
Mit Select-Object kann man auch eine Teilmenge aus der Mitte
auswählen, indem man am Beginn einige Elemente mit -Skip
überspringt:

```
Get-Process | Sort-Object ws -desc | Select-Object -skip 5 - fi
rst 5
```
5.13.1 Operatoren

Etwas gewöhnungsbedürig ist die Schreibweise der
Vergleichsoperatoren: Statt >= schreibt man -ge (siehe folgende
Tabelle). Die Nutzung regulärer Ausdrücke ist möglich mit dem
Operator -Match.

Dazu zwei Beispiele:

1. Der folgende Ausdruck listet alle Systemdienste, deren
Beschreibung aus zwei durch ein Leerzeichen getrennten Wörtern


besteht.

```
Get-Service | Where-Object { $_.DisplayName -match "^\w+ \w+$"
}
```
Bild 5.29 Ausgabe zu obigem Beispiel

2. Der folgende Ausdruck listet alle Prozesse, deren Namen mit einem
"i" starten und danach aus drei Buchstaben bestehen.

```
Get-Process | Where-Object { $_.ProcessName -match "^i\w{ 3 }$"
}
```
Bild 5.30 Ausgabe zu obigem Beispiel


Tabelle 5.3 Vergleichsoperatoren der PowerShell

```
Vergleich unter
Ignorierung der
Groß-/Kleinschreibung
```
```
Vergleich unter
Berücksichtigung der
Groß-/Kleinschreibung
```
Bedeutung

- lt / - ilt -clt Kleiner
- le / - ile -cle Kleiner oder
    gleich
- gt / - igt -cgt Größer
- ge / - ige -cge Größer oder
    gleich
- eq / - ieq -ceq Gleich
- ne / - ine -cne Nicht gleich
- like / - ilike -clike Ähnlichkeit
    zwischen
    Zeichenketten,
    Einsatz von
    Platzhaltern (*
    und ?) möglich
- notlike / - inotlike -cnotlike Keine
    Ähnlichkeit
    zwischen
    Zeichenketten,
    Einsatz von
    Platzhaltern (*
    und ?) möglich
- match / - imatch -cmatch


```
Vergleich mit
regulärem
Ausdruck
```
- notmatch / - inotmatch -cnotmatch Stimmt nicht
    mit regulärem
    Ausdruck
    überein
- is Typvergleich,
    z. B. (Get-Date)
    - is [DateTime]
- in -contains Ist enthalten
    in Menge
- notin -notcontains Ist nicht
    enthalten in
    Menge

Tabelle 5.4 Logische Operatoren in der PowerShell-Sprache

Logischer Operator Bedeutung

- not oder! Nicht
- and Und
- or Oder

5.13.2 Vereinfachte Schreibweise von

Bedingungen seit PowerShell 3.0


Microso hat versucht, die Schreibweise von Bedingungen nach
Where-Object seit Power-Shell-Version 3.0 zu vereinfachen.

Die Bedingung

```
Get-Service | where-object { $_.status -eq "running" }
```
kann der Nutzer seitdem vereinfacht schreiben als

```
Get-Service | where-object status -eq "running".
```
Dass auch

```
Get-Service | where-object -eq status "running"
```
und

```
Get-Service | where-object status "running" - eq
```
zum gleichen Ergebnis führen, wirkt befremdlich.

Allerdings funktioniert die neue Syntaxform nur in den einfachsten
Fällen. Bei der Verwendung von -and und -or ist die Verkürzung nicht
möglich.

So sind folgende Befehle nicht erlaubt:

```
Get-Process | Where-Object Name -eq "iexplore" - or name -eq "C
hrome" - or name -eq
"Firefox" | Stop-Process
```
```
Get-Service | where-object status -eq running -and name -like
"a*"
```
Korrekt muss es heißen:


```
Get-Process | Where-Object { $_.Name -eq "iexplore" - or $_.nam
e -eq "Chrome" - or $_.name -eq
"Firefox" } | Stop-Process
```
```
Get-Service | where-object { $_.status -eq "running" - and $_.n
ame -like "a*" }
```
Grund für das Versagen bei komplexeren Ausdrücken ist, dass
Microso die Syntaxvereinfachung über die Parameter abgebildet hat.
So wird in der einfachsten Form -eq als Parameter von where-object
betrachtet. Microso hätte da lieber den Parser grundsätzlich
überarbeiten sollen.

5.13.3 Where()-Methode seit PowerShell 4.0

In PowerShell hat Microso eine Optionen für das Filtern von Pipelines
eingebaut, die sich vor allem an fortgeschrittene PowerShell-Nutzer
richtet bzw. an Sowareentwickler, die die PowerShell nutzen.
Alternativ zum Commandlet Where-Object kann man nun auch mit
einer Where()-Methode filtern. Anstelle von

```
Get-Service a* | where status -eq "stopped"
```
oder

```
Get-Service a* | Where-Object { $_.status -eq "stopped" }
```
Ist nun auch diese Syntax möglich:

```
(Get-Service a*).Where({ $_.status -eq "stopped"})
```
Dabei ist die Eingabemenge, die auch eine Pipeline mit mehreren
Commandlets sein kann, zu klammern.


Man kann auch mehrere Bedingungen verketten:

```
(Get-Service).Where({ ($_.name.startswith("a") - or $_.name.sta
rtswith("A")) - and $_.
status -eq "stopped"})
```
Soweit bietet die Methode Where() nichts, was das Commandlet
Where-Object nicht auch könnte - nur in anderer Syntax.

Interessant sind die weiteren Optionen. Man kann bei der Where()-
Methode einen weiteren Parameter angeben: Default, First, Last,
SkipUntil, Until, Split. Dieser Parameter muss als Zeichenkette
übergeben werden.

Beispiele:

```
# Alle, bis Bedingung erfüllt
(1..10).Where({ $_ - eq 5 },'Until')
# Nur das erste Objekt, das Bedingung erfüllt, also 6
(1..10).Where({ $_ - gt 5 },'First')
# Nur das letzte Objekt, das Bedingung erfüllt, also 10
(1..10).Where({ $_ - gt 5 },'Last')
```
Sehr spannend ist die Möglichkeit, eine Menge mit Where() im Modus
'Split' in zwei Teilmengen zu teilen und als Ergebnis des Befehls direkt
zwei Ausgabevariablen zu erhalten:

```
# Teile eine Menge von Zahlen in zwei Teile
$kleiner,$groesser = (Get-Random -max 49 - Count 7 ).Where({ $_
```
- lt 30 },'Split')
"# Zahlen < 5"
$kleiner
"# Zahlen >= 5"
$groesser


```
HINWEIS: Dieses Beispiel setzt PowerShell 7.0 oder höher
voraus, da der Parameter -count bei Get-Random erst in
PowerShell 7 eingeführt wurde.
```
Bild 5.31 Gespaltene Ausgabe der Zufallszahlen

Auch komplexe Objekte kann man so mit Where() im Modus 'Split' in
Teilmengen aueilen:

```
# Teile die Dienste in zwei Teilmengen
$Running,$Stopped = (Get-Service a*).Where({$_.Status -eq 'Run
ning'},'Split')
$Running
$Stopped
```
5.14 Zusammenfassung von Pipeline-

Inhalten

Die Menge der Objekte in der Pipeline kann heterogen sein, d. h.
verschiedenen .NET-Klassen angehören. Dies ist zum Beispiel
automatisch der Fall, wenn man Get-ChildItem im Dateisystem
ausführt: Die Ergebnismenge enthält sowohl FileInfo- als auch
DirectoryInfo-Objekte.


Man kann auch zwei Befehle, die beide Objekte in die Pipeline senden,
zusammenfassen, so dass der Inhalt in einer Pipeline wie folgt
aussieht:

```
$( Get-Process ; Get-Service )
```
Dies ist aber nur sinnvoll, wenn die nachfolgenden Befehle in der
Pipeline korrekt mit heterogenen Pipeline-Inhalten umgehen können.
Die Standardausgabe der PowerShell kann dies. In anderen Fällen
bedingt der Typ des ersten Objekts in der Pipeline die Art der
Weiterverarbeitung (z. B. bei Export-CSV).

Bild 5.32 Anwendung von Get-PipelineInfo auf eine heterogene Pipeline

5.15" Kastrierung" von Objekten in der

Pipeline

Die Analyse des Pipeline-Inhalts zeigt, dass es omals sehr viele
Mitglieder in den Objekten in der Pipeline gibt. In der Regel braucht
man aber nur wenige. Nicht nur aus Gründen der Leistung und
Speicherschonung, sondern auch in Bezug auf die Übersichtlichkeit
lohnt es sich, die Objekte in der Pipeline hinsichtlich ihrer
Datenmenge zu beschränken.


Mit dem Befehl Select-Object (Alias: Select) kann ein Objekt in der
Pipeline "kastriert" werden, d. h., (fast) alle Mitglieder des Objekts
werden aus der Pipeline entfernt, mit Ausnahme der hinter Select-
Object genannten Mitglieder.

Beispiel:

```
Get-Process | Select-Object processname, get_minworkingset, ws
| Get-Member
```
lässt von den Process-Objekten in der Pipeline nur die Mitglieder
processname (Eigenscha), get_minworkingset (Methode) und
workingset (Alias) übrig (siehe folgende Abbildung). Wie das Bild zeigt,
ist das "Kastrieren" mit zwei Wermutstropfen verbunden:

```
Get-Member zeigt nicht mehr den tatsächlichen Klassennamen an,
sondern PSCustomObject, eine universelle Klasse der PowerShell.
Alle Mitglieder sind zu Notizeigenschaen degradiert.
```
Bild 5.33 Wirkung der Anwendung von Select-Object


```
TIPP: Mit dem Parameter -exclude kann man in Select-Object
auch Mitglieder einzeln ausschließen.
```
Dass es neben den drei gewünschten Mitgliedern noch vier weitere in
der Liste gibt, ist auch einfach erklärbar: Jedes, wirklich jedes .NET-
Objekt hat diese vier Methoden, weil diese von der Basisklasse
System.Object an jede .NET-Klasse vererbt und damit an jedes .NET-
Objekt weitergegeben werden.

5.16 Sortieren

Mit Sort-Object (Alias Sort) sortiert man die Objekte in der Pipeline
nach den anzugebenden Eigenschaen. Die Standardsortierrichtung
ist aufsteigend. Mit dem Parameter -descending (kurz: - desc) legt man
die absteigende Sortierung fest.

Der folgende Befehl sortiert die Prozesse absteigend nach ihrem
Speicherverbrauch:

```
Get-Process | Sort-Object workingset 64 - desc
```
Mit Komma getrennt kann man mehrere Eigenschaen aufführen,
nach denen sortiert werden soll. In folgendem Beispiel werden die
Systemdienste erst nach Status und innerhalb eines Status dann nach
Displayname sortiert.

```
Get-Service | Sort-Object Status, Displayname
```
Auch Listen elementarer Datentypen lassen sich sortieren. Hier muss
man keine Eigenscha angeben, nach der man sortieren will:


```
21, 32, 16, 34, 9, 10 | Sort-Object
```
Möchte man diese Zahlen nicht numerisch, sondern alphabetisch
sortieren, dann gibt man als Parameter einen Ausdruck an, der eine
Typkonvertierung mit einem Typbezeichner (Details zu
Typkonvertierungen erfahren Sie im Kapitel 7 "PowerShell-
Skriptsprache") enthält:

```
21, 32, 16, 34, 9, 10 | Sort-Object { [string]$_ }
```
Bild 5.34 Numerische versus alphabetische Sortierung von sechs Zahlen

5.17 Duplikate entfernen

Sowohl Select-Object -Unique als auch Get-Unique entfernen
Duplikate aus einer Liste.

Beispiel

```
1,5,7,8,5,7 | Select-Object -Unique
```
liefert als Ergebnis eine Pipeline mit vier Zahlen: 1,5,7 und 8.


ACHTUNG: Bei Get-Unique muss die Liste vorher sortiert sein!

Richtig ist daher:

```
1,5,7,8,5,7 | Sort-Object | Get-Unique
```
Falsch wäre:

```
1,5,7,8,5,7 | Get-Unique
```
Beide Commandlets arbeiten nicht nur auf elementaren Datentypen
wie Zahlen und Zeichenketten, sondern auch auf komplexen
Objekten, z. B.

```
(Get-process | Select-Object -Unique).Count
(Get-process | sort-object | get-unique).Count
```
Bild 5.35 Einsatz von Get-Unique und Select-Object -unique


Praxislösung: Microso-Office-Wörterbücher

zusammenfassen

Wer auf mehreren Rechnern arbeitet und kein Roaming-Profil nutzen
kann oder will, kennt das Problem: Auf jedem PC gibt es ein eigenes
benutzerdefiniertes Wörterbuch für Microso Word, Outlook etc. (.dic-
Datei mit Namen benutzer.dic bzw. custom.dic). .dic-Dateien sind
einfache ASCII-Dateien und man kann natürlich mit jedem beliebigen
Texteditor oder einem Merge-Werkzeug die Wörterbücher
zusammenführen. Ganz elegant ist die Zusammenführung aber mit
einem PowerShell-Einzeiler möglich. Der Befehl geht davon aus, dass
sich im Ordner d:\Woerterbuecher mehrere .dic-Dateien befinden. Die
Ausgabe ist ein konsolidiertes Wörterbuch MeinWoerterbuch.dic.
Doppelte Einträge werden natürlich mit Get-Unique eliminiert.

```
Dir "X:\Woerterbuecher" - Filter *.dic | Get-Content | Sort-Obj
ect | Get-Unique | Set-
Content "X:\Woerterbuecher\MeinWoerterbuch.dic"
```
5.18 Gruppierung

Mit Group-Object (Alias: Group) kann man Objekte in der Pipeline nach
Eigenschaen gruppieren.

Mit dem folgenden Befehl ermittelt man, wie viele Systemdienste
laufen und wie viele gestoppt sind:

```
Get-Service | Group-Object status
```
Dabei liefert das Commandlet drei Spalten (siehe nächste Abbildung):
Count, Name und Group (mit den Elementen in der Gruppe). Über die
Eigenscha Group kann man dann die Gruppenmitglieder abrufen, z.


B. die Mitglieder der ersten Gruppe (Zählung beginnt bei 0, runde
Klammern nicht vergessen):

```
(Get-Service | Group-Object status)[ 0 ].Group
```
Braucht man die Gruppenmitglieder nicht, verwendet man als Zusatz

- NoElement (das spart etwas Speicherplatz, was aber nur bei großen
Ergebnismengen relevant ist):

```
Get-Service | Group-Object status -NoElement
```
Ein weiteres Beispiel gruppiert die Dateien im System 32 - Verzeichnis
nach Dateierweiterung und sortiert die Gruppierung dann absteigend
nach Anzahl der Dateien in jeder Gruppe.

```
Get-ChildItem c:\windows\system 32 | Group-Object extension |
Sort-Object count -desc
```

Bild 5.36 Einsatz von Group-Object

```
TIPP: Wenn es nur darum geht, die Gruppen zu ermitteln und
nicht die Häufigkeit der Gruppenelemente, dann kann man
auch Select-Object mit dem Parameter -unique zum
Gruppieren einsetzen:
```
```
Get-ChildItem | Select-Object extension -Unique
```
```
TIPP: Man kann bei Group-Object auch einen Ausdruck
angeben, der wahr oder falsch liefert, und dadurch zwei
Gruppen bilden.
```

BEISPIEL:

```
Get-ChildItem c:\Windows | Where { !$_.PsIsContainer }
|
Group-Object { $_.Length -gt 1 MB}
```
```
teilt alle Dateien im aktuellen Verzeichnis in zwei Gruppen ein:
solche, die größer als 1 MByte sind, und solche, die es nicht
sind (Verzeichnisse werden bereits vorher ausgeschlossen,
auch wenn dies nicht erforderlich wäre, da sie die Größe 0
besitzen).
```
```
Bild 5.37 Ergebnis des obigen Befehls (Zahlen können in Abhängigkeit vom
Betriebssystem abweichen)
```
Praxislösung 1

Es sollen in einer Menge von Zeichenketten (hier: Feldnamen für Work
Items in Azure DevOps) Duplikate ermittelt werden. Der eingebettete
Here-String wird zunächst mit dem Split-Operator zeilenweise in eine
Menge von Zeichenketten aufgespalten. Danach wird diese Menge mit
Group-Objekt gruppiert. Im Ergebnis findet man die doppelten
Zeichenketten, indem man prü, bei welchen Elementen die
Eigenscha count größer als eins ist.


Listing 5.4 [Finde doppelte Zeichenketten.ps1]


# Finde doppelte Zeichenketten
# Eingabemenge: Zeichenketten (eingebettet als "Here-String" o
der aus einer Datei)
# Ausgabe: Liste der doppelt vorkommenden Zeichenketten

$eingabe = @"
Microsoft.VSTS.Build.FoundIn
Microsoft.VSTS.Build.IntegrationBuild
Microsoft.VSTS.CMMI.ActualAttendee 1
Microsoft.VSTS.CMMI.ActualAttendee 2
Microsoft.VSTS.CMMI.ActualAttendee 3
Microsoft.VSTS.CMMI.ActualAttendee 4
Microsoft.VSTS.CMMI.ActualAttendee 5
Microsoft.VSTS.CMMI.ActualAttendee 6
Microsoft.VSTS.CMMI.ActualAttendee 7
Microsoft.VSTS.CMMI.ActualAttendee 8
Microsoft.VSTS.CMMI.Analysis
Microsoft.VSTS.CMMI.Blocked
Microsoft.VSTS.CMMI.CalledBy
Microsoft.VSTS.CMMI.CalledDate
Microsoft.VSTS.CMMI.Comments
Microsoft.VSTS.CMMI.Committed
Microsoft.VSTS.CMMI.ContingencyPlan
Microsoft.VSTS.CMMI.CorrectiveActionActualResolution
Microsoft.VSTS.CMMI.CorrectiveActionPlan
Microsoft.VSTS.CMMI.Escalate
Microsoft.VSTS.CMMI.FoundInEnvironment
Microsoft.VSTS.CMMI.HowFound
Microsoft.VSTS.CMMI.ImpactAssessmentHtml
Microsoft.VSTS.CMMI.ImpactOnArchitecture
Microsoft.VSTS.CMMI.ImpactOnDevelopment
Microsoft.VSTS.CMMI.ImpactOnTechnicalPublications
Microsoft.VSTS.CMMI.ImpactOnTest
Microsoft.VSTS.CMMI.ImpactOnUserExperience


Microsoft.VSTS.CMMI.Justification
Microsoft.VSTS.CMMI.MeetingType
Microsoft.VSTS.CMMI.Minutes
Microsoft.VSTS.CMMI.MitigationPlan
Microsoft.VSTS.CMMI.MitigationTriggers
Microsoft.VSTS.CMMI.OptionalAttendee 1
Microsoft.VSTS.CMMI.OptionalAttendee 2
Microsoft.VSTS.CMMI.OptionalAttendee 3
Microsoft.VSTS.CMMI.OptionalAttendee 4
Microsoft.VSTS.CMMI.OptionalAttendee 5
Microsoft.VSTS.CMMI.OptionalAttendee 6
Microsoft.VSTS.CMMI.OptionalAttendee 7
Microsoft.VSTS.CMMI.OptionalAttendee 8
Microsoft.VSTS.CMMI.Probability
Microsoft.VSTS.CMMI.ProposedFix
Microsoft.VSTS.CMMI.Purpose
Microsoft.VSTS.CMMI.RequiredAttendee 1
Microsoft.VSTS.CMMI.RequiredAttendee 2
Microsoft.VSTS.CMMI.RequiredAttendee 3
Microsoft.VSTS.CMMI.RequiredAttendee 4
Microsoft.VSTS.CMMI.RequiredAttendee 5
Microsoft.VSTS.CMMI.RequiredAttendee 6
Microsoft.VSTS.CMMI.RequiredAttendee 7
Microsoft.VSTS.CMMI.RequiredAttendee 8
Microsoft.VSTS.CMMI.RequirementType
Microsoft.VSTS.CMMI.RequiresReview
Microsoft.VSTS.CMMI.RequiresTest
Microsoft.VSTS.CMMI.RootCause
Microsoft.VSTS.CMMI.SubjectMatterExpert 1
Microsoft.VSTS.CMMI.SubjectMatterExpert 2
Microsoft.VSTS.CMMI.SubjectMatterExpert 3
Microsoft.VSTS.CMMI.Symptom
Microsoft.VSTS.CMMI.TargetResolveDate
Microsoft.VSTS.CMMI.TaskType


Microsoft.VSTS.CMMI.UserAcceptanceTest
Microsoft.VSTS.CodeReview.AcceptedBy
Microsoft.VSTS.CodeReview.AcceptedDate
Microsoft.VSTS.CodeReview.ClosedStatus
Microsoft.VSTS.CodeReview.ClosedStatusCode
Microsoft.VSTS.CodeReview.ClosedStatusCode
Microsoft.VSTS.CodeReview.ClosingComment
Microsoft.VSTS.CodeReview.Context
Microsoft.VSTS.CodeReview.ContextCode
Microsoft.VSTS.CodeReview.ContextOwner
Microsoft.VSTS.CodeReview.ContextType
Microsoft.VSTS.Common.AcceptanceCriteria
Microsoft.VSTS.Common.ActivatedBy
Microsoft.VSTS.Common.ActivatedDate
Microsoft.VSTS.Common.Activity
Microsoft.VSTS.Common.BusinessValue
Microsoft.VSTS.Common.ClosedBy
Microsoft.VSTS.Common.ClosedDate
Microsoft.VSTS.Common.Discipline
Microsoft.VSTS.Common.Issue
Microsoft.VSTS.Common.Priority
Microsoft.VSTS.Common.Rating
Microsoft.VSTS.Common.Resolution
Microsoft.VSTS.Common.ResolvedBy
Microsoft.VSTS.Common.ResolvedDate
Microsoft.VSTS.Common.ResolvedReason
Microsoft.VSTS.Common.ReviewedBy
Microsoft.VSTS.Common.Risk
Microsoft.VSTS.Common.Severity
Microsoft.VSTS.Common.StackRank
Microsoft.VSTS.Common.StateChangeDate
Microsoft.VSTS.Common.StateCode
Microsoft.VSTS.Common.TimeCriticality
Microsoft.VSTS.Common.Triage


Microsoft.VSTS.Common.ValueArea
Microsoft.VSTS.Feedback.ApplicationLaunchInstructions
Microsoft.VSTS.Feedback.ApplicationStartInformation
Microsoft.VSTS.Feedback.ApplicationType
Microsoft.VSTS.Scheduling.CompletedWork
Microsoft.VSTS.Scheduling.DueDate
Microsoft.VSTS.Scheduling.Effort
Microsoft.VSTS.Scheduling.FinishDate
Microsoft.VSTS.Scheduling.OriginalEstimate
Microsoft.VSTS.Scheduling.RemainingWork
Microsoft.VSTS.Scheduling.Size
Microsoft.VSTS.Scheduling.StartDate
Microsoft.VSTS.Scheduling.StoryPoints
Microsoft.VSTS.Scheduling.TargetDate
Microsoft.VSTS.TCM.AutomatedTestId
Microsoft.VSTS.TCM.AutomatedTestName
Microsoft.VSTS.TCM.AutomatedTestStorage
Microsoft.VSTS.TCM.AutomatedTestType
Microsoft.VSTS.TCM.AutomationStatus
Microsoft.VSTS.TCM.LocalDataSource
Microsoft.VSTS.TCM.Parameters
Microsoft.VSTS.TCM.QueryText
Microsoft.VSTS.TCM.ReproSteps
Microsoft.VSTS.TCM.Steps
Microsoft.VSTS.TCM.SystemInfo
Microsoft.VSTS.TCM.TestSuiteAudit
Microsoft.VSTS.TCM.TestSuiteType
Microsoft.VSTS.TCM.TestSuiteTypeId
System.AreaId
System.AreaPath
System.AssignedTo
System.AttachedFileCount
System.AuthorizedAs
System.AuthorizedDate


System.BoardColumn
System.BoardColumnDone
System.BoardLane
System.ChangedBy
System.ChangedDate
System.CommentCount
System.CreatedBy
System.CreatedDate
System.Description
System.ExternalLinkCount
System.History
System.HyperLinkCount
System.Id
System.IterationId
System.IterationPath
System.NodeName
System.Reason
System.RelatedLinkCount
System.RemoteLinkCount
System.Rev
System.RevisedDate
System.State
System.Tags
System.Tags
System.TeamProject
System.Title
System.Watermark
System.WorkItemType
"@

# Alternativ: Einlesen einer Datei
# $eingabe = get-content "eingabedatei.txt"

# Der eingebettete Here-String wird zunächst mit dem Split-Ope


```
rator zeilenweise in
eine Menge von Zeichenketten aufgespalten.
$gespaltet = $eingabe -split "`n" |Sort-Object
# Danach wird diese Menge mit Group-Objekt gruppiert.
$gruppiert = $gespaltet | Group-Object
```
```
$anz = ($gespaltet).Count
$anzGruppiert = ($gruppiert).Count
$Duplikate = $gruppiert | where count -gt 1
```
```
if ($Duplikate.Count -eq 0 )
{
Write-Host "$Anz Elemente. Keine Duplikate!" - ForegroundCo
lor Green
}
else
{
Write-Host "$($Duplikate.Count) Zeichenketten kommen mehr
fach vor /
$anzGruppiert verschiedenen Zeichenketten in $anz Zeilen:" - Fo
regroundColor red
$Duplikate | Ft Name, Count
}
```
```
$Duplikate | Ft Name, Count
}
```
Praxislösung 2

Wenn man sich die Elemente der einzelnen Gruppen liefern lässt, so
kann man diese weiterverwenden, indem man über die Eigenscha
group mit Foreach-Object iteriert.


Beispiel: Ermittle aus dem Verzeichnis System 32 alle Dateien, die mit
dem Buchstaben "b" beginnen. Beschränke die Menge auf diejenigen
Dateien, die größer als 40 000 Byte sind, und gruppiere die
Ergebnismenge nach Dateierweiterungen. Sortiere die Gruppen nach
der Anzahl der Einträge absteigend und beschränke die Menge auf das
oberste Element. Gib für alle Mitglieder dieser Gruppe die Attribute
Name und Length aus und passe die Spaltenbreite automatisch an.

```
Get-ChildItem c:\windows\system 32 - filter b*.* | Where-Object
{$_.Length -gt 40000 } |
Group-Object Extension | Sort-Object count -desc | Select-Obje
ct -first 1 | Select-
Object group | foreach {$_.group} | Select-Object name,length
| Format-Table –
autosize
```
5.19 Objekte verbinden mit Join-String

Das in PowerShell 6 neu eingeführte Commandlet Join-String
verbindet eine zu bennende Eigenscha der Objekte in der Pipeline zu
einer einzigen Zeichenkette mit einem beliebigen Trennzeichen.

Wenn der Parameter -Property nicht angebeben wird, ru Join-String
auf den Objekten in der Pipeline die Methode ToString() auf. Dies
ergibt manchmal einen sinnvollen Inhalt, bei vielen Objekten wird
aber nur der Klassenname geliefert. Leer lassen muss man den
Parameter -Property, wenn der Inhalt der Pipeline primitive
Datentypen (Zahlen, Zeichenketten, Datumsangaben etc.) sind.


Bild 5.38 Einsatzbeispiele für Join-String

5.20 Berechnungen

Measure-Object (Alias: measure) führt verschiedene Berechnungen
(Anzahl, Durchschnitt, Summe, Minimum, Maximum) für Objekte in
der Pipeline aus. Dabei sollte man die Eigenscha nennen, über
welche die Berechnung ausgeführt werden soll. Sonst wird die erste
Eigenscha verwendet, die aber häufig ein Text ist, den man nicht
mathematisch verarbeiten kann.


Measure-Object liefert im Standard nur die Anzahl. Mit den Parametern

- sum, - min, - max und -average muss man weitere Berechnungen
explizit anstoßen.

Beispiel: Informationen über die Dateien in c:\Windows

```
Get-ChildItem c:\windows | Measure-Object -Property length -mi
n -max -average -sum
```
Bild 5.39 Beispiel für den Einsatz von Measure-Object

5.21 Zwischenschritte in der Pipeline

mit Variablen

Ein Befehl mit Pipeline kann beliebig lang und damit auch beliebig
komplex werden. Wenn der Befehl unübersichtlich wird oder man
Zwischenschritte genauer betrachten möchte, bietet es sich an, den
Inhalt der Pipeline zwischenzuspeichern. Die PowerShell ermöglicht
es, den Inhalt der Pipeline in Variablen abzulegen. Variablen werden
durch ein vorangestelltes Dollarzeichen [$] gekennzeichnet. Anstelle
von

```
Get-Process | Where-Object {$_.name -eq "iexplore"} | Foreach-
Object { $_.ws }
```

kann man die folgenden Befehle nacheinander in getrennte Zeilen
eingeben:

```
$x = Get-Process
$y = $x | Where-Object {$_.name -eq "iexplore"}
$y | Foreach-Object { $_.ws }
```
Das Ergebnis ist in beiden Fällen gleich.

Der Zugriff auf Variablen, die keinen Inhalt haben, führt so lange nicht
zum Fehler, wie man später in der Pipeline keine Commandlets
verwendet, die unbedingt Objekte in der Pipeline erwarten.

Bild 5.40 Zugriff auf Variablen ohne Inhalt

```
ACHTUNG: Wenn ein Pipeline-Befehl keinen Inhalt liefert,
dann erhält die Variable den Wert $null, der für "kein Wert"
steht.
Beispiel:
```
```
$x = Get-Service x*
```
Die Ausgabe für $null ist nichts.


5.22 Verzweigungen in der Pipeline

Manchmal möchte man innerhalb einer Pipeline das Ergebnis nicht
nur in der Pipeline weiterreichen, sondern auch in einer Variablen
oder im Dateisystem zwischenspeichern. PowerShell bietet dafür
verschiedene Möglichkeiten.

```
TIPP: Verzweigungen in der Pipeline lassen sich ganz einfach
abbilden, indem man die Zwischenschritte in verschiedenen
Variablen ablegt, auf die man später wieder zugreifen kann. Die
in diesem Unterkapitel gezeigten Techniken sind für Leute
gedacht, die unbedingt möglichst viel in einem einzigen
Pipeline-Befehl unterbringen wollen.
```
Tee-Object

Der Verzweigung innerhalb der Pipeline dient das Commandlet Tee-
Object, wobei hier das "Tee" für "verzweigen" steht. Tee-Object reicht
den Inhalt der Pipeline unverändert zum nächsten Commandlet
weiter, bietet aber an, den Inhalt der Pipeline wahlweise zusätzlich in
einer Variablen oder im Dateisystem abzulegen.

Der folgende Pipeline-Befehl verwendet Tee-Object gleich zweimal für
beide Anwendungsfälle:

```
Get-Service | Tee-Object -var a | Where-Object { $_.Status -eq
"Running" } | select
name | Tee-Object -filepath x:\dienste.txt | ft name
```
Die erste Verwendung von Tee-Object speichert die Liste der Dienste-
Objekte in der Variablen $a und gibt die Objekte aber gleichzeitig


weiter in die Pipeline.

Die zweite Verwendung speichert die Liste der laufenden Dienste in
der Textdatei g:\ dienste.txt und gibt sie zusätzlich an die
Standardausgabe aus.

Nach der Ausführung des Befehls steht in der Variablen $a eine Liste
aller Dienste und in der Textdatei dienste.txt eine Liste der laufenden
Dienste.

```
ACHTUNG: Bitte beachten Sie, dass man bei Tee-Object beim
Parameter -variable den Namen der Variablen ohne den
üblichen Variablenkennzeichner "$" angeben muss.
```
Parameter -OutVariable

Alternativ zum Commandlet Tee-Object kann man den allgemeinen
Parameter -OutVariable (kurz: - ov) einsetzen, der das Ergebnis eines
Commandlets in einer Variable ablegt und dennoch das Ergebnis in
der Pipeline weiterreicht. Das Beispiel aus dem vorherigen
Unterkapitel kann man so umformulieren:

```
Get-Service -OutVariable a | Where-Object { $_.Status -eq "Run
ning" } | select name |
Set-Content x:\dienste.txt -PassThru | ft name
```
Anders als Tee-Object kann –OutVariable nichts direkt in einer Datei
speichern. Zum Speichern kommt daher hier Set-Content zum Einsatz
mit –PassThru, was ein zusätzliches Durchleiten der Ergebnisse
bewirkt.


```
ACHTUNG: Nach -OutVariable ist von der Variablen nur der
Name anzugeben.
Das Dollarzeichen muss weggelassen werden.
```
Parameter -PipelineVariable

Der mit PowerShell-Version 4.0 eingeführte allgemeine Parameter -
PipelineVariable (kurz: - pv) sorgt dafür, dass das jeweils aktuelle
Objekt nicht nur in der Pipeline weitergereicht wird, sondern
zusätzlich auch in einer Variablen abgelegt wird. Dies ist immer dann
sinnvoll, wenn die Pipeline ein Objekt in seiner Struktur verändert (z.
B. SelectObject), man aber später noch auf den früheren Zustand
zugreifen will. Nach -PipelineVariable ist von der Variablen nur der
Name anzugeben. Das Dollarzeichen muss weggelassen werden.

Beispiel 1

Das folgende Beispiel setzt dies ein, um am Ende eine Liste von
Ausgaben aus zwei verschiedenen Objekten zu liefern: den Namen
und das Workingset eines Prozesses von Get-Process und den Namen
und den zugehörigen Security Identifier des Benutzers, unter dem der
Prozess läu. Die Pipeline beginnt mit dem Holen der laufenden
Prozesse unter Einbeziehung der Benutzeridentität, die in der Form
"Domäne\Benutzername" geliefert wird. Dabei wird das aktuelle
Process-Objekt mit -pv auch in der Variablen $p abgelegt. Im zweiten
Schritt wird für den Benutzernamen das zugehörige WMI-Objekt
Win32_User geholt. Im dritten Pipeline-Schritt werden dann zuerst die
zwei Informationen aus dem Process-Objekt ausgegeben (das sich in


$p befindet) sowie die Informationen aus dem Win32_UserAccount-
Objekt, die sich nun in der Pipeline befinden ($_).

```
Get-Process -IncludeUserName -pv p | % { Get-WmiObject Win32_U
serAccount -filter
"name='$(($_.username -split "\\")[ 1 ])'" } | % { $p.name + ":"
+ $p.ws + ":" +
$_.Name + ";" + $_.SID }
```
```
ACHTUNG: Der Parameter -PipelineVariable funktioniert nicht
wie gewünscht, wenn Commandlets in der Pipeline sind, die
die Ergebnisse puffern (z. B. Sort-Object, Group-Object), da der
Parameter -PipelineVariable sich ja immer nur auf das
aktuelle Objekt bezieht, was in diesen Fällen also immer das
letzte Objekt ist.
```
Beispiel 2

Der folgende Einzeiler listet alle 64516-IP-Adressen zwischen
192.168.0.0 und 192.168.254.254 auf.

```
1..254 | Foreach-Object -PipelineVariable x { $_ } | Foreach-O
bject { 1..254 } |
foreach-Object { "192.168.$x.$_" }
```
5.23 Vergleiche zwischen Objekten


Mit Compare-Object kann man den Inhalt von zwei Pipelines
vergleichen. Mit der folgenden Befehlsfolge werden alle
zwischenzeitlich neu gestarteten Prozesse ausgegeben:

```
$ProzesseVorher = Get-Process
# Hier einen Prozess starten
$ProzesseNacher = Get-Process
Compare-Object $ProzesseVorher $ProzesseNacher
```
Bild 5.41 Vergleich von zwei Pipelines

5.24 Weitere Praxislösungen

Dieses Kapitel enthält einige Beispiele für die Anwendung von
Pipelining und Ausgabebefehlen:

```
Beende durch Aufruf der Methode Kill() alle Prozesse, die
"chrome" heißen, wobei die Groß-/Kleinschreibung des
Prozessnamens irrelevant ist.
Get-Process | Where { $_.processname -ieq "chrome" } | foreach
{ $_.Kill() }
```
oder synonym und kürzer:


```
(Get-Process "chrome").Kill()
```
Sortiere die Prozesse, die das Wort "chrome" im Namen tragen,
gemäß ihrer CPU-Nutzung und beende den Prozess, der in der
aufsteigenden Liste der CPU-Nutzung am weitesten unten steht
(also am meisten Rechenleistung verbraucht).
Get-Process | Where { $_.processname -ilike "*chrome*" } | Sor
t-Object -property
cpu | Select-Object -last 1 | foreach { $_.Kill() }

Gib die Summe der Speichernutzung aller Prozesse aus.

```
ps | Measure-Object workingset
```
Gruppiere die Einträge im System-Ereignisprotokoll nach
Benutzernamen.

```
Get-EventLog -logname system | Group-Object username
```
Zeige die letzten zehn Einträge im System-Ereignisprotokoll.

```
Get-EventLog -logname system | Select-Object -last 10
```
Zeige für die letzten zehn Einträge im System-Ereignisprotokoll
die Quelle an.

```
Get-EventLog -logname system | Select-Object -first 10 | Selec
t-Object source
```
Importiere die Textdatei test.txt, wobei die Textdatei als eine
CSV-Datei mit dem Semikolon als Trennzeichen zu interpretieren
ist und die erste Zeile die Spaltennamen enthalten muss. Zeige
daraus die Spalten ID und Url.


```
Import-CSV d:\_work\test.txt -delimiter ";" | Select-Object I
D,Url
```
Ermittle aus dem Verzeichnis System 32 alle Dateien, die mit dem
Buchstaben "a" beginnen. Beschränke die Menge auf diejenigen
Dateien, die größer als 40 000 Byte sind, und gruppiere die
Ergebnismenge nach Dateinamenerweiterungen. Sortiere die
gruppierte Menge nach dem Namen der Dateierweiterung.
Get-ChildItem c:\windows\system 32 - filter a*.* | Where-Object
{$_.Length -gt
40000 } | Group-Object Extension | Sort-Object name | Format-Ta
ble

Ermittle aus dem Verzeichnis System 32 alle Dateien, die mit dem
Buchstaben "b" beginnen. Beschränke die Menge auf diejenigen
Dateien, die größer als 40 000 Byte sind, und gruppiere die
Ergebnismenge nach Dateierweiterungen. Sortiere die Gruppen
nach der Anzahl der Einträge absteigend und beschränke die
Menge auf das oberste Element. Gib für alle Mitglieder dieser
Gruppe die Attribute Name und Length aus und passe die
Spaltenbreite automatisch an.
Get-ChildItem c:\windows\system 32 - filter b*.* | Where-Object
{$_.Length -gt 40000 }
| Group-Object Extension | Sort-Object count -desc | Select-Ob
ject -first 1 |
Select-Object group | foreach {$_.group} | Select-Object name,
length | Format-Table

- autosize


#### 6 PowerShell-Skripte

Dieses Kapitel behandelt die Erstellung von PowerShell-Skripten aus
Commandlets und der PowerShell-Skriptsprache. Beide Formen können
in einem Skript beliebig gemischt werden. Zunächst werden der
allgemeine Aufbau und der Start der Skripte erläutert. Die Befehle der
Skriptsprache folgen im nächsten Kapitel.

```
ACHTUNG: Bereits im Kapitel 1 "Erste Schritte mit der PowerShell"
haben Sie gelernt, dass die PowerShell im Standard gar keine
Skriptausführung erlaubt. Wenn Sie den dort genannten Befehl
Set-ExecutionPolicy remotesigned noch nicht ausgeführt haben,
führen Sie ihn jetzt aus, um die Skriptausführung auf Ihrem System
zu erlauben. Details dazu erfahren Sie in Abschnitt 6.7
Sicherheitsfunktionen für PowerShell-Skripte
```
6.1 Skriptdateien

Befehlsabfolgen (Commandlets und/oder Elemente der Skriptsprache)
können als Power-Shell-Skripte im Dateisystem abgelegt und später
(unbeaufsichtigt) ausgeführt werden. Diese Skripte sind reine Textdateien
und haben die Dateinamenerweiterung .ps 1. Die Zahl 1 steht dabei
ursprünglich für die Version 1.0 der PowerShell. Microso hat in Hinblick


auf die Langlebigkeit vieler Skripte vorgesehen, dass verschiedene
Versionen der PowerShell auf einem System koexistieren können.

```
ACHTUNG: ps 1 gilt auch noch für PowerShell 5.x und PowerShell
Core 6.x sowie PowerShell 7. Man kann .ps 1 nun also als "erste
Version des PowerShell-Dateiformats" verstehen.
```
Beispiel

Das folgende Listing zeigt ein Skript, das verschiedene Informationen
über den Computer ausgibt. Die Informationen werden aus den
Commandlets Get-Date, Get-Service und Get-Process ermittelt. Dabei
werden nur jeweils einzelne Werte durch den Aufruf von Methoden
ToShortDateString() bzw. ToLongTimeString() sowie das Property Count
extrahiert. Zudem gibt es statische Ausgaben (Zeichenkettenliterale), die
durch das Pluszeichen (+) mit den Ergebnissen der Commandlets
verbunden werden. Die Raute (#) leitet Kommentare ein, die nicht
ausgegeben werden.

Die einzelnen Befehle sind jeweils durch Zeilenumbrüche getrennt.
Alternative Möglichkeiten der Befehlstrennung lernen Sie im Kapitel 7
"PowerShell-Skriptsprache" kennen.

```
# Mein erstes Skript
"Informationen über diesen Computer:"
"Datum: " + (Get-Date).ToShortDateString()
"Zeit: " + (Get-Date).ToLongTimeString()
"Anzahl laufender Prozesse: " + (Get-Process).Count
"Anzahl gestarteter Dienste: " + (Get-Service | where { $_.Status
```
- eq "running" } ).Count

Das Skript können Sie in einem beliebigen Texteditor (z. B. Notepad,
Textpad, Emacs) oder einem speziellen PowerShell-Editor (z. B. Integrated


Scripting Environment (ISE), Visual Studio Code mit PowerShell-
Erweiterung, PowerShellPlus, PowerGUI) erfassen und im Dateisystem
speichern. Details über die Editoren erfahren Sie im Kapitel 11
"PowerShell-Werkzeuge".

Bild 6.1 Das Skript im Notepad

Bild 6.2 Das Skript im "Integrated Scripting Environment" (ISE), das Microso bei der Windows
PowerShell mitliefert


6.2 Start eines Skripts

Jeffrey Snover, der maßgebliche Architekt der PowerShell, nannte einst
als "Top-Sicherheitsfunktion" der PowerShell die Tatsache, dass man ein
PowerShell-Skript nicht durch Doppelklick auf das Symbol in Windows
starten kann. Grundsätzlich könnte man diese Startart definieren, sie ist
aber nicht im Standardumfang der PowerShell-Installation enthalten. Ein
PowerShell-Skript wird gestartet durch Eingabe des Namens mit oder
ohne Dateierweiterung bzw. mit oder ohne ein vorangestelltes
Commandlet in der PowerShell-Konsole.

```
.\MeinErstesSkript.ps 1
```
oder

```
&.\MeinErstesSkript.ps 1
```
oder

```
Invoke-Expression .\MeinErstesSkript.ps 1
```
```
HINWEIS: Wichtig ist, dass ein Skript immer eine Pfadangabe
braucht, selbst wenn es nur ein ".\" für den lokalen Pfad ist. Das
".ps1" ist jeweils optional.
Wenn der Skriptpfad ein Leerzeichen enthält, muss man folgende
Syntax wählen: & "c:\Skripte\Skriptname mit Leerzeichen.ps1".
Wenn in dem eingebundenen Skript "freie" Befehle enthalten sind,
also Befehle, die nicht Teil einer Funktion sind, dann werden diese
Befehle sofort ausgeführt.
Damit in einem Skript enthaltene Funktionen auch noch nach der
Skriptausführung zur Verfügung stehen, muss man das "Dot
Sourcing" anwenden (siehe Abschnitt 6.5).
```

Die folgende Abbildung zeigt den Start des Skripts an der PowerShell-
Konsole mit absolutem Pfad ("P:\.. .") und relativem Pfad (".\").

Bild 6.3 Start des Skripts an der PowerShell-Konsole mit absolutem Pfad und relativem Pfad

Bild 6.4 Start des Skripts in der ISE mit dem Symbolleistenbefehl "Run Script" oder der Taste F 5

Alternativ kann man ein PowerShell-Skript aus dem normalen Windows-
Kommandozeilenfenster (cmd.exe) durch eine Verknüpfung aus dem


Windows-Desktop oder als Anmeldeskript starten, indem man
powershell.exe voranstellt:

```
powershell.exe p:\Skripte\MeinErstesSkript.ps 1
```
```
ACHTUNG: Für PowerShell-Skripte gelten seit Windows Vista
hinsichtlich der Benutzerkontensteuerung (User Account Control –
UAC) die gleichen Einschränkungen und Lösungen wie für WSH-
Skripte, d. h. Sie müssen die PowerShell-Konsole explizit mit dem
Kontextmenüeintrag "Run as Administrator" ausführen, um volle
administrative Rechte zu erhalten.
```
6.3 Aliase für Skripte verwenden

Man kann Aliase auch für Skriptdateien inklusive Pfadangabe vergeben, z.
B.

```
Set-Alias Get-ComputerInfo P:\1_Basiswissen\Scripting\MeinErstesSk
ript.ps 1
```
Danach kann man dieses Skript über Get-ComputerInfo aufrufen, als wäre
es ein Commandlet.

Bild 6.5 Setzen eines Alias für ein Skript


6.4 Parameter für Skripte

Das oben gezeigte "MeinErstesSkript" fragt immer die Dienste und
Prozesse des lokalen Systems ab. Schön wäre es, wenn man auch
entfernte Computersysteme abfragen könnte. Sowohl Get-Process als
auch Get-Service bieten dazu einen Parameter -Computername, bei dem
man ein entferntes System angeben kann. Details zur Fernausführung
(Remoting) erfahren Sie im gleichnamigen Kapitel. An dieser Stelle soll der
Computername ein Parameter des Skripts werden.

Beim Aufruf eines Skripts kann man Parameter genauso übergeben wie
beim Aufruf von Commandlets, d. h. ohne Klammern und getrennt durch
Leerzeichen:

```
.\Skriptname.ps 1 Parameter 1 Parameter 2 Parameter 3
```
Ein Skript kann Parameter auf zwei Weisen verarbeiten:

```
Über die Variable $args, die ein Array (Liste) der Parameter enthält.
Die Zählung beginnt bei 0. Der erste Parameter steht in $args[ 0 ], der
zweite in $args[ 1 ], der dritte in $args[ 2 ] usw.
Durch eine explizite Deklaration einer Parameterliste mit Zuweisung
von Variablennamen und optional Datentypen. Die Parameterliste
definiert man am Beginn des Skripts mit param($name1, $name2,
$name3, usw.) oder param([Typ] $name1,[Typ] $name2,[Typ] $name3,
usw.). Im Skript kann man dann über $name 1 etc. Bezug auf die Werte
nehmen.
```
Die folgenden Listings zeigen beide Varianten am Beispiel von Get-
ComputerInfo.ps 1 , einer modifizierten Form von MeinErstesSkript.ps 1.
Der Aufruf erfolgt mit:

```
.\Get-ComputerInfo.ps 1 Server 123
```

ACHTUNG: Wenn Sie den Computernamen vergessen sollten,
beschwert sich das Skript selbst nicht. Es findet keinen Parameter
und setzt den Wert $null. $null (nicht zu verwechseln mit der Zahl
0!) steht für "kein Wert". Das ist in Ordnung für das Skript, aber die
Commandlets Get-Process und Get-Service mögen es nicht, wenn
man als -ComputerName $null übergibt, und beschweren sich: "The
argument is null or empty.".

```
Listing 6.1 [Get-ComputerInfo.ps1] Variante 1 unter Verwendung von args[x]
# Get-ComputerInfo
# Skript mit Parametern
"Informationen über den Computer: " + $args[ 0 ]
"Datum:" + (Get-Date).ToShortDateString(); "Zeit:" + (Get-D
ate).
ToLongTimeString()
"Anzahl laufender Prozesse: " + (Get-Process -computername
$args[ 0 ]).Count
"Anzahl gestarteter Dienste: " + (Get-Service -computername
$args[ 0 ]| where
{ $_.Status -eq "running" } ).Count
```

```
Listing 6.2 [Get-ComputerInfo.ps1] Variante 2 unter Verwendung von param[$x]
# Get-ComputerInfo
# Skript mit Parametern
param([string] $Computer)
"Informationen über den Computer: " + $Computer
"Datum:" + (Get-Date).ToShortDateString(); "Zeit:" + (Get-D
ate).
ToLongTimeString()
"Anzahl laufender Prozesse: " + (Get-Process -computername
$Computer).Count
"Anzahl gestarteter Dienste: " + (Get-Service -computername
$Computer|
where
{ $_.Status -eq "running" } ).Count
```
6.5 Skripte dauerha einbinden (Dot

Sourcing)

Als "Dot Sourcing" wird eine Möglichkeit bezeichnet, eine Skriptdatei
aufzurufen und permanent in die aktuelle Instanz der PowerShell
einzubinden. Der Unterschied zu den oben genannten Möglichkeiten ist,
dass nach dem "Dot Sourcing" alle in dem Skript deklarierten Variablen
und alle dort enthaltenen Funktionen der PowerShell-Konsole allen
nachfolgend aufgerufenen Skripten zur Verfügung stehen. "Dot Sourcing"
ist also eine Möglichkeit, die Funktionalität der PowerShell zu erweitern.

"Dot Sourcing" wird durch einen vorangestellten Punkt mit Leerzeichen
aktiviert:

. Softwareinventar.ps 1


Es kann ein relativer oder ein absoluter Pfad angegeben werden.

```
ACHTUNG: Wenn in dem eingebundenen Skript "freie" Befehle
enthalten sind, also Befehle, die nicht Teil einer Funktion sind,
dann werden diese Befehle sofort ausgeführt. Deklarierte
Funktionen werden nicht ausgeführt, stehen aber dem
einbindenden Skript und den folgenden eingebundenen Skripten
zur Verfügung.
```
Man kann mit "Dot Sourcing" auch Skripte in andere einbinden. Die
Einbindung erfolgt auch hier mit dem Punktoperator (.).

```
Listing 6.3 Beispiel für ein PowerShell-Skript, das nur besteht, um andere Skripte
einzubinden und aufzurufen
[3_Einsatzgebiete/Benutzer/Run Demos.ps1]
# Demo User Management
```
. ("W:\demo\PowerShell\Benutzer\Localuser_Create.ps1")
. ("W:\demo\PowerShell\Benutzer\LocalGroup.ps1")
. ("W:\demo\PowerShell\Benutzer\Localuser_Delete.ps1")

6.6 Das aktuelle Skriptverzeichnis

Häufig muss man wissen, in welchem Verzeichnis das aktuelle Skript liegt,
weil man andere Dateien (Daten- und Konfigurationsdateien) laden will,
die relativ dazu im Dateisystem liegen. Den aktuellen Pfad liefert die
Variable $PSScriptRoot. Das ist möglich seit PowerShell 3.0. In älteren
Versionen der PowerShell muss man split-path -parent $MyInvocation.
MyCommand.Definition benutzen.

Beispiel: Aufruf eines Skriptes im selben Verzeichnis mit Dot Sourcing


. "$PSScriptRoot\weiteresSkript.ps1"

6.7 Sicherheitsfunktionen für

PowerShell-Skripte

Die Active-Scripting-Architektur im Internet Explorer, in Outlook und im
Windows Script Host (WSH) hatte mit Sicherheitsproblemen zu kämpfen.
Die PowerShell will diese Sicherheitsprobleme durch eine geänderte
Grundeinstellung vermeiden. Dass nicht jedes beliebige Skript zur
Ausführung gebracht werden kann, zeigt sich, wenn man versucht, die
Power-Shell-Konsole nicht nur interaktiv, sondern zum Start eines Skripts
zu verwenden. Die Standardausführungsrichtlinie (Execution Policy) lässt
überhaupt keine Skripte zu. Man ändert die Ausführungsrichtlinie mit dem
Commandlet Set-ExecutionPolicy.

Bild 6.6 Die Skriptausführung muss man in der PowerShell erst explizit aktivieren.

Mögliche Sicherheitsrichtlinien

Ein Benutzer kann die Shell zunächst nur interaktiv verwenden, bis er die
Ausführungsrichtlinie mit dem Commandlet Set-ExecutionPolicy auf eine
niedrigere Sicherheitsstufe herabsetzt:


```
Modus "Restricted: Es werden keine Konfigurationsdateien geladen
und keine Skripts ausgeführt. "Restricted" ist der Standardwert.
Modus "AllSigned": Nur signierte Skripte starten und signierte Skripte
von nichtvertrauten Quellen starten auf Nachfrage.
Modus "RemoteSigned": Eine vertraute Signatur ist nur für Skripte aus
dem Internet (via Browser, Outlook, Messenger) erforderlich; lokale
Skripte starten auch ohne Signatur.
Modus "Unrestricted": Alle Skripte laufen, nur bei unsignierten
Skripten aus dem Internet gibt es eine Nachfrage.
Modus "Bypass": Gar keine Sicherheit (d. h. keine Blockierung, keine
Warnungen, keine Nachfragen).
Modus "Undefined": Entfernt die gerade zugewiesene
Ausführungsrichtlinie aus dem aktuellen Bereich. Mit diesem
Parameter wird aber keine Ausführungsrichtlinie entfernt, die in einer
Gruppenrichtlinie festgelegt wurde.
```
Neu seit der PowerShell-Version 2 ist die Möglichkeit, einen
Gültigkeitsbereich für die Ausführungsrichtlinie festzulegen. Der
Standardwert ist "LocalMachine".

Gültige Werte sind:

```
"Process": Die Ausführungsrichtlinie wirkt sich nur auf den aktuellen
PowerShell-Prozess aus.
"CurrentUser": Die Ausführungsrichtlinie wirkt sich nur auf den
aktuellen Benutzer aus.
"LocalMachine": Die Ausführungsrichtlinie wirkt sich auf alle Benutzer
des Computers aus.
```
Zum Entfernen einer Ausführungsrichtlinie aus einem bestimmten
Bereich legen Sie die Ausführungsrichtlinie für diesen Bereich auf
"Undefined" fest.


```
ACHTUNG: "Unrestricted" sollte man nicht wählen, weil dies
"bösen" Skripten, die z. B. als E-Mail-Anhänge übermittelt werden,
die Tür öffnen würde. Wenn man sich nicht die Arbeit mit digitalen
Signaturen machen will, ist die Option "RemoteSigned" ein
Kompromiss. Noch vor dem endgültigen Erscheinen der
PowerShell gab es die ersten angeblichen PowerShell-Viren. Diese
waren aber nur eine Bedrohung, wenn man sie explizit gestartet
hat (siehe https://www.microso.com/en-
us/wdsi/threats/malware-encyclopedia-description?
Name=Worm:MSH/Cibyz.A).
Im Kapitel "Digitale Signaturen für PowerShell-Skripte" erfahren
Sie, wie man selbst erstellte oder fremde Skripte digital signiert.
```
Hintergründe

Die Sicherheitsrichtlinie wird in der Registrierungsdatenbank auf System-
oder Benutzerebene abgespeichert im Schlüssel:
HKEY_CURRENT_USER\Soware\Microso\PowerShell\ 1 \
ShellIds\Microso.PowerShell\ExecutionPolicy bzw.
HKEY_LOCAL_MACHINE\SOFTWARE\
Microso\PowerShell\ 1 \ShellIds\Microso.PowerShell\ExceutionPolicy.


Bild 6.7 Persistierung der Sicherheitsrichtlinien in der Registrierungsdatenbank

```
ACHTUNG: Bitte beachten Sie, dass durch die Speicherung in der
Registrierungsdatenbank die Sicherheitsrichtlinie bei aktivierter
Windows-Benutzerkontensteuerung (User Account Control) nur
geändert werden kann, wenn die PowerShell-Konsole unter vollen
Rechten ("Elevated") läu.
Bitte beachten Sie, dass die Ausführungsrichtlinie für die 64- und
die 32-Bit-Power-Shell getrennt gesetzt werden muss. Das
bedeutet, dass eine Einstellung, die Sie in der 64-Bit-PowerShell
vornehmen nicht automatisch für die 32-Bit-Variante gilt und
umgekehrt!
```

6.8 Skripte mit vollen Rechten (Elevation)

Alle PowerShell Hosts (Konsole, Editoren) starten in den meisten Fällen
nicht mit vollen Benutzerrechten, sondern mit eingeschränkten Rechten.
Einige Skripte erfordern aber volle Rechte, d. h. sogenannte Elevation mit
"Run as Administrator".

Ein PowerShell-Skript per .NET-Klasse
Security.Principal.WindowsPrincipal kann prüfen, ob es elevated läu
oder nicht:

```
Listing 6.4 [1_Basiswissen\Scripting\Elevation_Check.ps1]
if ((New-Object Security.Principal.WindowsPrincipal([Security.Prin
cipal.WindowsIdenti
ty]::GetCurrent())).IsInRole([Security.Principal.WindowsBuiltInRol
e]::Administrator))
{
"Skript is elevated"
}
else
{
Write-Warning "This Script requires elevation!"
}
```
Möglich ist auch, dass ein Skript automatisch die Elevation anfordert,
wenn sie nicht vorhanden ist. Der Trick ist, dass ein PowerShell-Skript sich
selbst noch einmal neu "als Administrator" startet.


Listing 6.5 [1_Basiswissen\Scripting\Elevation_AtScriptStart.ps1]

```
#######################################
# PowerShell Script
# (C) Dr. Holger Schwichtenberg
# http://www.powershell-doktor.de
########################################
```
```
# Check to see if we are currently running "as Administrator"
if (-not (New-Object Security.Principal.WindowsPrincipal([Securit
y.Principal.WindowsI
dentity]::GetCurrent())).IsInRole([Security.Principal.WindowsBuilt
InRole]::Administra
tor))
{
# not elevated :-( --> Restart Process
$newProcess = new-object System.Diagnostics.ProcessStartInfo "p
owershell.exe";
#oder: pwsh.exe
$newProcess.Arguments = """" + $myInvocation.MyCommand.Definiti
on + """";
$newProcess.Verb = "runas";
[System.Diagnostics.Process]::Start($newProcess);
exit
}
```
```
$Host.UI.RawUI.WindowTitle = $myInvocation.MyCommand.Definition +
" (*** Elevated
***)"
$Host.UI.RawUI.BackgroundColor = "DarkBlue"
```
```
Write-Host "This code always runs elevated :-)" - ForegroundColor Y
ellow
Read-Host
```

6.9 Blockierte PowerShell-Skripte

Die Ausführung von PowerShell-Skripten, die aus dem Internet
heruntergeladen werden, blockiert Windows wie andere ausführbare
Dateien (z. B. .exe) aus Sicherheitsgründen auch. Eine solche Datei kann
man nicht direkt per Kontextmenü starten. Man kann sie aber an der
Konsole starten oder aus einem Editor heraus.

Um die Datei auch per Doppeklick starten zu können, muss man die
Blockierung aufheben. Dies geht in den Dateieigenschaen (siehe
folgende Abbildung) oder mit dem Commandlet Unblock-File.

Bild 6.8 Blockierte Skriptdatei, die aus dem Internet stammt

So hebt man die Blockierung für alle Skriptdateien in einem Download-
Ordner auf:

```
Dir w:\Downloads\*.ps 1 | ForEach {Unblock-File $_.FullName}
```

6.10 PowerShell-Skripte im Kontextmenü

des Windows Explorers

Skripte, die auf Dateien oder Dateisystemordnern arbeiten, kann man
elegant in den Windows Explorer einbinden. Dies ist möglich per Registry-
Eintrag.

Bild 6.9 Ein PowerShell-Skript im Kontextmenü von .docx-Dateien

Bild 6.10 Registryeintrag für das PowerShell-Skript im Kontextmenü von .docx-Dateien

Solch einen Kontextmenüeintrag kann man natürlich per PowerShell-
Skript anlegen.


HINWEIS: Der Zweck des in den Windows Explorer eingebundenen
Skripts (Grafiken aus Word-Dokumenten extrahieren), wird später
in diesem Buch im Kapitel 39.4 "Praxislösung: Grafiken aus einem
Word-Dokument (DOCX) extrahieren" ausführlich erörtert.


Listing 6.6 [\3_Einsatzgebiete\Dateisystem\ExtractImgesFromDOCX.ps1]

```
# Extract all images from a Word document into folder /img
# Author: Dr. Holger Schwichtenberg, http://www.IT-Visions.de, 2018
```
```
#cmd /c ftype docx=powershell.exe -File `"C:\Software\ExtractImges
FromDOCX.ps 1 `"
`"% 1 `"
```
```
Write-Host "Extract all images from a Word document into folder /i
mg"
Write-Host "Author: Dr. Holger Schwichtenberg, http://www.IT-Visions.de,
2018"
Write-Host "Script: $PSScriptRoot\$($MyInvocation.MyCommand.Name)"
```
```
# Register this script as "Extract Images" command for DOCX
if ((New-Object Security.Principal.WindowsPrincipal([Security.Prin
cipal.WindowsIdenti
ty]::GetCurrent())).IsInRole([Security.Principal.WindowsBuiltInRol
e]::Administrator))
{
[System.Reflection.Assembly]::LoadWithPartialName("System.Windows.
Forms") | out-null
$Result = [System.Windows.Forms.MessageBox]::Show("Register this S
cript for all .docx
files in Windows Explorer?","Extract all images from a Word docume
nt into folder",1)
$Result
If ($Result -ne "OK") { return }
```

Write-Host "Registering this script in Registry..."
New-PSDrive -Name HKCR -PSProvider Registry -Root HKEY_CLASSES_ROO
T
md "HKCR:\Word.Document.12\shell\Extract Images using PowerShell\"

- Force
md "HKCR:\Word.Document.12\shell\Extract Images using PowerShell\c
ommand" - Force
$registryPath = "HKCR:\Word.Document.12\shell\Extract Images using
PowerShell\
Command"
$Name = "(Default)"
$value = 'powershell.exe -File "' + $PSScriptRoot +"\" + $MyInvoca
tion.MyCommand.
Name + '" "%1"'

New-ItemProperty -Path $registryPath -Name $name -Value $value -Pr
opertyType String

- Force | Out-Null
Write-Warning "Run script as normal user for processing DOCX!"
return
}
else
{
Write-Warning "This Script requires elevation for adding a registr
y key!"
}

try
{
$ErrorActionPreference = "Stop"; #Make all errors terminating
$path = $args[ 0 ] # Get path to .DOCX from Script arguments
Write-Host "DOCX: $path"
$file = Get-Item $path
$filezipname = $file.Name + ".zip"
$filezippath = "$($file.Directory)\$filezipname"


```
Write-host "Copy $path to ZIP..." - ForegroundColor Yellow
Copy-Item $path $filezippath
Write-host "Extract ZIP to temp folder..." - ForegroundColor Yellow
if (test-path "$($file.Directory)\temp") { Write-Error "Temp exist
s!"; }
Expand-Archive $filezippath -DestinationPath "$($file.Directory)\t
emp"
Write-host "Create img folder and copy images..." - ForegroundColor
Yellow
md "$($file.Directory)\Img\" - Force
Copy-Item "$($file.Directory)\temp\word\media\*" "$($file.Director
y)\Img\" - verbose
Write-host "Cleanup..." - ForegroundColor Yellow
rd $filezippath -ErrorAction Stop
rd "$($file.Directory)\temp" - Recurse
Write-host "Done!" - ForegroundColor Green
}
catch{
Write-Host "Error: $($_.Exception.Message)" - ForegroundColor r
ed
Read-Host "Press ENTER to exit"
}
```
6.11 Anforderungsdefinitionen von

Skripten

Skripte können in einer speziellen Kommentarsyntax mit #Requires
deklarieren, dass sie bestimmte Anforderungen haben, um laufen zu
können. Das Skript startet dann nicht, wenn die Anforderungen nicht
erfüllt sind.

Das folgende Skript startet nur, wenn

1. mindestens PowerShell Version 3.0 verwendet wird


2. das Skript mit vollen Administratorrechten ("Elevated") läu
3. die genannten Module verfügbar sind

```
Listing 6.7 [1_Basiswissen\Scripting\SkriptMitAnforderungen.ps1]
# siehe https://docs.microsoft.com/en-us/powershell/module/microso
ft.powershell.core/
about/about_requires
#Requires -Version 3
#Requires -RunAsAdministrator
#Requires -Modules PSCX,ITVisions_PowerShell_Extensions
```
```
"Skript mit Anforderungen!"
Get-Computername | Set-Clipboard
Get-Clipboard
```
6.12 Skripte anhalten

Ein PowerShell-Skript kann man eine Zeitlang anhalten. Die Zeit bemisst
sich in Millisekunden oder Sekunden.

So wartet das Skript zehn Millisekunden:

```
Start-Sleep -m 10
```
So wartet das Skript zehn Sekunden:

```
Start-Sleep -s 10
```
Seit PowerShell 7.3 Preview 3 kann man auch eine Dauer mit -Duration im
Format der .NET-Klasse System. TimeSpan angeben:
Stunden:Tage:Minuten

Mit diesem Befehl wartet das Skript nun eine Minute und 30 Sekunden:

```
Start-Sleep -Duration 00:01:30
```

6.13 Versionierung und

Versionsverwaltung von Skripten

Versionierung und Versionsverwaltung sind Begriffe der professionellen
Sowareentwicklung, die aber auch im Umfeld der PowerShell immer
mehr Bedeutung erhalten. Die Begriffe bezeichnen eigentlich zwei
verschiedene Aspekte, manche Menschen trennen dies aber nicht so
scharf.

6.13.1 Versionierung

Versionierung ist die Vergabe einer Versionsnummer für ein Programm,
Skript oder eine Sowarekomponente. Jedes Mal, wenn eine geänderte
Version ausgeliefert wird, sollte die Versionsnummer sich ändern, um die
Veränderung der Soware direkt erkennen zu können. Etabliert hat sich
das Verfahren der semantischen Versionierung (vgl. [http://semver.org/):](http://semver.org/):)

```
Eine Versionsnummer besteht aus mindestens drei Teilen:
MAJOR.MINOR.PATCH, zum Beispiel 1.10.24.
Eine Änderung der PATCH-Versionszahl bedeutet eine Fehlerkorrektur,
die voll kompatibel zu früheren Versionen ist. Hier hat sich also nur
intern etwas geändert.
Eine Änderung der MINOR-Versionszahl bedeutet eine Erweiterung
der Funktionen ohne Beeinträchtigung der Kompatibilität zu
früheren Versionen. Es gibt neue Funktionen, die alten Funktionen
funktionieren aber wie bisher.
Eine Änderung der MAJOR-Versionszahl bedeutet, dass es
Änderungen an der Art und Weise gibt, wie Programm, Skript oder
Sowarekomponente zu verwenden sind (zum Beispiel Änderungen
der Eingabeparameter).
```

```
PowerShell-Skripte haben – anders als in .exe-Dateien gespeicherte
Anwendungen oder in .dll-Dateien gespeicherte
Sowarekomponenten – keinen eingebauten Mechanismus zur
Versionsnummernvergabe und -speicherung. Bewährt hat sich, die
Versionsnummer als Kommentar zu Skriptbeginn abzulegen.
########################################
# Das PowerShell-Script inventarisiert die installierte Software
# eines Herstellers auf n Computersystemen
# (C) Dr. Holger Schwichtenberg
# Version 1.10.24 vom 31.12.2020
########################################
```
Möglich ist natürlich auch, hier im Kopf-Kommentar eines Skripts die
gesamte Versionsgeschichte abzulegen.

```
Die Versionsnummer im Dateinamen abzulegen (z. B.
SowareInventar_v1.10.24.ps1) ist o nicht günstig, weil die Nutzer
des Skriptes dann immer wieder mit anderen Dateinamen zu tun
haben. Es kann aber ein geeignetes Instrument sein, wenn die Nutzer
des Skriptes mehrere Versionen eines Skripts im Parallelbetrieb
haben müssen.
```
```
HINWEIS: Sie sollten in Ihrem Unternehmen Richtlinien für die
Versionierung von Skripten erlassen! Es ist sehr wichtig, dass Sie
erkennen können, welche Version eines Skripts im Einsatz ist.
```
6.13.2 Versionsverwaltung (Versionskontrolle)

Als Versionsverwaltung (alias: Versionskontrolle) bezeichnet man die
Erfassung aller Änderungen an (Programmcodequelltext-)Dateien, die es
ermöglicht, eine vollständige Änderungshistorie zu erhalten und zu alten
Ständen der Datei zurückzukehren. Eine Version in der


Versionsverwaltung (also eine Speicherung des Standes in der
Versionsverwaltung) sollte es zu jeder im Rahmen der Versionierung
vergebenen Versionsnummer geben. Aber es kann in der
Versionsverwaltung darüber hinaus weitere Versionsstände geben, die
nicht zu einer ausgelieferten Version gehören.

Für die Versionsverwaltung gibt es zahlreiche verschiedene
Versionsverwaltungsprogramme (alias Versionskontrollsysteme), z. B.:

```
Beispiele für kostenfreie
Versionsverwaltungsprogramme
```
```
Beispiele für kommerzielle
Versionsverwaltungsprogramme
```
CVS

Subversion

Mercurial

Git

```
Azure DevOps Services
(früher: Visual Studio Team
Services (VSTS)), nur für bis
zu fünf Benutzer kostenfrei
```
```
github.com, kostenfrei für
Open Source-Projekte
```
ClearCase Perforce

```
Azure DevOps Server (früher:
Team Foundation Server
(TFS))
```
```
Azure DevOps Services
(früher: Visual Studio Team
Services (VSTS) ,
kostenpflichtig bei mehr als
fünf Benutzern
```
```
github.com, kostenfrei für
private Projekte
```
```
TIPP: Der Autor dieses Buchs verwendet Git in Verbindung mit
Azure DevOps Services und GitHub. Zu Git und Azure DevOps gibt
es eigene Bücher. Die Behandlung in diesem Buch würde dessen
Rahmen sprengen.
```

7 PowerShell- Skriptsprache

Neben der Commandlet-Infrastruktur bietet die PowerShell auch eine eigene
Skriptsprache zur Erstellung von Befehlsabfolgen im klassischen imperativen
Programmierstil. Die Power-Shell Language (PSL) kennt nicht nur Variablen,
sondern auch übliche Programmkonstrukte wie Schleifen und Bedingungen. In
der PSL kann man komplexe Befehlsabfolgen definieren und diese zu Skripten
zusammenfassen.

Microso grei dabei nicht auf eine bestehende Skriptsprache zurück, sondern
hat sich für die Neuschöpfung nach eigenen Worten "inspirieren lassen" von
Unix-Shell-Sprachen, PERL, PHP, Python und C#. Folglich verwendet die Sprache
auch geschweie Klammern; Semikola braucht man jedoch als Befehlstrenner
nicht.

7.1 Hilfe zur PowerShell-Skriptsprache

Die Sprachkonstrukte der PowerShell sind genauso wie die PowerShell-
Commandlets in einfachen, rein textbasierten Hilfedokumenten erklärt, die mit
der PowerShell installiert werden. Die Hilfedokumente zu den Sprachkonstrukten
beginnen mit dem Wort "About", z. B. liefert der Befehl

```
Get-Help About_for
```
Hilfe zur for-Schleife. Der Befehl

```
Get-Help About
```
zeigt eine Liste aller "About"-Dokumente.


7.2 Befehlstrennung

Jede Zeile ist ein Befehl. Ein Befehl kann aus mehreren Commandlets bestehen,
die durch das "Pipe-Symbol" [|] getrennt sind. Man kann mehrere Befehle durch
ein Semikolon [;] getrennt in eine Zeile setzen. Man kann Semikola auch wie in
C++ und C# am Ende jeder Zeile verwenden – man muss es aber nicht.

```
Get-Process ; Get-Service
```
```
TIPP: Genau wie in einzeiligen Befehlen kann man in Skripten auch einen
Zeilenumbruch nach dem Pipeline-Symbol [|]oder mit einem Gravis [`],
ASCI-Code 96, bewirken.
```
7.3 Kommentare

Grundsätzlich sollte man bei der Programmierung dem eigentlichen
Programmcode zusätzliche Kommentare hinzufügen, um das Programm für sich
selbst und andere verständlich zu machen. Ein gutes Skript zeichnet sich dadurch
aus, dass es gut lesbar ist, dass der Code also entsprechend kommentiert wurde.
Zwar kann man anhand des Programmcodes o schon sehen, was innerhalb
eines Skripts geschieht, allerdings wird diese Lesbarkeit durch Kommentare
wesentlich verbessert.

Kommentare werden in der PowerShell-Skriptsprache durch eine Raute #
gekennzeichnet. Kommentare werden von der PowerShell komplett ignoriert.
Hier kann jeder beliebige Text stehen.

```
# Ein beliebiger Kommentar
```

```
HINWEIS: Die Raute gilt immer nur für den Rest der Zeile. Man kann nach
einem Befehl einen Kommentar schreiben, z. B.
$s = Get-Service | where { $_.Status -eq "running" } # holt die
gestarteten Dienste
```
```
Aber man kann nicht in die gleiche Zeile nach der Raute noch einen Befehl
schreiben, der ausgeführt werden soll.
$s = Get-Service # holt die gestarten Dienste Get-Process
```
```
Hier wird "Get-Process" ignoriert.
```
Seit der PowerShell 2.0 gibt es auch mehrzeilige Kommentare. Hier ist alles, was
zwischen <# und #> steht, ein Kommentar, auch wenn es Zeilenumbrüche gibt.

```
Listing 7.1 Ein- und mehrzeilige Kommentare im Einsatz
<#
-----------------------------------
PowerShell Script
HTTP-Download und Ausgabe am Bildschirm
(C) Dr. Holger Schwichtenberg
http://www.powershell-doktor.de
-----------------------------------
#>
```
```
# Instanz erzeugen
$wc = new-object System.Net.WebClient # Es werden keine Parameter benöti
gt
# HTML herunterladen und ausgeben
$wc.DownloadString("http://www.powershell-doktor.de")
# Zusätzliche Ausgaben
"Zusätzliche Header-Informationen:"
$wc.ResponseHeaders.ToString() # Liefert eine Liste aller HTTP-Header
```
7.4 Variablen


Variablen sind Speicher für einzelne Datenwerte, für ganze Objekte oder für
Objektmengen.

7.4.1 Variablen in der PowerShell

PowerShell-Variablen beginnen mit dem Variablenkennzeichner $. Ein
Variablenbezeichner (der Name der Variable) kann aus Buchstaben und Zahlen
sowie einem Unterstrich bestehen. Nicht erlaubt sind Namen, die bereits
vordefinierten Variablen zugewiesen wurden, insbesondere nicht der Name $_,
den die PowerShell für den aktuellen Inhalt der Pipeline verwendet.

Die Zuweisung des Inhalts an Variablen erfolgt mit dem Gleichheitszeichen:

```
$x = 5 # Zuweisung der Zahl 5 an die Variable $x
```
Bei der Verwendung (Auslesen des Inhalts) ist nichts weiter zu beachten:

```
"Die Zahl ist " + $x # Verwendung der Variablen
```
Man kann einer Variablen den Inhalt einer Pipeline zuweisen:

```
$laufendeDienste = Get-Service | Where-Object { $_.Status -eq "running"
} Und dann später darauf zugreifen, z. B.:
```
```
"Anzahl der laufenden Dienste: " + $laufendeDienste.Count
"Liste der Dienste: "
$laufendeDienste | Format-Table Name, Status
```

```
HINWEIS: Die Zuweisung an Variablen und das Auslesen kann alternativ
mit den Commandlets Set-Variable bzw. Get-Variable erfolgen. Dabei ist
jeweils zu beachten, dass in diesem Fall der Variablenname ohne "$"
anzugeben ist. Ebenso ist bei der Zuweisung kein Gleichheitszeichen zu
verwenden. Die Verwendung dieser Commandlets ist jedoch
umständlicher als der direkte Zugriff, da zusätzliche Klammerungen
notwendig sind, um Set-Variable bzw. Get-Variable in Ausdrücken zu
verwenden. Ebenso muss man bei Get-Variable immer noch auf .Value
zugreifen, da Get-Variable nicht den Wert liefert, sondern ein Objekt vom
Typ PSVariable, das den Wert verpackt.
```
```
Set-Variable x 5
"Die Zahl ist " + (Get-Variable x).Value # Verwendung der Variablen
Set-Variable laufendeDienste $(Get-Service | where { $_.Status -eq
"running" })
"Anzahl der laufenden Dienste: " + (Get-Variable laufendeDienste).Value.
Count
"Liste der Dienste: "
(Get-Variable laufendeDienste).Value | ft Name, Status
```
7.4.2 Typisierung

Variablen sind entweder untypisiert

```
$a = 5
```
oder typisiert auf einen PowerShell-Datentyp oder eine beliebige .NET-Klasse

```
[int] $a = 5
[System.DateTime] $a = "1.8.2020"
```

```
TIPP: Das Voranstellen des Typnamens zur Variablentypisierung
[int] $a = 5
```
```
bewirkt, dass die Variable nur Daten dieses Typs aufnehmen kann, und
entspricht damit der klassischen Typisierung in Hochsprachen wie C++,
Java und C#. Danach folgende Versuche, der typisierten Variablen einen
inkompatiblen Wert zuzuweisen, z. B. $a = "Hallo", führen zum
Laufzeitfehler "Cannot convert value". Eine Zeichenkette, die eine Zahl
erhält, darf aber im konkreten Fall zugewiesen werden, weil PowerShell
die Zeichenkette automatisch konvertiert: $b = "123"
Es ist nicht möglich, eine Variablentypisierung ohne Wertinitialisierung
durchzuführen. Der Ausdruck
[int] $a
```
```
typisiert nicht die Variable, sondern ru den Wert ab und konvertiert ihn
in eine Ganzzahlvariable.
```
Anders als in vielen anderen Programmiersprachen ist es in der PowerShell-
Skriptsprache erlaubt, eine Variable in einem Gültigkeitsbereich (Scope)
mehrfach zu deklarieren, auch mit verschiedenen Typen.

```
TIPP: Die Mehrfachdeklaration ist kein guter Programmierstil und sollte
vermieden werden.
```
```
[int] $a = 5
$a # Ausgabe: 5
[System.DateTime] $a = "1.8.2020"
$a # Ausgabe: Mittwoch, 8. Januar 2020 00:00:00
[bool] $a = $true
$a # Ausgabe true
```

7.4.3 Datentypen/Typbezeichner in PowerShell

Als Typbezeichner (alias Typname oder Typkennzeichner) können alle .NET-
Klassennamen verwendet werden sowie einige vordefinierte Typbezeichner
(sogenannte "Typadapter" oder auch "Type Accelerators") der PowerShell.
Beispielsweise sind [int], [System.Int 32 ] und [int 32 ] völlig gleichbedeutend.
[int] ist der eingebaute PowerShell-Typbezeichner für Ganzzahlen mit 32 Bit
Länge. Dieser Typ wird abgebildet auf die .NET-Klassen [System. Int 32 ]. Dieser
Name kann wiederum mit [int 32 ] abgekürzt werden. Wie viel man tippen
möchte, ist also Geschmackssache. Typadapter gibt es auch für komplexere
Klassen, z. B. [ADSI] und [WMI] (siehe Tabelle).

Die folgende Tabelle zeigt die wichtigsten Datentypen.

Tabelle 7.1 Die wichtigsten Datentypen der PowerShell



7.4.4 Variablen mit Null-Werten

Variablen müssen in der PowerShell im Standard nicht explizit deklariert werden.

Variablen, die nicht initialisiert wurden, haben in PowerShell im Standard den
Null-Wert ($null). Während in den meisten objektorientierten
Programmiersprachen (z. B. Java, C++, C#, Visual Basic) die Anwendung des
Punkt-Operators auf einen Null-Wert zum Laufzeitfehler führt (Null Reference
Exception), ist die PowerShell in einigen Situationen tolerant, z. B. bei der
Ausgabe oder der Anwendung eines mathematischen Operators (hier konvertiert
Power-Shell $null automatisch in die Zahl 0) sowie dem Aufruf des Properties
Length.

Einen Laufzeitfehler bekommt man aber beim Aufruf anderer Properties oder
dem Aufruf von Methode sowie bei der Verwendung mit Get-Variable oder dem
Laufwerk Variable:.


```
Listing 7.2 [1_Basiswissen\PowerShellLanguage\Variablen.ps1]
if ($nichtintialisierteVariable -eq $null) { Write-Host '$nichtintialisi
erteVariable
ist $null' }
$nichtintialisierteVariable # kein Fehler
$nichtintialisierteVariable + 2 # kein Fehler, liefert 2, weil $null -> 0
$nichtintialisierteVariable.Length # kein Fehler
[Math]::Abs($nichtintialisierteVariable) # kein Fehler
$nichtintialisierteVariable.Substring(2,4) # Laufzeitfehler: Null Refere
nce
$nichtintialisierteVariable.ToUpper() # Laufzeitfehler: Null Reference
Get-Variable nichtintialisierteVariable # Laufzeitfehler: Cannot find a
variable with
the name 'nichtintialisierteVariable'.
Variable:nichtintialisierteVariable # Laufzeitfehler: Cannot find a vari
able with the
name 'nichtintialisierteVariable'.
```
7.4.5 Initialisierungszwang

Die Tatsache, dass Variablen in PowerShell im Standard keinem
Initialisierungszwang unterliegen, ist gefährlich. Somit besteht selbst bei
einfachen Schreibfehlern bei Variablennamen die Gefahr, dass es unerwünschte
Effekte gibt, weil man $null bekommt, obwohl man etwas anderes erwartet.

Mit der Anweisung Set-PSDebug -Strict können Sie erreichen, dass die
PowerShell einen Fehler meldet, wenn man eine Variable ausliest, der man zuvor
keinen Wert zugewiesen hat. Seit PowerShell 2.0 gibt es zusätzlich Set-
StrictMode. Im Gegensatz zu Set-PSDebug wirkt sich Set-StrictMode nur auf den
aktuellen Gültigkeitsbereich einschließlich der untergeordneten Bereiche aus
und kann deshalb in einem Skript oder in einer Funktion verwendet werden,
ohne globalen Einfluss zu haben.

Set-StrictMode hat einen Pflichtparameter -Version, der sich auf die PowerShell-
Version bezieht und unterschiedliche Regeln mit sich bringt.

Die Angabe des Parameterwertes Latest bewirkt, dass der jeweils aktuelle
Regelsatz verwendet wird.


Mit Set-StrictMode -Off kann man den strengen Modus wieder aufheben.

```
Wert für Version Bedeutung
```
```
1.0 Verhindert Verweise auf nicht initialisierte Variablen, mit
Ausnahme nicht-initialisierter Variablen in Zeichenfolgen
Latest oder
andere gültige
Versionsummer
(z. B. 5.1 oder 7.0)
```
```
Verhindert Verweise auf nicht-initialisierte Variablen
(einschließlich nicht-initialisierter Variablen in
Zeichenfolgen) Verhindert Verweise auf nicht-vorhandene
Eigenschaen eines Objekts
```
```
Verhindert Funktionsaufrufe mit der Syntax für aufrufende
Methoden Verhindert eine Variable ohne Namen (${})
```

Listing 7.3 [1_Basiswissen\PowerShellLanguage\Variablen.ps1]

```
# Variablen mit Null-Werten
Set-StrictMode -Off
if ($nichtintialisierteVariable -eq $null) { Write-Host '$nichtintialisi
erteVariable
ist $null' }
$nichtintialisierteVariable # kein Fehler
$nichtintialisierteVariable + 2 # kein Fehler, liefert 2, weil $null -> 0
$nichtintialisierteVariable.Length # kein Fehler
[Math]::Abs($nichtintialisierteVariable) # kein Fehler
$nichtintialisierteVariable.Substring(2,4) # Laufzeitfehler: Null Refere
nce
$nichtintialisierteVariable.ToUpper() # Laufzeitfehler: Null Reference
Get-Variable nichtintialisierteVariable # Laufzeitfehler: Cannot find a
variable with
the name 'nichtintialisierteVariable'.
Variable:nichtintialisierteVariable # Laufzeitfehler: Cannot find a vari
able with the
name 'nichtintialisierteVariable'.
```
```
"Nun streng..."
Set-StrictMode -Version 7.0
# Nun verursachen alle Zugriffe einen Laufzeitfehler:
# The variable '$nichtintialisierteVariable' cannot be retrieved because
```

```
it has not
been set.
if ($nichtintialisierteVariable -eq $null) { Write-Host '$nichtintialisi
erteVariable
ist $null' }
$nichtintialisierteVariable
$nichtintialisierteVariable + 1
$nichtintialisierteVariable.Length
$nichtintialisierteVariable.Substring(2,4)
```
```
# Nun alles richtig!
$nichtintialisierteVariable = "Holger Schwichtenberg"
if ($nichtintialisierteVariable -eq $null) { Write-Host '$nichtintialisi
erteVariable
ist $null' }
$nichtintialisierteVariable
$nichtintialisierteVariable + 1
$nichtintialisierteVariable.Length
$nichtintialisierteVariable.Substring(2,4)
```
```
HINWEIS: Die Aktivierung der Initialisierungspflicht für Variablen stellt
nicht sicher, dass man niemals eine Variable in Händen hält, die den Null-
Wert $null enthält. In einigen Fällen ist die PowerShell tolerant bei der
Ausgabe von Null-Werten, in anderen Fällen ist $null abzufangen. Die
PowerShell ab Version 7 bietet dafür drei Hilfen an:
Null Assignment Operator ??
Null Coalescing Operator ??=
Null Conditional Operator ?.
```
7.4.6 Null Coalescing Operator ??

Der "Null Coalescing Operator" ??, den in C# schon seit 2005, in PowerShell aber
erst ab Version 7.0 gibt, liefert den Wert des vorangestellten Ausdrucks, wenn
dieser nicht $null ist. Wenn der Wert $null ist, wird der Wert des nachfolgenden


Ausdrucks übergeben. Somit kann man auf elegante Weise den Null-Fall in einen
anderen Wert umwandeln.

```
$name = $name ?? "n/a"
```
In PowerShell 1.0 bis 6.2 musste man länger schreiben:

```
if ($name -eq $null) { $name = "n/a"}
```
7.4.7 Null Coalescing Assigment Operator ??=

Eine weitere Behandlung des $null-Falls ist in PowerShell 7.0 hinzugekommen in
Form des Operators "Null Coalescing Assignment" mit ??=. Mit diesem
Zuweisungsoperator kann der PowerShell-Nutzer eine Zuweisung ausführen,
wenn eine Variable den Wert $null hat. Damit werden einige Einsatzgebiete des
Null Assignment Operators nochmals verkürzt.

Statt

```
if ($name -eq $null) { $name = "n/a"}
```
oder

```
$name = $name ?? "n/a"
```
kann man nun noch prägnanter schreiben:

```
$name ??= "n/a"
```
Diesen Operator gibt es auch in C# seit Version 8.0.

7.4.8 Null Conditional Operator ?. und ?[]

Seit PowerShell 7.0 gibt es das Feature Null Conditional Operator ?.. Es war in
Version 7.0 zunächst experimentell und musste aktivieren werden:

```
Enable-ExperimentalFeature PSNullConditionalOperators
```

Seit Version 7.1 ist dies nicht mehr notwendig.

Der Null Conditional Operator ermöglicht in der PowerShell-Sprache das
Abfangen von Null-Referenz-Fehlern; es gibt diesen Operator auch in der
Programmiersprache C# schon seit deren Version 6.0.

Für den Null Conditional Operator verwendet man beim Zugriff auf
Objektmitglieder ?. anstelle von.

Während der Punkt-Operator mit einem Laufzeitfehler abstürzt, wenn er auf ein
Objekt angewendet wird, das den Wert $null hat (z. B. eine nicht initialisierte
Variable), ist ?. in diesem Fall tolerant und gibt $null weiter.

In der PowerShell ist zu beachten, dass es aber nicht reicht,. durch ?. zu ersetzen
wie in C#. Vielmehr muss man den Variablennamen auch in geschweie
Klammern setzen:

```
${variablenname}?.Methode()
```
oder

```
${ variablenname }?.Property
```
Details dazu zeigt die folgende Abbildung:

Bild 7.1 Null Conditional Operator in PowerShell 7

Mengenelementzugriff mit ?[]

Für Mengen setzt man neu neuen Operator ?[] ein:


Bei der Menge

```
$menge = $null
```
führt der Befehl

```
$menge[ 100 ]
```
normalerweise zum Laufzeitfehler "InvalidOperation: Cannot index into a null
array."

Der Befehl

```
${menge}?[ 100 ]
```
führt nicht zum Fehler, weil er $null liefert.

Der Operator ?[] ist nicht notwendig, wenn man bei einer initialisierten Menge
auf ein Element zugrei, dass es nicht gibt.

```
$menge = 1..10
$menge[ 100 ]
```
In diesem Fall gibt es keinen Laufzeitfehler. Gleichwohl kann man aus Vorsicht
auch hier schreiben

```
${menge}?[ 100 ]
```
wenn man nicht sicher ist, dass $menge initialisiert ist.

7.4.9 Typkonvertierung (Typumwandlung)

Als Typkonvertierung (engl. Type Cast) bezeichnet man die Umwandlung einer
Information, die in einem Datentyp vorliegt, in einen anderen Datentyp. Die
PowerShell-Skriptsprache ist bei der Typumwandlung sehr viel toleranter als
viele andere .NET-basierte Programmiersprachen und nimmt viele
Typkonvertierungen automatisch vor.

Das folgende Listing zeigt, dass die PowerShell die gebrochene Zahl 5.1
automatisch in eine Ganzzahl wandelt, nämlich wenn


sie in einer Zeichenkette steht

man die Konvertierung explizit mit vorangestelltem [Typbezeichner]
deklarieren kann

man die Konvertierung auch mit nachgestelltem -as [Typbezeichner]
deklarieren kann

die PowerShell $true in die Zahl 1 wandelt

die PowerShell $false in die Zahl 0 wandelt

die PowerShell eine Zeichenkette, die aus Buchstaben und Zahlen besteht,
nicht umwandeln kann. Im Standard kommt es zum Fehler.

bei der Umwandlung einer Zeichenkette mit Buchstaben und Zahlen mithilfe
des Operators -as das Ergebnis 0 ist


```
Listing 7.4 [1_Basiswissen\PowerShellLanguage\Variablen.ps1]
[int] $x = 1.23
$x # Ausgabe: 1
```
```
$x = "2.34"
$x # 2
```
```
$x = [Int] "3.45"
$x # 3
```
```
$x = 4.56 - as [Int]
$x # 4
```
```
$a = $false
$x = $a -as [Int]
$x # 0, weil $true = 1, während $false = 0
```
```
$a = $true
$x = $a -as [Int]
$x # 1, weil $true = 1, während $false = 0
```
```
$x = "Nummer 1" # Fehler: Der Wert "Nummer 1" kann nicht in den Typ "Sys
tem.Int32"
konvertiert werden.
$x # immer noch: 1
```
```
$x = [Int] "Nummer 1" #Fehler: Der Wert "Nummer 1" kann nicht in den Typ
"System.
Int32" konvertiert werden.
$x # immer noch: 1
```
```
$x = "Nummer 1" - as [Int] # Kein Fehler, liefert 0
$x # 0
```
7.4.10 Gültigkeitsbereiche (Scope)


Eine Variable wird durch eine Zuweisung auch direkt deklariert und gilt dann
innerhalb des entsprechenden Gültigkeitsraums (engl. Scope), in dem sie
deklariert wurde (z. B. einem Block, einer Unterroutine oder dem ganzen Skript).

Mit $script kann man eine Variablendeklaration einleiten, die über den aktuellen
Skriptblock im ganzen aktuellen Skript hinaus gültig ist.

Mit $global kann man eine Variablendeklaration einleiten, die global, d. h. nicht
nur außerhalb eines Skriptblocks, sondern sogar außerhalb des aktuellen Skripts,
gültig sind.

Beispiel: In dem folgenden Skript ist $x 2 nur in dem Skriptblock gültig. Alle
anderen Variablen sind auch außerhalb des Skriptblocks gültig. $x 4 ist auch
gültig außerhalb des Skripts, d. h., der Wert ist nach Ende des Skripts noch
vorhanden. Wenn die aktuelle PowerShell-Instanz (Konsole oder ISE) aber
geschlossen wird, ist der Wert dann auch weg.

```
Listing 7.5 [1_Basiswissen\PowerShell Language\VariablenGueltigkeit.ps1]
Remove-Variable x*
"Test für Gültigkeitsbereiche"
$x 1 = "Wert"
```
```
# Scriptblock
$cmd = {
"Skriptblock"
$x 2 = "Wert"
$script:x 3 = "Wert"
}
```
```
& $cmd
```
```
$global:x 4 = "Wert"
```
```
"x 1 =$x1"
"x 2 =$x2" # ist leer!
"x 3 =$x3"
"x 4 =$x4"
"Skriptende!"
```
Die folgende Abbildung zeigt die Ausführung des obigen Skripts. Zunächst wird
das Skript normal (ohne "Dot Sourcing") aufgerufen. Nach Skriptende ist nur die


Variable $x 4 noch verfügbar, die mit $global deklariert wurde.

Wenn man das Skript hingegen mit Dot Sourcing startet, sind die Variablen $x 1 ,
$x 3 und $x 4 verfügbar.

Bild 7.2 Beispiel zur Variablengültigkeit

7.4.11 Variablen leeren oder löschen

Eine befüllte Variable kann man wieder leeren mit dem Commandlet Clear-
Variable. Dabei ist aber der Name der Variablen ohne $ anzugeben, z. B.:

```
Get-Variable x
```
Mit Remove-Variable kann man eine Variablendeklaration wieder aufheben (was
in vielen anderen Sprachen nicht möglich ist).


```
$name = "Holger Schwichtenberg"
$name
Get-Variable name
Clear-Variable name
Get-Variable name # ist noch da, aber leer
$name
Remove-Variable name
Get-Variable name # Fehler
$name # kein Fehler, sofern nicht Set-PSDebug -Strict
```
```
TIPP: Der folgende Befehl löscht alle Variablen, deren Name mit x
beginnt:
Remove-Variable x*
```
7.4.12 Variablentyp ermitteln

Unabhängig davon, ob eine Variable typisiert wurde oder nicht, kann man den
Datentyp jederzeit ermitteln. Bei untypisierten Variablen hat die Variable
automatisch den Datentyp des zuletzt zugewiesenen Typs.

Den Datentyp liefert die Methode GetType() in Form eines .NET-Objekts vom Typ
System. Type. Da jede PowerShell-Variable eine Instanz einer .NET-Klasse ist,
besitzt jede PowerShell-Variable die Methode GetType(), die jedes .NET-Objekt
von der Mutter aller .NET-Klassen (System.Object) erbt. Meistens interessiert man
sich nur für den Klassennamen, den man aus Fullname (mit Namensraum) oder
Name (ohne Namensraum) auslesen kann.

```
$b = [System.DateTime] "6.1.2020"
"$b hat den Typ: " + $b.GetType().Fullname # liefert: System.DateTime
```
7.4.13 Vordefinierte Variablen


Die PowerShell kennt zahlreiche vordefinierte Variablen (alias eingebaute
Variablen alias interne Variablen). Die nachstehende Tabelle zeigt nur eine
Auswahl dieser Variablen.


Tabelle 7.2 Vordefinierte PowerShell-Variablen (Auswahl)

```
Variable Bedeutung
$true Wert "wahr"
```
```
$false Wert "falsch"
```
```
$OFS Trennzeichen für die Ausgabe von Objektmengen
```
```
$Home Heimatordner des angemeldeten Benutzers
```
```
$PSHome Installationsordner des PowerShell-Hosts
$Args Parameter (zur Verwendung in Funktionen)
```
```
$Input Aktueller Inhalt der Pipeline (zur Verwendung in
Funktionen)
$_ Aktuelles Objekt der Pipeline (zur Verwendung in
Schleifen)
$StackTrace Aktuelle Aufrufreihenfolge
```
```
$Host Informationen über den PowerShell-Host und
Einstellmöglichkeiten, z. B. Farbe
$LastExitCode Rückgabewert der zuletzt ausgeführten externen
Windows- oder Konsolenanwendung
$Error Komplette Liste aller aufgetretenen Fehler seit Start
der PowerShell (die maximal gespeicherte Anzahl ist
durch $MaximumErrorCount festgelegt)
$PSModuleAutoLoading-
Preference Steuerung des Ladeverhaltens von Modulen
$ErrorActionPreference Steuerungen des Verhaltens im Fehlerfall. Standard
ist "Continue" (d. h. Ausgabe des Fehlers und dann
Fortsetzen des Skripts). Weitere Optionen:
SilentlyContinue, Stop, Inquire, Ignore, Suspend
```

```
$VerbosePreference Festlegung, ob im Standard Ausgaben erfolgen, die
als "verbose" deklariert sind. Standard ist
SilentlyContinue (d. h. keine Ausgaben). Weitere
Optionen sind: Stop, Continue, Inquire, Ignore,
Suspend
$WhatIfPreference Festlegung, ob im Standard alle Befehle, die -whatif
unterstützen, diesen Modus nutzen. Der Standard ist
$false, d. h., der Befehl wird tatsächlich ausgeführt.
```
Mit $Host kann man die Farben der PowerShell-Konsole für die ganze aktuelle
Sitzung verändern, z. B.:

```
$Host.UI.RawUI.BackgroundColor = "darkgreen"
```
Das Trennzeichen für Objektmengen kann man mit $OFS verändern:

Der Befehl

```
$OFS="/" ; [string] ("a","b","c")
```
liefert die Ausgabe:

```
a/b/c
```
```
TIPP: Alle deklarierten Variablen, sowohl die eingebauten als auch die
selbst definierten, erhält man durch den Befehl Get-ChildItem Variable:
alias Dir Variable:.
Dir Variable:p* listet alle Variablen auf, die mit "p" oder "P" beginnen.
Get- Variable p* hat den gleichen Effekt.
```
Einige der eingebauten Variablen können nicht geändert werden. Für eigene
Variablen kann man diesen Zustand erreichen mit:

```
Set-Variable variablenname -Option readonly
```

```
ACHTUNG: Dabei ist der Variablenname ohne das Dollarzeichen zu
verwenden!
```
7.5 Variablenbedingungen

Seit PowerShell 3.0 erlaubt es Microso, zu einer Variablen Bedingungen
abzulegen, die diese erfüllen muss. Die Bedingung wird bei jeder Zuweisung
geprü. Fehlerhae Zuweisungen werden mit Fehlerausgaben von der
PowerShell quittiert; die PowerShell bricht in der Standardeinstellung das Skript
aber nicht ab.

Achtung: Wichtig ist, dass schon bei der Initialisierung Werte gesetzt werden, da
sonst die Variable nicht korrekt typisiert wird und auch die Annotationen nicht
wirken.

Mögliche Bedingungen sind:

```
die Länge einer Zeichenkette: [ValidateLength(1,5)],
der Aufbau einer Zeichenkette, beschrieben durch einen regulären Ausdruck:
[Validate Pattern("[0-9A-F]*")],
ein Ausdruck, der wahr sein muss: [ValidateScript({$_.Starts With("A")})],
dass ein Zahlenwert aus einem Wertebereich stammen muss:
[ValidateRange(0,100)],
dass ein Parameter ein Wert einer vordefinierten Liste sein muss:
[ValidateSet("A","B","C")].
```
```
HINWEIS: In .NET heißen die Ausdrücke in eckigen Klammern "Attribute",
wobei dies kein guter Begriff ist, weil Attribute in anderen
objektorientierten Programmiersprachen/-frameworks die Eigenschaen
eines Objekts sind. Besser wäre "Annotation" (vgl. Java). Die genannten
Annotationen wurden schon mit PowerShell 2.0 eingeführt, konnten dort
aber zunächst nur auf Parameter einer Funktion angewendet werden. Neu
seit PowerShell-Version 3.0 ist die Anwendung auf jede beliebige Variable.
```

In dem folgenden Beispiel werden zunächst gültige Werte zugewiesen, dann aber
ungültige.

```
"gültige Zuweisungen bei Initialisierung"
[ValidateRange(0,1000)] [int] $BenuterAnzahl = 0
[ValidateLength(1,15)] [string] $benutzername = "HSchwichtenberg"
[ValidateScript({$_.StartsWith("I")})] [string] $Domain = "ITV"
[ValidatePattern("(\w[-._\w]*\w@\w[-._\w]*\w\.\w{2,3})")] [string]
$BenutzerEMail = "buero@it-visions.de"
```
```
"weitere gültige Zuweisungen"
$benutzername = "HolgerS"
$BenutzerAnzahl = 1
$BenutzerEMail = "Kundenteam@IT-Visions.de"
$Domain = "ITV-Schulungen"
```
```
"ungültige Zuweisungen"
$benutzername = "HolgerSchwichtenberg"
$BenutzerAnzahl = -1
$BenutzerEMail = "Unsinn"
$Domain = "unsinn"
```
7.6 Zahlen

Zahlenliterale können in der PowerShell angegeben werden entweder als

```
Dezimal-Ganzzahlen, z. B. 123 ,
gebrochene Dezimalzahlen mit Nachkommastellen (mit Punkt als
Trennzeichen zu den Nachkommastellen. Ein Komma als Trennzeichen ist
nicht erlaubt!), z. B. 123456 ,
Hexadezimalzahlen durch ein vorangestelltes 0 x, z. B. 0 Xff für den Wert 255.
Sie lassen sich verwenden wie Dezimalzahlen, z. B. 0 Xff+ 1 ergibt 256.
oder als Wertebereich, z. B. 1..5 ist die Menge aller Zahlen von 1 bis 5 in Form
einer Liste (Collection) von Ganzzahlen in der PowerShell-Pipeline.
```

```
TIPP: Mit den Kürzeln KB, MB, GB, TB und PB können die Maßeinheiten
Kilobyte, Megabyte, Gigabyte, Terabyte und Petabyte komfortabel
verwendet werden, z. B. steht die Eingabe 5 MB für die Zahl 5242880 (5 *
1024 * 1024).
```
Bild 7.3 Zahlen in der PowerShell

Bei der Zuweisung eines Zahlenliterals zu einer untypisierten Variablen erzeugt
die Power-Shell im Standard eine Instanz des Typs System. Int 32. Reicht der
Wertebereich von Int 32 nicht aus, werden Int 64 oder Decimal erzeugt. Wenn das
Zahlenliteral eine gebrochene Zahl ist (mit einem Punkt zur Trennung der
Nachkommastellen), dann erzeugt die PowerShell Double oder Decimal.

Möchte man Kontrolle über den Datentyp der Variablen, muss man die Variable
explizit typisieren, z. B. mit [Byte] oder [Decimal]. Für Decimal gibt es eine weitere
Möglichkeit, indem man ein "d" an das Literal anhängt (z. B. 5.1d).


```
# Implicit Integer
$i = 5
$i.GetType().Name
```
```
# Implicit Long
$i = 5368888888888888
$i.GetType().Name
```
```
# Implicit Decimal
$i = 53688888888888888888888888888
$i.GetType().Name
```
```
# Explicit Long
[Int 64 ] $l = 5
$l.GetType().Name
```
```
# Explicit Byte
[Byte] $b = 5
$b.GetType().Name
```
```
# Implicit Double
$d = 5.1
$d.GetType().Name
```
```
# Implicit Decimal
$d = 5.1d
$d.GetType().Name
```
```
# Explicit Decimal
[Decimal] $d = 5.1
$d.GetType().Name
```
Zufallszahlen

Eine Zufallszahl kann man mit dem Commandlet Get-Random (seit PowerShell 2.0)
oder in PowerShell 1.0 in den PowerShell Community Extensions
[GITHUB.COM/PSCX/PSCX] erzeugen. Get-Random liefert eine Zahl zwischen 0 und


1. Mit den Parametern -Min und -Max kann man den Wertebereich beeinflussen
(siehe Abbildung).

Seit PowerShell 7.0 kann man auch mit -count anfordern, dass mehr als eine
Zufallszahl geliefert wird. So zieht man die Lottozahlen (6 aus 49 plus Zusatzzahl)
für das nächste Wochenende:

```
Get-Random -Minimum 1 - Maximum 49 - count 7
```
Bild 7.4 Einsatz von Get-Random zur Erzeugung von Zufallszahlen zwischen 1 und 49

Zuvor musste man dafür eine Schleife bilden:

```
for($i=0;$i -le 7;$i++) { Get-Random -Minimum 1 - Maximum 49 }
```
Falls die selbstgezogenen Lottozahlen Sie nicht zum Multi-Millionär machen und
Sie daher in der IT weiterarbeiten müssen, hil Ihnen vielleicht die folgende
Befehlszeile, die ein komplexe Zufallskennwort mit Groß- und Kleinbuchstaben,
Zahlen sowie Sonderzeichen (ASCII-Werte 33 (!) bis 126 (~)) mit einer Länge 10
und 20 Zeichen erzeugt. Die Zahl wird damit mit dem Typkonvertier [char] in ein
ASCII-Zeichen verwandelt. Join-String fügt am Ende der Pipeline die einzelnen
Zeichen zu einer Zeichenkette zusammen:


```
Get-Random -Minimum 33 - Maximum 126 - count (Get-
Random -Minimum 10 - Maximum 20 ) | Foreach-Object { [char]$_ } | Join-Str
ing
```
Für alle, die noch nicht PowerShell 7 verwenden, hier auch ein
Zufallskennwortgenerator, der in PowerShell 2.0 bis 6.2 läu:

```
Function New-Password([int] $Anzahl)
{
$kennwort = ""
$zufallszahlgenerator = New-Object System.Random
for($i=0;$i -lt $Anzahl;$i++) { $kennwort = $kennwort +[char]$zufallszah
lgenerator.
next(33,126) }
return $kennwort
}
```
```
New-Password 15
```
Alternativ kann man Zufallszahlen mit den .NET-Klassen System.Random oder
System. Security.Cryptography.RandomNumberGenerator erzeugen.

Get-Random basiert auf System.Random. System.Random verwendet die aktuelle
Systemuhrzeit als Ausgangsbasis für die Berechnung von Zufallszahlen; dies
bedeutet eine gewisse Vorhersagbarkeit der Zufallszahlen (siehe Ausschnitt aus
der Dokumentation unten).

```
Listing 7.6 Zufallszahlen erzeugen mit der .NET-Klasse System.Random
$rnd = New-Object System.Random
$zufallszahl = $rnd.next( 100 )+ 100
$zufallszahl
```

Auf jeden Fall vorhersagbar sind die Zufallszahlen, wenn man einen festen
Ausgangswert (Seed) als Konstruktorparameter bei System.Random übergibt.

```
Listing 7.7 Zufallszahlen erzeugen mit der .NET-Klasse System.Random mit festen Seed-Wert
$rnd = New-Object System.Random( 12345 )
$zufallszahl = $rnd.next( 100 )+ 100
$zufallszahl
```
System.Security.Cryptography.RandomNumberGenerator hat dieses Problem nicht:

```
# kryptografisch starker Zufallszahlengenerator
[System.Security.Cryptography.RandomNumberGenerator]::GetInt 32 ( 49 )
```
Bild 7.5 Hinweise in der Dokumentation zu System.Random [https://docs.microso.com/en-
us/dotnet/api/system.random.-ctor?view=netcore-3.1]

7.7 Zeichenketten (Strings)

Zeichenketten sind Ansammlungen von Buchstaben, Zahlen und Sonderzeichen.
Zeichenketten können leer sein.


7.7.1 Zeichenkettenliterale

Zeichenketten sind in der PowerShell Instanzen der .NET-Klasse System.String.
Sie werden begrenzt durch einfache ['] oder doppelte Anführungszeichen ["] oder
['@) (@']. Die letzte Variante, die auch Zeilenumbrüche in der Zeichenkette
erlaubt, nennt Microso "Here-String".

```
Listing 7.8 Beispiel für einen Here-String
[1_Basiswissen/PowerShellLanguage/strings.ps1]
#Here-String
@'
Eine lange Zeile
kann in spezielle
Begrenzer
verpackt werden
'@
```
```
ACHTUNG: Bei der Parameterübergabe an Commandlets sind
Zeichenketten nur in Anführungszeichen zu schreiben, wenn die
Parameterabgrenzung sonst nicht mehr klar wäre, also wenn ein
Leerzeichen darin vorkommt.
Beispiel:
Dir c:\Windows
Dir "c:\Program Files"
```
```
Es wäre hier sehr falsch, die Anführungszeichen wegzulassen, denn dann
würden c:\Program und Files jeweils als eigener Parameter interpretiert
werden.
```
7.7.2 Zeichenketten zusammensetzen

Zwei oder mehrere Zeichenketten kann man in der PowerShell durch das
Pluszeichen verbinden.


```
$vorname = "Holger"
$name = "Schwichtenberg"
$ganzername = "Dr. " + $vorname + " " + $name
Write-Host $ganzername -ForegroundColor Yellow
```
```
Achtung bei der Zeichenkettenzusammensetzung in Parametern!
In den beiden nachstehenden Befehlen erkennt die PowerShell die
Grenzen der Parameter nicht richtig:
Write-Host "Dr. " + $vorname + " " + $name -ForegroundColor Yellow
Write-Host "Dr. "+$vorname+" "+$name -ForegroundColor Yellow
```
```
Hier ist eine Klammerung notwendig:
Write-Host ("Dr. " + $vorname + " " + $name) - ForegroundColor Yell
ow
```
7.7.3 Variablenauflösung in Zeichenketten

Alternativ zu der Zeichenkettenzusammensetzung mit dem Pluszeichen kann
man die Variablenauflösung in Zeichenketten verwenden.

PowerShell-Variablen werden nicht nur in Ausdrücken, sondern auch innerhalb
von Zeichenketten aufgelöst, wenn die Zeichenkette mit einem doppelten
Anführungszeichen begrenzt ist.

Wenn Folgendes deklariert ist

```
[int] $count = 1
[string] $Computer = "SERVER01"
```
dann kann man statt

```
$count.ToString() + ". Zugriff auf Computer " + $Computer
```
auch einfacher schreiben:


```
"$count. Zugriff auf Computer $Computer"
```
In beiden Fällen ist das Ergebnis gleich:

```
"1. Zugriff auf Computer SERVER01"
```
Oder das Beispiel aus dem vorherigen Kapitel

```
$vorname = "Holger"
$name = "Schwichtenberg"
$ganzername = "Dr. $vorname $name"
Write-Host $ganzername -ForegroundColor Yellow
```
Die Variablenauflösung funktioniert ebenso in Parametern von Commandlets.
Auch die beiden folgenden Befehle sind gleichbedeutend, d. h., in beiden Fällen
wird der Verzeichnispfad WinNT://SERVER 01 angesprochen:

```
Get-DirectoryEntry ("WinNT://" + $Computer)
Get-DirectoryEntry "WinNT://$Computer"
```
Die Variablenauflösung ist genau genommen keine Variablenauflösung, sondern
eine Ausdruckauflösung. Das Dollarzeichen kann auch einen beliebigen
Ausdruck einleiten.

Dafür drei Beispiele:

```
"1+ 3 =$( 1 + 3 )"
```
```
"Aktuelle Uhrzeit: $((Get-Date).ToShortTimeString())"
```
```
"Anzahl der laufenden Prozesse: $((Get-Process).Count)"
```
Bild 7.6 Ausgabe der obigen Beispiele


```
ACHTUNG: Eine Variablenauflösung findet nicht statt, wenn die
Zeichenkette in einfachen Anführungszeichen ['] steht:
'$count. Zugriff auf Computer $Computer'.
```
```
Diesen Umstand kann man trickreich nutzen, siehe Kapitel
"Standardeinstellungen ändern mit Profilskripten".
```
Ein Unterstrich ist in Variablennamen erlaubt. Wenn man einen Unterstrich in
einer Zeichenkette mit einer Variablen verbinden will, so geht dies nicht so:

```
[string] $Computer = "Server113"
$VhdPath = "x:\VMs\$computer_VHD.vhdx"
```
In diesem Fall sucht die PowerShell eine Variable mit Namen $computer_VHD, die
es aber nicht gibt. Die Variable $vhdpath enthält dann nur x:\VMs\.vhdx.

Richtig ist der Einsatz des Gravis [`], der das Ende des Variablennamens einleiten
muss:

```
$VhdPath = "x:\VMs\$computer`_VHD.vhdx"
```
Danach ist das Ergebnis richtig: x:\VMs\Server113_VHD.vhdx

7.7.4 Wiederholte Zeichenketten

Um eine Zeichenkette mehrfach auszugeben, muss man diese nicht mehrfach
eintippen und auch nicht wie in anderen Programmiersprachen eine Schleife
erzeugen. In der PowerShell-Skriptsprache kann man Zeichenketten
multiplizieren.

```
"*" * 20
"ACHTUNG! " * 5
Write-warning ("ACHTUNG! " * 5 )
```

Bild 7.7 Multiplizieren von Zeichenketten

7.7.5 Leere Zeichenketten

Zeichenketten haben die Besonderheit, dass es für den Zustand "leer" zwei Werte
gibt:

1. die leere Zeichenkette mit doppelten "" oder einfachen Anführungszeichen ‚'
2. den Wert $null

Wie das folgende Listing zeigt, gibt es auf dem Bildschirm in beiden Fällen eine
Leerzeile. Relevant wird der Unterschied aber bei Vergleichen, denn dabei ist eine
leere Zeichenkette nicht das gleiche wie $null. Man muss also immer auf "" und
$null vergleichen: $name -eq "" - or $name -eq $null. Hier kann man alternativ
eine statische Methode aus der Klasse System.String anwenden:
[String]::IsNullOrEmpty($name).

```
TIPP: Im Rahmen von If-Bedingungen kann man einfach if ($name) bzw.
if (-not $name) verwenden! Dies prü sowohl auf Leerzeile als auch auf
$null.
```

```
Listing 7.9 [1_Basiswissen\PowerShellLanguage\Variablen.ps1]
$name = "Holger Schwichtenberg"
$name # Ausgabe: Holger Schwichtenberg
$name = "" # leere Zeichenkette
$name # Ausgabe: Leerzeile
$name -eq "" # true
$name -eq $null # false
$name = $null # Zeichenkette ist null, d. h. nicht vorhanden
$name # Ausgabe: Leerzeile
$name -eq "" # false
$name -eq $null # true
[String]::IsNullOrEmpty($name) #true
if ( $name) { "Name ist nicht leer!" }
if (-not $name) { "Name ist leer!" }
```
7.7.6 Sonderzeichen in Zeichenketten

Sonderzeichen in Zeichenketten werden in PowerShell mit dem Gravis [`]
eingeleitet.

Wichtige Sonderzeichen sind:

```
[`a]) Tonausgabe (Beep
```
```
[` b] Backspace
[`f] Form Feed (für Drucker)
```
```
[` n] New Line
```
```
[`r] Carriage Return
```
```
[`r` n] Carriage Return und New Line
```
```
[`t] Tabulator
```
Ein Beispiel für den Einsatz zeigt das folgende Skript.


```
Listing 7.10 Nutzung von New Line und Tabulator
$Name = "Holger Schwichtenberg"
$Status 1 = "OK"
$Status 2 = "3 Fehler in den letzten 24 Stundnen"
$Begruessung = "Guten Tag, Herr $Name,`nder aktuelle Systemstatus ist:
`nServer 1 `t`t$Status 1 `nServer 2 `t`t$Status2."
Write-Host $Begruessung -ForegroundColor Yellow
```
Bild 7.8 Ausgabe des obigen Listings

```
ACHTUNG: Sonderzeichen werden nicht ausgewertet, wenn die
Zeichenkette in einfachen Anführungszeichen steht!
```
7.7.7 Bearbeitungsmöglichkeiten für Zeichenketten

Für Zeichenketten in der PowerShell stehen alle Bearbeitungsmöglichkeiten der
Klasse System.String in der PowerShell zur Verfügung.

Folgende Methoden stehen zur Verfügung:

```
Clone()
CompareTo()
Contains()
CopyTo()
EndsWith()
Equals()
IndexOf()
```

IndexOfAny()

Insert()

LastIndexOf()

LastIndexOfAny()

Length()

PadLeft()

PadRight()

Remove()

Replace(), ähnlich dem PowerShell-Operator -replace

Split(), ähnlich dem PowerShell-Operator -split

StartsWith()

Substring()

ToCharArray()

ToLower()

ToLowerInvariant()

ToString()

ToUpper()

ToUpperInvariant()

Trim()

TrimEnd()

TrimStart()


Bild 7.9 Methoden der Klasse System.String

Beispiel

Das nächste Beispiel zeigt folgende Zeichenkettenoperationen:

```
Umwandlung in Großbuchstaben
Einfügen eines Textes
```

Extrahieren eines Textteils als einzelne Zeichen mit Range-Operator

Extrahieren eines Textteils als Zeichenkette mit Range-Operator und Join-
Operator

Extrahieren eines Textteils als Zeichenkette mit Substring()-Methode

```
HINWEIS: Zu beachten ist, dass beim Range-Operator .. als erste Zahl die
Startposition (beginnend bei 0) und als zweite Zahl die Endposition
(ebenfalls beginnend bei 0) anzugeben ist. Auch bei der Methode
Substring() muss als erster Parameter die Startposition (beginnend bei 0)
angegeben werden, als zweite jedoch die Anzahl der Zeichen.
```
Listing 7.11 Beispiel für die Veränderung von Zeichenketten
[1_Basiswissen/PowerShellLanguage/strings.ps1]

```
# Umwandlung in Großbuchstaben
$a = "Dr. Schwichtenberg"
$b.ToUpper()
$b
```
```
# Einfügen eines Textes
$a = $a.Insert(4, "Holger ")
$a
```
```
# Extrahieren eines Textteils via Range-Operator in Einzelbuchstaben
$c = $a[4..9]
$c
```
```
# Extrahieren eines Textteils via Range-Operator + Join als Zeichenkette
$c = $a[4..9] - join ''
$c
```
```
# Extrahieren eines Textteils als Zeichenkette
$c = $a.Substring(4,6) # 6 ist die Anzahl
$c
```

Bild 7.10 Ausgabe des obigen Skripts

```
TIPP: Neben der Möglichkeit, Zeichenketten mit ToUpper() bzw. ToLower()
komplett in Groß- bzw. Kleinbuchstaben zu versetzen, bietet die .NET-
Klassenbibliothek in der Klasse System.Globalization.TextInfo noch die
Methode ToTitleCase() an, die die angegebene Zeichenfolge in große
Anfangsbuchstaben verwandelt, d. h., jedes neue Wort wird in
Großbuchstaben geschrieben. Bestehende Großbuchstaben bleiben
unangetastet. Zu beachten ist, dass man TextInfo nicht direkt nutzen
kann, sondern von dem Commandlet Get-Culture bekommt.
(Get-Culture).TextInfo.ToTitleCase("DR. holger schwichtenberg")
#Ergebnis: DR. Holger Schwichtenberg
```
7.7.8 Zeichenketten ersetzen

Zum Ersetzen von Teilen von Zeichenketten gibt es in PowerShell zwei
Möglichkeiten:

1. Aufruf der Methode Replace() auf einem String-Objekt
2. Verwendung des PowerShell-Operators -replace


```
TIPP: Replace() und -replace sind nicht exakt übereinstimmend in Ihrer
Funktion:
Während die Übersetzung bei -replace nicht case-sensitive ist, ist bei
Replace() die Groß-/Kleinschreibung relevant.
Während -replace auch reguläre Ausdrücke akzeptiert, ist dies bei
Replace() nicht möglich.
```
Das folgende Listing zeigt ein Beispiel mit den unterschiedlichen Ergebnissen.

```
Listing 7.12 Replace() versus -replace
[1_Basiswissen\PowerShellLanguage\Strings.ps1]
"Thomas Müller" - replace "ü","ue" #Ergebnis: Thomas Mueller
"Thomas Müller".replace("ü","ue") #Ergebnis: Thomas Mueller
```
```
"Thomas Özil" - replace "ö","oe" #Ergebnis: Thomas oezil (-replace ist ni
cht case
sensitive)
"Thomas Özil".replace("ö","oe") #Ergebnis: Thomas Özil (replace() ist ca
se sensitive)
```
```
"Thomas Özil" - replace "\bö","oe" #Ergebnis: Thomas oezil (-replace akze
ptiert RA)
"Thomas Özil".replace("\bö","oe") #Ergebnis: Thomas Özil (replace() akze
ptiert nicht RA)
```
7.7.9 Zeichenketten trennen und verbinden

Manchmal muss man eine Zeichenkette trennen, z. B.:

```
"Holger;Schwichtenberg;Essen;Germany;www.IT-Visions.de"
```
Das .NET Framework stellt dazu die Methode Split() in der Klasse System.String
bereit.


```
Listing 7.13 Einsatz der Methode Split()
[1_Basiswissen/PowerShellLanguage/Strings.ps1]
[String] $CSVString = "Holger;Schwichtenberg;Essen;Germany;www.IT-Vision
s.de"
$CSVArray = $CSVString.Split(";")
$Surname = $CSVArray[ 1 ]
$Surname
```
Alternativ kann man seit PowerShell 2.0 den eingebauten Operator -Split
verwenden. Das macht es ein wenig kürzer:

```
Listing 7.14 Einsatz des Operators -Split
[1_Basiswissen/PowerShellLanguage/Strings.ps1]
[String] $CSVString = "Holger;Schwichtenberg;Essen;Germany;www.IT-Vision
s.de"
$CSVArray = $CSVString -Split ";"
$Surname = $CSVArray[ 1 ]
$Surname
```
Zeichenketten verbinden

Das Gegenstück zum Verbinden von Zeichenketten sind die Methoden Join() und
der Operator -Join sowie das Commandlet Join-String (ab PowerShell 6).

Bei Join() ist zu beachten, dass dies eine statische Methode der Klasse
System.String ist.

```
Listing 7.15 Einsatz der statischen Methode Join()
[1_Basiswissen/PowerShellLanguage/Strings.ps1]
$Array = "Holger", "Schwichtenberg", "Essen", "Germany", "www.IT-Vision
s.de"
$CSVString = [System.String]::Join(";", $Array)
$CSVString
```

```
Listing 7.16 Einsatz des Operators -Join
[1_Basiswissen/PowerShellLanguage/Strings.ps1]
$Array = "Holger", "Schwichtenberg", "Essen", "Germany", "www.IT-Vision
s.de"
$CSVString = $Array -Join ";"
$CSVString
```
```
Listing 7.17 Einsatz des Commandlets Join-String
[1_Basiswissen/PowerShellLanguage/Strings.ps1]
$Array = "Holger", "Schwichtenberg", "Essen", "Germany", "www.IT-Vision
s.de"
$CSVString = $Array | Join-String -Separator ";"
$CSVString
```
Weiteres Beispiel

Es folgt ein weiteres Beispiel zum Einsatz von -Split und -Join.

```
Listing 7.18 Beispiele zum Einsatz der Operatoren -split und -join
$CSV = "www.powershell-doktor.de;Dr. Holger Schwichtenberg;Essen"
```
```
$Einzelwerte = $CSV -split ";"
$Name = $Einzelwerte[ 1 ]
$Name # liefert "Dr. Holger Schwichtenberg"
```
```
$Einzelwerte = $Einzelwerte | Sort-Object
$AlleWerteGetrenntDurchKomma = $Einzelwerte -join ","
$AlleWerteGetrenntDurchKomma # liefert "Dr. Holger Schwichtenberg,Essen,
http://www.powershell-doktor.de"
```
7.8 Reguläre Ausdrücke

Das Microso .NET Framework (inklusive .NET Core) und die PowerShell
enthalten eine gute Unterstützung für Mustererkennung in Texten durch reguläre


Ausdrücke. Reguläre Ausdrücke sind eine komplexe Sprache, die nicht originär
der PowerShell entstammt und die hier nicht vollständig beschrieben werden
kann. Dazu gibt es komplette Bücher. Sie finden eine gute Dokumentation dazu
auch im WWW unter https://docs.microso.com/de-de/dotnet/standard/base-
types/regular-expressions.

Ein regulärer Ausdruck ist eine Zeichenkette, die mit Platzhaltern ein Muster
beschreibt. Man kann nach dieser Musterdefinition eine Zeichenkette mit dem
Muster vergleichen und erhält als Ergebnis, ob die Zeichenkette auf das Muster
passt. Dabei kann das Muster auch auf einen Teil der Zeichenkette zutreffen. Mit
regulären Ausdrücken kann man auch Teile von Zeichenketten durch andere
Zeichenketten ersetzen (Austauschfunktion).

7.8.1 Mustervergleichsoperatoren

In der PowerShell prü man mit folgenden Operatoren auf ein Muster:

```
Mustervergleich ohne Unterscheidung zwischen Groß- und Kleinschri: -
match und -imatch
Mustervergleich mit Unterscheidung zwischen Groß- und Kleinschri: -
cmatch
Prüfung, ob ein Muster NICHT enthalten ist, ohne Unterscheidung zwischen
Groß- und Kleinschri: - notmatch und -inotmatch
Prüfung, ob ein Muster NICHT enthalten ist, mit Unterscheidung zwischen
Groß- und Kleinschri: - cnotmatch
```
Die Anwendung sieht so aus:

```
$Ergebnis = $Zeichenkette -match $Muster
```
Das Ergebnis ist $true oder $false.

Beispiel: Prüfung einer E-Mail-Adresse

Ein erstes Beispiel dient der Verdeutlichung. Geprü werden soll, ob die
eingegebenen Zeichenketten den Aufbau einer E-Mail-Adresse haben. Die
Zeichenketten werden in diesem Fall im Quellcode des Skripts hinterlegt. Die


Entgegennahme der Eingabe mit Read-Host wird im Kapitel "Benutzereingaben"
später behandelt.

```
Listing 7.19 RegEx.ps 1
"Bitte geben Sie eine E-Mail-Adresse ein:"
$Muster = "^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$"
#$Muster = "[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]
+)
*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?"
$Eingabe 1 = "buero@IT-Visions.de"
$Eingabe 2 = "buero@IT-Visionsde"
```
```
$Ergebnis 1 = $Eingabe 1 - match $Muster
$Ergebnis 2 = $Eingabe 2 - match $Muster
"Auswertung: { 0 } ist eine E-Mail-Adresse: { 1 }" - f $Eingabe1, $Ergebnis 1
"Auswertung: { 0 } ist eine E-Mail-Adresse: { 1 }" - f $Eingabe2, $Ergebnis 2
```
Die Ausgabe sieht so aus:

```
Auswertung: buero@IT-Visions.de ist eine E-Mail-Adresse: True
Auswertung: hsIT-Visionsde ist eine E-Mail-Adresse: False
```
Die Interpretation von "^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,6}$" sieht so aus:

```
^ steht für den Anfang und $ für das Ende der Zeichenkette.
Eine eckige Klammer beschreibt eine Menge von Zeichen, wobei Platzhalter
erlaubt sind, also A-Z steht für A, B, C, D usw. bis Z. [A-Z0-9._%+-] umfasst
alle Buchstaben, alle Zahlen sowie die Sonderzeichen Punkt, Unterstrich,
Prozentzeichen, Plus und Minus. Wichtig ist, dass eine eckige Klammer nicht
für eine Zeichenfolge steht, sondern nur für ein einzelnes Zeichen. Es darf
also nur ein Zeichen aus der Liste vorkommen.
Ein "+" außerhalb von eckigen Klammern steht für "ein oder mehrmalige
Wiederholung" und bezieht sich auf die eckige Klammer davor.
"@" ist ein Literal. Es steht tatsächlich für den "Klammeraffen".
[A-Z0-9.-]+ beschreibt die Second-Level-Domäne und bedeutet dann also
mindestens einmaliges Vorkommen eines der Zeichen aus der Liste in
eckigen Klammern.
```

```
\. steht für einen Punkt, der vorkommen muss. "\" ist das "Escape"-Zeichen.
Ein Punkt in regulären Ausdrücken steht eigentlich für "beliebiges Zeichen".
In diesem Fall geht es aber darum, dass wirklich nur ein Punkt vorkommen
darf, daher \.
[A-Z]{2,6} beschreibt die Top-Level-Domäne. Diese besteht nur aus
Buchstaben (daher: [A-Z]) und ist immer mindestens zwei Zeichen lang. Es
gibt aber auch längere Top-Level-Domänen (z. B. "museum"). Hier wird
erlaubt, dass die Top-Level-Domäne zwischen zwei und sechs Zeichen lang
ist.
```
```
HINWEIS: Der oben genannte reguläre Ausdruck ist noch nicht perfekt,
denn er tri auch auf Fälle zu, in denen die E-Mail-Adresse unsinnig ist, z.
B. abc@abc.unsinn. Es gibt hier zahlreiche Möglichkeiten, genauer zu
prüfen, z. B. ^[a-z0-9!#$%&‚*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?
^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+(?:[A-Z]{2}|com|
org|net|gov|mil|biz|info|mobi|name|aero|jo bs|museum)$.
Dieser Ausdruck ist aber schwerer verständlich.
```
7.8.2 Allgemeiner Aufbau von regulären Ausdrücken

Reguläre Ausdrücke sind Zeichenketten, in denen sowohl übliche Buchstaben als
auch viele Sonderzeichen zur Musterbeschreibung eingesetzt werden. Allgemein
besteht ein regulärer Ausdruck aus fünf Arten von Musterelementen:

```
Zeichenklasse: zum Beispiel Buchstaben oder Zahlen
Quantifizierer (alias Quantoren): beschreibt, wie o sich eine Zeichenklasse
wiederholen muss oder darf, z. B. dreimal oder beliebig o oder zwischen
zwei- und sechsmal
Ankerelemente (Positionselemente): z. B. Anfang und Ende einer
Zeichenkette
Runde Klammern: dienen der Gruppierung von Elementen
Das Escape-Zeichen "\", das einem Sonderzeichen wieder zu seiner
ursprünglichen Bedeutung verhil, z. B. "\." oder "\$"
```

Die Elemente der Sprache für reguläre Ausdrücke

Die folgenden Tabellen geben die wichtigsten Sprachelemente für reguläre
Ausdrücke wieder.


Tabelle 7.3 Zeichenklassen. Quelle: Diese Tabelle ist der .NET API-Dokumentation entnommen
[https://docs.microso.com/de-de/dotnet/standard/base-types/character-classes-in-regular-expressions]

```
Zeichenklasse Erläuterung
```
```
[character_group] (Positive Zeichengruppe) Entspricht einem
beliebigen Zeichen in der angegebenen
Zeichengruppe.
Die Zeichengruppe besteht aus einem oder
mehreren Literalzeichen, Escapezeichen,
Zeichenbereichen oder Zeichenklassen, die
miteinander verkettet sind.
Zur Angabe aller Vokale verwenden Sie z. B.
[aeiou]. Wenn Sie die gesamte Interpunktion
und alle Dezimalziffern angeben möchten,
codieren Sie [\p{P}\d].
```
```
[^character_group] (Negative Zeichengruppe) Entspricht einem
beliebigen Zeichen, das sich nicht in der
angegebenen Zeichengruppe befindet.
Die Zeichengruppe besteht aus einem oder
mehreren Literalzeichen, Escapezeichen,
Zeichenbereichen oder Zeichenklassen, die
miteinander verkettet sind. Das führende
Zirkumflexzeichen (^) ist obligatorisch und gibt
an, dass es sich bei der Zeichengruppe um eine
negative und nicht um eine positive
Zeichengruppe handelt.
Zur Angabe aller Zeichen mit Ausnahme von
Vokalen verwenden Sie z. B. [^aeiou]. Wenn Sie
alle Zeichen außer Interpunktion und
Dezimalziffern angeben möchten, verwenden
Sie [^\p{P}\d].
```
```
[firstCharacterlastCharacter] (Zeichenbereich) Entspricht einem beliebigen
Zeichen in einem Zeichenbereich.
Ein Zeichenbereich ist eine Folge
zusammenhängender Zeichen, die definiert
wird, indem das erste Zeichen in der Folge, ein
Bindestrich (-) und das letzte Zeichen in der
```

```
Folge angegeben werden. Zwei Zeichen sind
zusammenhängend, wenn sie benachbarte
Unicode-Codepunkte haben. Es können zwei
oder mehr Zeichenbereiche miteinander
verkettet werden.
Wenn Sie beispielsweise den Bereich der
Dezimalziffern von ‚0' bis ‚9', den Bereich der
Kleinbuchstaben von ‚a' bis ‚f' und den Bereich
der Großbuchstaben von ‚A' bis ‚F' angeben
möchten, verwenden Sie [0-9a-fA-F].
```
. (Punkt) Entspricht allen Zeichen mit Ausnahme
    von \n. Bei Modifikation durch die Singleline-
    Option entspricht ein Punkt einem beliebigen
    Zeichen.
    Beachten Sie, dass ein Punkt in einer positiven
    oder negativen Zeichengruppe (Punkt in
    eckigen Klammern) als Literalzeichen und nicht
    als Zeichenklasse behandelt wird.

\p{name} Entspricht einem beliebigen Zeichen in der
allgemeinen Unicode-Kategorie oder einem
durch name angegebenen benannten Block (z. B.
Ll, Nd, Z, IsGreek und IsBoxDrawing).

\P{name} Entspricht einem beliebigen Zeichen, das sich
nicht in der allgemeinen Unicode-Kategorie
oder einem in name angegebenen benannten
Block befindet.

\w Entspricht einem beliebigen Wortzeichen.
Entspricht den allgemeinen Unicode-Kategorien
[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}].
Wenn mit der ECMAScript-Option ECMAScript-
konformes Verhalten angegeben wurde, ist \w
gleichbedeutend mit [a-zA-Z_0-9].

\W Entspricht einem beliebigen Nichtwortzeichen.
Entspricht den allgemeinen Unicode-Kategorien
[^\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\


```
p{Lm}]. Wenn mit der ECMAScript-Option
ECMAScript-konformes Verhalten angegeben
wurde, ist \W gleichbedeutend mit [^a-zA-Z_0-
9 ].
```
\s Entspricht einem beliebigen Leerraumzeichen.
Entspricht den Escapesequenzen und den
allgemeinen Unicode-Kategorien
[\f\n\r\t\v\x 85 \p{Z}]. Wenn mit der
ECMAScript-Option ECMAScript-konformes
Verhalten angegeben wurde, ist \s
gleichbedeutend mit [ \f\n\r\t\v].

\S Entspricht einem beliebigen Nicht-
Leerraumzeichen. Entspricht den
Escapesequenzen und den allgemeinen
Unicode-Kategorien [^\f\n\r\t\v\x 85 \ p{Z}].
Wenn mit der ECMAScript-Option ECMAScript-
konformes Verhalten angegeben wurde, ist \S
gleichbedeutend mit [^ \f\n\r\t\v].

\d Entspricht einer beliebigen Dezimalziffer.
Entspricht \p{Nd} für Unicode und [0-9] für
Nicht-Unicode mit ECMAScript-Verhalten.

\D Entspricht einer beliebigen Nichtziffer.
Entspricht \P{Nd} für Unicode und [^0-9] für
Nicht-Unicode mit ECMAScript-Verhalten.


Tabelle 7.4 Quantifizierer. Quelle: Diese Tabelle ist der .NET API-Dokumentation entnommen
[https://docs.microso.com/de-de/dotnet/standard/base-types/character-classes-in-regular-expressions]

```
Quantifizierer Erläuterung
```
```
* Stimmt mit dem vorangehenden Element nicht oder
mehrmals überein. Ist äquivalent zu {0,}. * ist ein gieriger
Quantifizierer, dessen nicht gieriges Äquivalent *? ist.
Der reguläre Ausdruck \b91*9*\b sucht beispielsweise nach
Entsprechungen der Ziffer 9 , die auf eine Wortgrenze folgen.
Auf die 9 können keine oder mehrere Instanzen der Ziffer 1
folgen, auf die ihrerseits keine oder mehrere Instanzen der
Ziffer 9 folgen können.
```
```
+ Stimmt mit dem vorangehenden Element mindestens einmal
überein. Ist äquivalent zu {1,}. + ist ein gieriger Quantifizierer,
dessen nicht gieriges Äquivalent +? ist.
Der reguläre Ausdruck \ba(n)+\w*?\b sucht beispielsweise
nach ganzen Wörtern, die mit dem Buchstaben a beginnen,
auf den mindestens eine Instanz des Buchstabens n folgt.
```
```
? Stimmt mit dem vorangehenden Element nicht oder einmal
überein. Ist äquivalent zu {0,1}.? ist ein gieriger
Quantifizierer, dessen nicht gieriges Äquivalent ?? ist.
Der reguläre Ausdruck \ban?\b sucht beispielsweise nach
ganzen Wörtern, die mit dem Buchstaben a beginnen, auf
den keine oder eine Instanz des Buchstabens n folgt. Er sucht
also nach den Wörtern a und an.
```
```
{n} Stimmt mit dem vorangehenden Element genau n-mal
überein. {n} ist ein gieriger Quantifizierer, dessen nicht
gieriges Äquivalent {n}? ist.
Der reguläre Ausdruck \b\d+\,\d{3}\b sucht beispielsweise
nach Übereinstimmungen einer Wortgrenze, auf die
mindestens eine Dezimalziffer, drei Dezimalziffern und eine
weitere Wortgrenze folgen.
```
```
{n,} Stimmt mit dem vorangehenden Element mindestens n-mal
überein. {n,} ist ein gieriger Quantifizierer, dessen nicht
gieriges Äquivalent {n}? ist.
```

```
Der reguläre Ausdruck \b\d{2,}\b\D+ sucht beispielsweise
nach Übereinstimmungen einer Wortgrenze, auf die
mindestens zwei Ziffern, eine Wortgrenze und ein weiteres
Zeichen folgen, bei dem es sich nicht um eine Ziffer handelt.
```
{n,m} Stimmt mit dem vorangehenden Element mindestens n-mal,
jedoch nicht mehr als m-mal überein. {n,m} ist ein gieriger
Quantifizierer, dessen nicht gieriges Äquivalent {n,m}? ist.
Der reguläre Ausdruck (00\s){2,4} sucht beispielsweise nach
zwei bis vier Vorkommen zweier 0-Ziffern, auf die ein
Leerzeichen folgt.

*? Stimmt mit dem vorangehenden Element nicht oder
mehrmals, jedoch so wenige Male wie möglich überein. Dies
ist ein träger Quantifizierer, der das Gegenstück zum gierigen
Quantifizierer * darstellt.
Der reguläre Ausdruck \b\w*?oo\w*?\b sucht beispielsweise
alle Wörter, die die Zeichenfolge oo enthalten.

+? Stimmt mit dem vorangehenden Element einmal oder
mehrmals, jedoch so wenige Male wie möglich überein. Dies
ist ein träger Quantifizierer, der das Gegenstück zum gierigen
Quantifizierer + darstellt.
Der reguläre Ausdruck \b\w+?\b sucht beispielsweise ein
oder mehrere durch Wortgrenzen getrennte Zeichen..

?? Stimmt mit dem vorangehenden Element nicht oder
mehrmals, jedoch so wenige Male wie möglich überein. Dies
ist ein träger Quantifizierer, der das Gegenstück zum gierigen
Quantifizierer? darstellt.
Beispielsweise sucht der reguläre Ausdruck ^(\s)*(System.)??
Console. Write(Line)??\(?? nach Übereinstimmungen mit den
Zeichenfolgen Console. Write oder Console.WriteLine. Die
Zeichenfolge kann auch System. vor Console enthalten und
eine öffnende Klammer kann auf sie folgen. Die Zeichenfolge
muss am Anfang einer Zeile stehen, ihr kann jedoch ein
Leerzeichen vorangehen.

{n}? Stimmt genau n-mal mit dem vorangehenden Element
überein. Dies ist ein träger Quantifizierer, der das Gegenstück


```
zum gierigen Quantifizierer {n}+ darstellt.
Der reguläre Ausdruck \b(\w{3,}?\.){2}?\w{3,}?\b sucht
beispielsweise nach genau zwei Sätzen von Zeichen, auf die
ein Punkt an einer Wortgrenze folgt. Auf diesen folgen dann
ein weiterer Satz von Zeichen und eine Wortgrenze. Dieser
reguläre Ausdruck soll eine Website-Adresse identifizieren.
```
{n,}? Stimmt mit dem vorangehenden Element mindestens n-mal,
jedoch so wenige Male wie möglich überein. Dies ist ein
träger Quantifizierer, der das Gegenstück zum gierigen
Quantifizierer {n,} darstellt.
Beachten Sie zur Veranschaulichung das Beispiel für den {n}?

- Quantifizierer. Der reguläre Ausdruck in diesem Beispiel
verwendet den {n,}-Quantifizierer, um nach einer
Zeichenfolge zu suchen, die mindestens drei Zeichen enthält,
auf die ein Punkt folgt.

{n,m}? Stimmt mit dem vorangehenden Element n-mal bis m-mal,
jedoch so wenige Male wie möglich, überein. Dies ist ein
träger Quantifizierer, der das Gegenstück zum gierigen
Quantifizierer {n,m} darstellt.
Der reguläre Ausdruck \b[A-Z](\w*?\s*?){1,10}[.!?] sucht
beispielsweise nach Sätzen, die zwischen einem und zehn
Wörtern enthalten. Er sucht nach einer Wortgrenze gefolgt
von einem Großbuchstaben, auf den ein bis zehn
Wiederholungen von keinen oder mehreren Wortzeichen und
optional ein Leerzeichen folgen. Die Übereinstimmung wird
dann von einem Punkt, einem Ausrufezeichen oder einem
Fragezeichen beendet.


Tabelle 7.5 Wichtige Ankerelemente für reguläre Ausdrücke

```
Sonstige Zeichen Erläuterung
^ Anfang der Zeichenfolge
```
```
$ Ende der Zeichenfolge
```
```
\b Ende eines Worts
```
```
\Z Satzende
```
Beispiele

Die folgende Tabelle nennt noch weitere Beispiele für reguläre Ausdrücke.

```
Beispiel Bedeutung
```
```
\{[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F] {4}-[0-
9|a-f|A-F]{12}\}
```
```
GUID (Global
Unique
Identifier)
```
```
(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4] [0-9]|[01]?
[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9] [0-9]?)\.(25[0-5]|2[0-
4][0-9]|[01]?[0-9][0-9]?)
```
```
IP-Adresse
```
```
href\s*=\s*(?:""(?< 1 >[^""]*)""|(?< 1 >\S+)) HREF=-
Parameter in
HTML-Seiten
```
Es gibt im Internet Websites, die reguläre Ausdrücke zur Wiederverwendung
sammeln, z. B. [http://www.regexlib.com/](http://www.regexlib.com/) und [http://www.regular-expressions.info/.](http://www.regular-expressions.info/.)

7.9 Datum und Uhrzeit

Das Commandlet Get-Date liefert eine Instanz der .NET-Klasse System.DateTime,
die das aktuelle Datum und die aktuelle Uhrzeit enthält.


```
Get-Date
```
Die Anzeige reduziert man wie folgt auf das Datum:

```
Get-Date -displayhint date
```
Die Anzeige reduziert man so auf die Zeit:

```
Get-Date -displayhint time
```
Get-Date kann auch dazu genutzt werden, ein spezielles Datum zu erzeugen und
dieses in einer Variablen zu speichern, z. B. der 6.12.2020 12:11:10 Uhr:

```
$a = Get-Date "12/ 6 / 2020 12:11:10"
```
Die Differenz zwischen dem aktuellen Datum und einem in einer Variablen
gespeicherten Datum errechnet man durch den Aufruf der Methode Subtract():

```
(Get-Date).Subtract((Get-Date "12/ 6 / 2020 12:11:10"))
```
oder durch die einfache Verwendung des Minuszeichens:

```
(Get-Date) - (Get-Date "12/ 6 / 2020 12:11:10")
```
Dies führt am 14.1.2020 21:57 Uhr zu folgender Ausgabe (negative Zahlen,
bedeuten, dass das Datum in der Zukun liegt):

```
Days : -149
Hours : -14
Minutes : -14
Seconds : -21
Milliseconds : -659
Ticks : -129248616590217
TotalDays : -149,593306238677
TotalHours : -3590,23934972825
TotalMinutes : -215414,360983695
TotalSeconds : -12924861,6590217
TotalMilliseconds : -12924861659,0217
```

Timespan

Intern verarbeitet die PowerShell Zeiträume als Instanzen der Klasse System.
TimeSpan. Man kann auch selbst Zeiträume mit dem Commandlet New-TimeSpan
anlegen und mit diesen rechnen, z. B.:

```
$Dauer = New-TimeSpan -Days 10 - hours 4 - minutes 3 - seconds 50
$jetzt = Get-Date
$zukunft = $jetzt + $Dauer
```
```
HINWEIS: Bei New-TimeSpan kann man die Dauer nur in Tagen, Stunden,
Minuten und Sekunden angeben. Eine Angabe in Monaten oder Jahren ist
nicht möglich.
```
Uhrzeit setzen

Die aktuelle lokale Systemzeit kann man mit Set-Date setzen.

Entfernte Zeit

Die Zeit von einem entfernten System kann man nicht mit dem Commandlet Get-
Date abfragen, sondern nur unter Zuhilfenahme der WMI-Klasse
Win32_Currenttime.

```
Get-CimInstance Win32_Currenttime -computername D 142
```
Das Ergebnis der Operation ist dann aber kein .NET-Objekt vom Typ System.
DateTime, sondern ein .NET-Objekt vom Typ System.Management.ManagementObject,
das ein WMI-Objekt vom Typ root\cimv 2 \Win32_LocalTime enthält.

7.10 Objekte


In .NET sind alle Werte, auch primitive Werte wie Zahlen (byte, int, long, decimal
etc.), Zeichenketten (string) und Datumsangaben (datetime), Objekte im Sinne
der objektorientierten Programmierung, also mit Eigenschaen (Properties),
Methoden (Methods) und Ereignissen (Events). Dies gilt also auch für die
PowerShell.

Jede Variable in PowerShell enthält also ein Objekt. Eigenschaen (Properties),
Methoden (Methods) und Ereignisse (Events) trennt man über den Punkt-
Operator (.) ab. Seit Power-Shell 7.0 ist auch der Null Conditional Operator (?.)
möglich.

Neben der Instanziierung von .NET-Klassen gibt es in der PowerShell weitere
Möglichkeiten, .NET-Objekte zu erhalten, die in diesem Buch bereits besprochen
wurden:

```
Von Commandlets wie Get-Process oder Get-Service
Von eingebauten Variablen wie $host oder $psversiontable
Von Literaten wie "Holger Schwichtenberg"
Durch Erstellung dynamischer Objekte (siehe Kapitel "Dynamische Objekte")
Durch Instanziierung von PowerShell-Klassen (siehe Kapitel
"Objektorientiertes Programmieren mit Klassen")
Von statischen .NET-Klassen (siehe Kapitel "Verwendung von .NET-Klassen")
Durch Instanziierung von .NET-Klassen (siehe Kapitel "Verwendung von .NET-
Klassen")
Durch Instanziierung von COM-Klassen (siehe Kapitel "Verwendung von COM-
Klassen")
# Objekte von eingebauten Variablen
$host.Name
$host.ui.RawUI.WindowTitle = "Meine PowerShell"
```
```
# Objekte von Commandlets
(Get-Process)[ 0 ].Name
(Get-Process | Where-Object { $_.Name -like "Chrome" }).Kill()
(Get-Service)[ 1 ].Status
```
```
# Objekte von Literalen
"Holger Schwichtenberg".ToUpper()
```

7.11 Arrays

Arrays sind Mengen von Variablen, die eine frei wählbare Anzahl von Werten
aufnehmen können.

7.11.1 Deklaration

Ein Array deklariert man durch die Zuweisung einer durch Kommata getrennten
Wertemenge:

```
$a = 01,08,72,13,04,76
```
Das Array kann auch explizit mit [array] deklariert werden:

```
[array] $b
$b = 01,08,72,13,04,76
```
```
TIPP: Eine Zahlenreihe kann man auch mit zwei Punkten abkürzen: $b =
1..10 ist gleichbedeutend mit $b = 1,2,3,4,5,7,8,9,10.
```
7.11.2 Arrayoperationen

Um auf die Elemente zuzugreifen, hat man drei Möglichkeiten:

```
Zugriff auf ein einzelnes Element mit dem Index in eckigen Klammern (bei 0
beginnend), z. B. ist $b[ 3 ] das vierte Element.
Zugriff auf mehrere Elemente, hier wird der Index durch ein Komma getrennt,
z. B. bedeutet $b[1,3,5] das zweite, vierte und sechste Element.
Zugriff auf einen Indexbereich. Der Indexbereich ist durch zwei Punkte zu
trennen, z. B. $a[1..5]. Dies bedeutet das zweite bis sechste Element.
Zugriff auf das letzte Element erhält man mit $a[-1].
```

Der Operator += ergänzt ein Element am Ende eines Arrays (siehe folgende
Abbildung). Das Entfernen von Elementen ist nicht möglich (nur das Umkopieren
in ein anderes Array).

Bild 7.11 Arbeit mit Arrays

Ein leeres Array definiert man mit dem Ausdruck @( ). Zwischen den Klammern
ist kein Leerzeichen notwendig; dies ist hier nur zur besseren Lesbarkeit
abgedruckt.

```
# leeres Array ohne Elemente
$a = @()
# Elemente hinzufügen
$a += 45
$a += 14
$a += 9
# Anzahl
$a.Count
```

Möchte man ein Array mit nur einem Element definieren, muss man die Liste mit
einem Komma beginnen oder das Array explizit deklarieren:

```
$a = ,"Nur ein Element"
[Array] $a = "Nur ein Element"
```
Ein leeres Array oder ein Array mit nur einem Element kann man auch definieren,
indem man den Typadapter (Type Accelerator) [Array] verwendet.

```
# leeres Array ohne Elemente
[Array] $aLeer
$aLeer.Count
```
```
# leeres Array mit einem Element
[Array] $aEins = "eins"
$aEins.Count
```

```
TIPP: Die Tatsache, dass der Operator += sowohl für Zeichenketten und
Zahlen als auch Arrays implementiert ist, führt leicht zu Fehlern. In dem
folgenden Beispiel ist nur $a als Array deklariert und daher nimmt es die
drei Zahlen als einzelne Objekte in die Pipeline auf. $b ist nicht explizit
deklariert; die PowerShell addiert die Zahlen. Im Fall von $c werden die
Zahlen zu einer einzigen Zeichenkette zusammengefügt.
$a = @()
$a += 45
$a += 25
$a += 7
$a # Ergebnis: 45,25,7
```
```
$b += 45
$b += 25
$b += 7
$b # Ergebnis: 77
```
```
$c += "45"
$c += "25"
$c += "7"
$c # Ergebnis: 45257
```
7.11.3 Array auflisten

Zum Auflisten eines Arrays ist Foreach-Object nicht zwingend notwendig. Wenn
ein Array am Ende der Pipeline steht, wird das Array ausgegeben (siehe Abbildung
7.10). Das Attribut Count liefert die Anzahl der Elemente im Array.

```
[array] $b
$b = 1,2,3
$b.Count
```

7.11.4 Arrays verbinden

Zwei Arrays kann man durch den Plus-Operator verbinden:

```
$DomainControllers = "D141", "D142", "D143"
$MemberServers = "D144", "D145", "D146"
$AllServers = $DomainControllers + $MemberServers
$AllServers.Count # Ergebnis: 6!
```
7.11.5 Mehrdimensionale Arrays

Mehrdimensionale Arrays sind möglich, indem man die Elemente mit runden
Klammern zusammenfasst. In dem folgenden Beispiel entsteht ein
zweidimensionales Array. Die Elemente der ersten Dimension enthalten jeweils
Arrays mit drei Elementen. Auch hier kann man mit dem Plus-Operator die Menge
ergänzen.

```
$DomainControllers = ("D141", "192.168.1.10", "Building 1"), ("D142", "1
92.168.1.20",
"Building 2"), ("D143", "192.168.1.30", "Building 3")
"Number of Computers: " + $DomainControllers.Count
"IP Address of Computer 2: " + $DomainControllers[ 1 ][ 1 ] # 192.168.1.20
"Building of Computer 2: " + $DomainControllers[ 1 ][ 2 ] # Building 2
$DomainControllers += ("D144", "192.168.1.40", "Building 4")
"Building of Computer 4: " + $DomainControllers[ 3 ][ 2 ] # Building 4
```
7.12 ArrayList

In der .NET-Klassenbibliothek gibt es eine Klasse ArrayList, die ähnliche
Funktionen wie ein PowerShell-Array für eindimensionale Arrays bietet (siehe
folgendes Listing).


```
Listing 7.20 [1_Basiswissen\PowerShellLanguage\Arrays.ps1]
$lottozahlen = [System.Collections.ArrayList]::new()
$lottozahlen.add( 10 )
$lottozahlen.add( 21 )
$lottozahlen.add( 3 )
$lottozahlen.add( 35 )
$lottozahlen.add( 9 )
$lottozahlen.add( 19 )
```
```
$lottozahlen # Alle Elemente
$lottozahlen.Count # Anzahl der Elemente: 6
$lottozahlen[ 0 ] #erstes Element
$lottozahlen[ 5 ] #sechstes Element
$lottozahlen.sort() #sortieren
$lottozahlen # Ausgabe der sortierten Elemente
$lottozahlen.Remove( 19 ) #Entfernen des Wertes 19
$lottozahlen.RemoveAt( 0 ) #Entfernen des ersten Elements
$lottozahlen.Count # Anzahl der Elemente: 4
```
Der Vorteil von ArrayList ist, dass es bei vielen Elementen wesentlich schneller
arbeitet als das PowerShell-Array! Das folgende Listing vergleicht die
Ausführungsdauer für das Hinzufügen von 10 000 Elementen zu PowerShell-Array
und ArrayList. Beim PowerShell-Array dauert dies drei Sekunden, bei ArrayList
nur etwas mehr als eine halbe Sekunde.


```
Listing 7.21 [1_Basiswissen\PowerShellLanguage\Arrays.ps1]
"Array:"
(Measure-Command {
```
```
[array] $l 1 = @()
1..$count | % { $l 1 += $_ }
"Elemente in Array: " + $l1.Count
}).TotalSeconds # ca. 3 Sekunden
```
```
"ArrayList:"
(Measure-Command {
$l 2 = [System.Collections.ArrayList]::new()
1..$count | % { $l2.Add($_) | out-null }
"Elemente in Arraylist: " + $l2.Count
}).TotalSeconds # ca. 0.6 Sekunden
```
7.13 Assoziative Arrays (Hash-Tabellen)

Neben den Arrays unterstützt die PowerShell auch benannte (assoziative)
Elementmengen in Form sogenannter Hash-Tabellen. In einer Hash-Tabelle
werden die Elemente nicht durch die Position, sondern durch einen eindeutigen
Bezeichner identifiziert. Dieses Konzept existiert auch in anderen Sprachen und
wird dort o "assoziatives Array" genannt. Das zu Grunde liegende Basiskonzept
ist die .NET-Klasse System. Collections.Hashtable.

Bei der Definition einer Hash-Tabelle ist das @-Zeichen zu verwenden, gefolgt
von der Elementmenge in geschweien Klammern. Die einzelnen Elemente sind
durch Semikola zu trennen. Jedes Element besteht aus einem Elementnamen
und einem Elementwert, wobei Elementname und Elementwert durch ein
Gleichheitszeichen zu trennen sind. Der Elementname darf nicht in
Anführungszeichen stehen. Möchte man den Datentyp explizit angeben, ist
[Hashtable] zu verwenden.


```
# Implicit Hashtable
$Computers = @{ D 141 = "192.168.1.10"; D 142 = "192.168.1.20"; D 143 = "19
2.168.1.30";
}
```
```
# Explicit Hashtable
[Hashtable] $Computers = @{ D 141 = "192.168.1.10"; D 142 = "192.168.1.2
0"; D 143 =
"192.168.1.30"; }
```
Auf eine solche Hash-Tabelle kann man nicht nur wie bei den einfachen Arrays
über die Notation mit eckigen Klammern zugreifen, sondern auch direkt über den
Punkt-Operator. Dies macht die Arbeit mit Hash-Tabellen sehr elegant:

```
# Hole IP-Addresse des Computer "D142" aus der Hashtable
$Computers["D142"]
$Computers.D 142
```
Man kann die Elemente auch direkt beschreiben.

```
# Ein Element in der Hashtable ändern
$Computers.D 142 = "192.168.1.21"
```
Sehr komfortabel ist, dass beim Beschreiben eines bisher nicht existierenden
Elements das Element neu angelegt wird. Auf diese Weise kann man auch eine
Hash-Tabelle schrittweise anlegen, d. h. mit einer leeren Liste starten. Eine leere
Hash-Tabelle wird ausgedrückt durch @{ }.

```
# Ein Element in der Hashtable ergänzen
$Computers.D 144 = "192.168.1.40"
```
```
# Eine leere Hashtable beginnen
$MoreComputers = @{ }
$MoreComputers.D 145 = "192.168.1.50"
$MoreComputers.D 146 = "192.168.1.60"
$MoreComputers.Count # Ergebnis = 2
```
Zwei Hash-Tabellen kann man verbinden wie zwei Arrays. Dies funktioniert aber
nur, wenn in beiden Listen zusammen jeder Elementname nur einmal vorkommt.


Falls es Duplikate gibt, wird ein Fehler erzeugt und das Ergebnis ist eine leere
Menge.

```
# Zwei Hashtables verbinden
$AllComputers = $Computers + $MoreComputers
$AllComputers.Count # Ergebnis = 6
```
Hash-Tabellen kann man nicht nur für echte Listen, sondern auch zur einfachen
Definition eigener Datenstrukturen verwenden, z. B. um Informationen über eine
Person zu speichern.

```
# Verwenden einer Hashtable als Datenstruktur
$Author = @{ Name="Dr.Holger Schwichtenberg"; Age=47; Country="Deutschla
nd" }
$Author.Name
$Author.Age
$Author.Country
```
7.14 Operatoren

Dieses Kapitel liefert einen Überblick über die Operatoren in PowerShell.

7.14.1 Vergleichsoperatoren

Die Vergleichsoperatoren wurden bereits im Kapitel "Objektorientiertes
Pipelining/Filtern" vorgestellt.

7.14.2 Arithmetische Operatoren

Die PowerShell unterstützt die elementaren arithmetischen Operatoren +, -, *, /
und % (Modulo-Operation alias Divisionsrest). Das Pluszeichen verwendet man
sowohl zur Addition von Zahlen als auch zur Verkettung von Zeichenketten. Sogar
Mengen (Arrays und Hash-Tabellen) kann man verbinden. Auch der Stern [*] für
die Multiplikation hat noch andere Bedeutung: Sowohl eine Zeichenkette als


auch ein Array kann man damit multiplizieren. Dadurch werden die Zeichen bzw.
Elemente so o wiederholt wie angegeben. In der Natur einer Hash-Tabelle liegt
es, dass man die Elemente nicht vervielfachen kann, da dies zu doppelten
Elementnamen führen würde, was nicht erlaubt ist.

```
# Multiplizieren einer Zeichenkette
$String = "abcdefghijklmnopqrstuvwxyz"
$LongString = $String * 20
"Count: " + $LongString.Length # = 520
```
```
# Multiplizieren eines Arrays
$a = 1,2,3,4,5
$b = $a * 10
"Count: " + $b.Count # = 50
```
7.14.3 Zuweisungsoperator

Als Zuweisungsoperator wird das Gleichheitszeichen verwendet. Eine Zuweisung
kann zwischen einer Variablen und einer Konstanten oder zwischen zwei
Variablen erfolgen.

```
$PC 1 = "PC123"
$PC 2 = $PC 1
```
Wertkopie versus Referenzkopie

Allerdings wird mit dem Zuweisungsoperator zwischen zwei Variablen nicht
zwingend der Wert der Variablen kopiert. Es hängt von der Klasse ab. Wenn die
Klasse System.String ist oder laut Dokumentation in Microso Developer
Network (MSDN) eine "Struktur" oder von System. ValueType erbt, dann wird der
Wert kopiert.

Im folgenden Beispiel wird wie erwartet durch die Veränderung der Variablen
$PC 1 der Inhalt von $PC 2 nicht beeinflusst.


```
"---- Wertkopie"
$PC 1 = "PC123"
$PC 2 = $PC 1 # Wertkopie!
"Vorher"
$PC 1
$PC 2
```
```
"Änderung an PC1:"
$PC 1 = "PC124"
```
```
"Nachher"
$PC 1 # Ergebnis: PC 124
$PC 2 # Ergebnis: PC 123
```
Wenn die Klasse der Variablen aber nicht die o. g. Bedingungen erfüllt, dann wird
eine Referenzkopie erstellt. Im folgenden Beispiel wird unerwartet durch die
Veränderung der Variablen $P 1 der Inhalt von $P 2 auch beeinflusst. Hier hat der
Zuweisungsoperator nicht das Objekt selbst kopiert, sondern nur den Verweis
darauf!

```
"---- Referenzkopie"
$p 1 = (Get-Process)[ 0 ]
$p 2 = $p 1 # Referenzkopie
```
```
"Vorher"
$p1.Name + ": " + $p1.PriorityBoostEnabled
$p2.Name + ": " + $p2.PriorityBoostEnabled
```
```
"Änderung an p1:"
$p1.PriorityBoostEnabled = - not $p1.PriorityBoostEnabled
```
```
"Nachher"
$p1.Name + ": " + $p1.PriorityBoostEnabled
$p2.Name + ": " + $p2.PriorityBoostEnabled
```

Bild 7.12 Ein Beispiel für Wertkopie versus Referenzkopie

Bild 7.13 Wertkopie (links) versus Referenzkopie (rechts)

Kreuzzuweisungen

Interessant sind Kreuzzuweisungen, mit denen auf elegante Weise die Inhalte
zweier Variablen vertauscht werden können. Normalerweise braucht man dafür
eine Zwischenvariable. In der PowerShell kann man aber einfach schreiben: $x, $y
= $y, $x (siehe folgende Abbildung).


Bild 7.14 Kreuzzuweisung zur Variableninhaltsvertauschung in der PowerShell

7.14.4 Bit-Operatoren

Bit-Operatoren (alias binäre Operationen oder bitweise Operationen) werden
insbesondere für Zahlen benötigt, in denen einzelne Bits eine bestimmte
Bedeutung haben (Bitflags, Flag-Aufzählungstypen). Dies ist ein sehr klassisches
Vorgehen aus Zeiten, wo Speicherplatz noch rar war. In neueren
Programmierschnittstellen findet man dies nicht mehr.

Tabelle 7.6 Bit-Operatoren in PowerShell

```
Operator Beschreibung Beispiel Ergebnis
```
- band Bitweises UND (es bleiben nur die Bits auf 1
    stehen, die in beiden Operanden 1 sind

```
10 -
band 3
```
```
2
```
- bor Bitweises ODER (inklusiv)10 - bor
    3

```
11
```
- bxor Bitweises exklusives ODER (10 - bxor
    3

```
9
```
- bnot Bitweises NOT (Negation)-bNot
    10

```
-11
```
- shl Bitweise Verschiebung nach links 100 - shl
    2

```
400
```
- shr Bitweise Verschiebung nach rechts 100 - shr
    1

```
50
```

7.14.5 Aufrufoperator

Ein interessanter Operator ist auch das kaufmännische Und [&]. Damit kann man
eine Zeichenkette als einen Befehl ausführen. Dies ist eine Möglichkeit,
dynamischen und selbst modifizierenden Programmcode zu schreiben. Dazu ein
Beispiel:

```
$What = "Process"
& ("Get-"+$What)
```
Die obige Befehlsabfolge führt zur Ausführung des Commandlets Get-Process.
Nun könnte man den Inhalt der Variablen $What auch aus einer anderen Quelle, z.
B. einer Benutzereingabe, bekommen. Alternativ kann man statt des Operators &
auch das Commandlet Invoke-Expression verwenden:

```
$What = "Process"
invoke-expression("Get-"+$What)
```
```
ACHTUNG: Unbedingt zu beachten ist, dass dynamische Codeausführung
ein Sicherheitsrisiko birgt, wenn man Benutzereingaben direkt in den
Befehlen verarbeitet. Man könnte meinen, dass in dem obigen Beispiel
das Risiko beschränkt ist, weil immer der "Get"-Befehl ausgeführt wird.
$What = "Process; Get-Service"
invoke-expression("Get-"+$What)
```
7.15 Überblick über die Kontrollkonstrukte

Als Kontrollstrukturen kennt die PowerShell-Skriptsprache die folgenden
Konstrukte:

```
if (Bedingung) {...} else {...}
switch ($var) {Wert {...} Wert {...} default {..} } }
for(Initialisierung;Bedingung;Schrittweite) { ... }
```

```
while (Bedingung) { ... }
do { ... } while (Bedingung)
do { ... } until (Bedingung)
foreach ($var in $menge) {...}
function name {...}
break
continue
return
exit
trap Fehlerklasse { ... } else { ... }
throw "Fehlertext"
throw Fehlerklasse
```
```
HINWEIS: Details zu den Befehlen finden Sie in der Hilfe zur PowerShell.
Hier wird zu Gunsten anderer Inhalte auf eine detaillierte Darstellung
dieser Grundkonstrukte verzichtet – zumal ihre Funktionsweise anderen
Programmiersprachen sehr ähnlich ist. Throw und Trap werden im
Abschnitt 7.21 "Fehlerbehandlung" separat behandelt.
```
Bei Schleifen handelt es sich um Konstrukte zur wiederholten Verarbeitung eines
oder mehrerer Befehle. Wenn ein bestimmter Befehl beispielsweise fünfmal
aufgerufen werden soll, so könnte man natürlich rein theoretisch den Befehl
fünfmal nacheinander in das Skript schreiben. Der PowerShell ist das egal (sie
macht brav, was ihr befohlen wird), aber guter Stil wäre das nicht und bei einer
großen Anzahl von Wiederholungen wäre das sehr aufwendig. Und diese
Vorgehensweise versagt natürlich dann, wenn die Anzahl der Wiederholungen
nicht konstant ist, sondern sich aus dem Programmablauf variabel ergibt. Eine
Schleife dagegen kann an eine bestimmte Bedingung gebunden werden. Im Fall
einer konstanten Menge von Schleifendurchläufen setzt man den Befehl in eine
Schleife und lässt diese alle Werte zwischen einem unteren Wert (z. B. 1) und
einem oberen Wert (z. B. 5) durchlaufen. Dadurch wird der gewünschte Befehl
fünfmal aufgerufen. Allerdings sind Schleifen noch viel flexibler und es existieren
unterschiedliche Formen für verschiedene Ansprüche.


Die PowerShell kennt folgende Formen von Schleifen:

```
zählergesteuerte Schleifen,
bedingungsgesteuerte Schleifen.
```
Im einfachen Fall der zählergesteuerten Schleifen gibt es eine genau definierte
Anzahl von Durchläufen und somit wird der enthaltene Code entsprechend o
ausgeführt. Diese Form von Schleifen ist relativ einfach zu handhaben. Man
definiert einen Start- und einen Endwert. Alle Werte einschließlich der beiden
angegebenen Werte werden durchlaufen. Zusätzlich ist es möglich, eine
bestimmte Schrittweite anzugeben, z. B. eine Schrittweite von zwei. Dadurch
wird nur jeder zweite Wert der Schleife durchlaufen.

Im Gegensatz dazu gibt es Schleifen, deren Fortsetzung bzw. Abbruch von einer
ganz bestimmten Bedingung abhängig ist. Eine genaue Anzahl von Durchläufen
ist deshalb nicht von vornherein steuerbar. Eine solche Bedingung könnte
beispielsweise eine bestimmte Zahl innerhalb einer Variablen sein, z. B. "Die
Schleife wird so lange durchlaufen, bis der Inhalt der Variablen eingegebeneZahl
kleiner als 100 ist". Somit kann beispielsweise eine Benutzereingabe so lange
wiederholt werden, bis der Benutzer einen korrekten Wert eingegeben hat.

7.15.1 Die For-Schleife

Diese Schleife beginnt bei einem bestimmten Startwert und endet bei einem
Endwert. Bei jedem Durchlaufen der Schleife wird der Zähler um einen
bestimmten Wert hochgezählt, bis die gewünschte Obergrenze erreicht ist. In der
Regel wird der Zähler bei jedem Durchlauf um eins erhöht. Allerdings ist es auch
möglich, jede andere ganzzahlige Schrittweite zu verwenden.

```
for(Initialisierung;Bedingung;Schrittweite) { ... }
```
Die Konfiguration der Schleife steht in runden Klammern, die pro Durchlauf
auszuführenden Anweisungen stehen in geschweien Klammern. Im
Konfigurationsteil "Initialisierung" belegt man die Laufvariable mit einem
Anfangswert. Die Bedingung vergleicht die Laufvariable mit einem Endwert. Im
Teil "Schrittweite" wird die Laufvariable hochgezählt (oder heruntergezählt).
Jeweils eine Zahl vor oder zurück kommt man mit $i++ bzw. $i--. Andere
Schrittweiten kann man anstelle des zweiten Operators angeben. So zählt $i+= 5
um jeweils fünf hoch und $i-= 5 um fünf herunter.


Das erste Beispiel gibt die Zahlen von 1 bis 5 aus, unter Verwendung der
Laufvariablen i und einer Schrittweite von 1:

```
# Schleife von 1 bis 5
for ($i = 1; $i -lt 6; $i++) { $i }
```
Bild 7.15 Ausgabe der ersten For-Schleife

Das folgende Beispiel fragt eine Zahl ab und berechnet daraus deren Fakultät.
Dies geschieht durch eine Schleife, die von eins bis zur eingegebenen Zahl
durchlaufen wird und alle auretenden Werte dieser Schleife multipliziert.

```
Listing 7.22 Fakultätsberechnung mit einer For-Schleife
"Bitte eine Zahl eingeben:"
$Fakultaet = Read-Host
$FakultaetErgebnis = 1
for ($i = 1; $i -le $Fakultaet; $i++)
{
$FakultaetErgebnis = $FakultaetErgebnis * $i
}
"Die Fakultät von " + $Fakultaet + " ist " + $FakultaetErgebnis
```
Eine For-Schleife kann man mit der Anweisung continue vorzeitig fortsetzen und
mit break vorzeitig verlassen. Das folgende Beispiel zeigt, wie man "zu
aufwendige" Berechnungen (die hier mehr als 32-Bit-Zahlen benötigen)
unterbinden kann.


```
Listing 7.23 Fakultätsberechnung mit einer For-Schleife und vorzeitiger Abbruchbedingung
"Bitte eine Zahl eingeben:"
$Fakultaet = Read-Host
$FakultaetErgebnis = 1
$Abbruch = $false
for ($i = 1; $i -le $Fakultaet; $i++)
{
$FakultaetErgebnis = $FakultaetErgebnis * $i
if ($FakultaetErgebnis -gt [System.Int 32 ]::MaxValue) { $Abbruch = $true;
break; }
}
if ($Abbruch) { "Werteüberlauf!" }
else { "Die Fakultät von " + $Fakultaet + " ist " + $FakultaetErgebnis }
```
7.15.2 Die Do/While/Until-Schleifenfamilie

Rund um die Schlüsselwörter Do/While/Until gibt es drei Arten von Schleifen, die
jeweils über Bedingungen gesteuert werden. In Abhängigkeit davon, ob die
Bedingung erfüllt ist oder nicht, wird die Schleife abgebrochen oder fortgesetzt.

Die Bedingung kann entweder vor dem ersten Durchlauf der Befehle zum ersten
Mal ausgeführt werden (eine sogenannte kopfgesteuerte Schleife) oder nach dem
ersten Durchlauf (eine sogenannte fußgeprüe Schleife).

```
HINWEIS: Im Vergleich zur For-Schleife hat man bei der Do/While/Until-
Schleifenfamilie mehr Flexibilität.
```
Eine kopfgeprüe Schleife beginnt man mit While. Die Bedingung steht hier vor
dem Anweisungsblock, man prü also eine Bedingung vor dem ersten
Durchlaufen ab. Die Bedingung steht in runden Klammern, der Anweisungsblock
in geschweien Klammern. Die Initialisierung erfolgt vor der Schleife. Die
Schrittweite steht im Anweisungsblock.


```
Listing 7.24 Einfaches Zählen bis fünf mit der While-Schleife
"While:"
$i = 0 # Initialisierung
while($i -lt 5 ) # Bedingung
{
$i++ # Schrittweite
$i # Aktion
}
```
Bei der fußgeprüen Schleife steht die Bedingung erst am Ende. Das hat zur
Folge, dass die Schleife mindestens einmal durchlaufen wird, bevor die
Bedingung überprü wird.

Die PowerShell-Skriptsprache kennt hier zwei Varianten, die äquivalent
zueinander verwendet werden können.

```
Die Do...While-Schleife: Tue etwas, solange etwas gilt.
Die Do...Until-Schleife: Tue etwas, bis etwas gilt.
```
Das folgende Listing zeigt das Zählen von 1 bis 5 mit beiden Schleifenformen. Zu
beachten ist der Unterschied bei der Bedingung. Würde man auch bei Do...Until
statt $i -eq 5 die Bedingung $i -lt 5 schreiben, würde die Schleife schon bei
der Zahl 1 enden.

```
Listing 7.25 Einfaches Zählen bis fünf mit der Do.. .Schleife
"Do While:"
$i = 0
do
{ $i++
$i
}while($i -lt 5 )
```
```
"Do Until:"
$i = 0
do
{ $i++
$i
}until($i -eq 5 )
```

7.15.3 Die ForEach-Schleife

Die ForEach-Schleife ähnelt zwar der For-Schleife, allerdings werden bei dieser
kein Start- und Endwert benötigt. Diese Schleife verwendet man zum
Durchlaufen von Objektmengen. Für jedes Element in einer bestimmten Menge
wird die Schleife einmal durchlaufen. Bei einer solchen Menge kann es sich
beispielsweise um alle Dateien eines bestimmten Verzeichnisses handeln.
Grundsätzlich kann man jede Menge in der PowerShell mit ForEach durchlaufen.

Die ForEach-Schleife ist kaum geeignet, um damit zu zählen, denn man muss die
zu durchlaufenden Zahlen zunächst in einem Array ablegen.

```
Listing 7.26 Einfaches Zählen bis fünf mit der ForEach.. .-Schleife
# Schleife von 1 bis 5
"Foreach:"
$menge = 1,2,3,4,5
foreach ($i in $menge)
{ $i }
```
```
HINWEIS: Das obige Skript könnte man noch etwas optimieren, indem
man $menge = 1,2,3,4,5 mit $menge = 1...5 abkürzt.
```
Wirklich interessant ist die ForEach-Schleife, wenn man die Anzahl der zu
durchlaufenden Objekte zur Entwicklungszeit noch nicht kennt. Jede PowerShell-
Pipeline kann mit ForEach durchlaufen werden.

```
Listing 7.27 Durchlaufen des Pipeline-Ergebnisses mit ForEach-Schleife
$dienste = Get-Service –ComputerName F 111
foreach ($dienst in $dienste)
{
"{0,-20}: { 1 }" - f $dienst.Name , $dienst.Status
}
```
Während in C# eine Iteration über eine Menge, die auf null (in PowerShell $null)
steht, zum Laufzeitfehler führt, ist die PowerShell hier tolerant: foreach über
$null führt nicht zum Fehler! Die Schleife wird einfach ignoriert.

Zum Testen:


```
foreach($x in $null) { $x }
```
oder

```
$menge = $null
foreach($x in $menge) { $x }
```

HINWEIS: Es stellt sich die Frage, wie sich das Commandlet Foreach-
Object und die ForEach-Schleife voneinander unterscheiden. Zunächst
einmal kann man mit beiden eine jede Objektmenge durchlaufen. Die
ForEach-Schleife orientiert sich syntaktisch an den Konzepten der
prozeduralen Programmierung, während sich das Commandlet Foreach-
Object in das Pipeline-Konzept einreiht. Unter der Haube gibt es einen
wesentlichen Unterschied, den man bei größeren Objektmengen auch
bemerkt. Die Pipelines arbeiten asynchron, d. h., Foreach-Object beginnt
schon mit der Arbeit, sobald das erste Objekt vorliegt. Die ForEach-Schleife
beginnt hingegen erst, wenn alle Objekte vorliegen.

Wenn man den Pipeline-basierten Befehl

```
Get-ChildItem c:\Windows -Recurse -Filter "*.txt" |
ForEach-Object { "{0,-20}: { 1 }" - f $_.Name , $_.length }
```
mit der skriptbasierten Befehlsfolge

```
$Dateien = Get-ChildItem c:\Windows -Recurse -Filter "*.txt"
foreach ($datei in $Dateien)
{
"{0,-20}: { 1 }" - f $datei.Name , $dienst.length
}
```
vergleicht, wird man zwei Konsequenzen feststellen:

Der Pipeline-Befehl beginnt sofort mit der Ausgabe der Dateiliste. Die
skriptbasierte Lösung braucht einige Zeit vor der ersten Ausgabe.

Der Pipeline-Befehl meldet zwischen den Ausgaben Fehler über Pfade, für
die es kein Zutrittsrecht gibt. Die skriptbasierte Lösung zeigt erst alle
Fehlermeldungen, die ja von Get-ChildItem kommen, und dann erst die
Dateiausgabe, die aus der ForEach-Schleife stammt.


```
ACHTUNG: Ein Kuriosum bei der ForEach-Schleife war in PowerShell 1.0
und 2.0 zu beachten: Wenn an Stelle der zu durchlaufenden Objektmenge
$null steht, wird die Schleife dennoch einmal durchlaufen.
"Foreach über $null"
foreach ($x in $null) { "Versuch 1: $x" }
"Foreach über eine leere Menge"
$dienste = (Get-Service x*)
foreach ($x in $dienste) { "Versuch 2: $x" }
foreach ($x in (Get-Service x*)) { "Versuch 3: $x" }
```
```
In den obigen Beispielen wird die Schleife in Versuch 1 und 2 jeweils
einmal durchlaufen. Get-Service x* liefert auf den meisten Systemen kein
Ergebnis, weshalb die Variable $null erhält. Daher sind Versuch 1 und 2
aus Sicht der Schleife gleichbedeutend. In Versuch 3 wird die Schleife aber
keinmal durchlaufen, denn Get-Service x* liefert eine leere Menge und
die behandelt ForEach tatsächlich so, wie man es auch von $null erwarten
würde.
Als Verbesserung seit PowerShell-Version 3.0 wird eine Schleife nicht
mehr durchlaufen, wenn die Menge $null ist. Dies kann aber zu
überraschenden Verhaltensänderungen führen, wenn man ein
PowerShell-2.0-Skript, das diesen Seiteneffekt genutzt hat, nun in einer
neueren PowerShell laufen lässt.
```
Kein Problem für die ForEach-Schleife und das Foreach-Object-Commandlet ist
übrigens die Frage, ob die Pipeline ein einzelnes Objekt oder eine Menge enthält.
Auch im Fall des einzelnen Objekts wird die Schleife genau einmal durchlaufen.

7.16 Bedingungen

Die PowerShell-Skriptsprache beherrscht, wie fast alle anderen
Programmiersprachen auch, die bedingte Programmausführung. Von einer
bedingten Programmausführung spricht man, wenn in Abhängigkeit von
bestimmten Bedingungen nicht alle Befehle in einem Skript ausgeführt, sondern
ein oder mehrere Befehle übersprungen werden. Genau genommen heißt dies für


das Skript, dass abhängig davon, ob eine bestimmte Bedingung erfüllt ist oder
nicht, ein bestimmter Codeabschnitt verarbeitet bzw. nicht verarbeitet wird.

Innerhalb der PowerShell-Skriptsprache gibt es zwei grundsätzliche Formen für
die bedingte Programmausführung. Durch eine Fallunterscheidung wird es
ermöglicht, den Programmablauf abhängig von bestimmten Bedingungen zu
steuern:

```
if (Bedingung) {...} else {...}
switch ($var) {Wert {...} Wert {...} default {..} } }
```
7.16.1 If... Else-Bedingung

Das Basiskonstrukt für eine Bedingung ist If...Else. Die Bedingung steht in
runden Klammern, der Anweisungsblock in geschweien Klammern. Eine Else-
Anweisung ist optional.

```
ACHTUNG: Man darf weder die geschweien noch die runden Klammern
weglassen.
```
Das erste Beispiel zeigt drei einfache If-Anweisungen ohne Else.

```
Listing 7.28 Drei Bedingungen unter Einsatz von If
"Bitte geben Sie eine Zahl ein"
$Wert 1 = Read-Host
"Bitte geben Sie noch eine Zahl ein"
$Wert 2 = Read-Host
```
```
if ($Wert 1 - gt $Wert 2 ) { "Der erste Wert ist größer als der zweite." }
if ($Wert 1 - lt $Wert 2 ) { "Der erste Wert ist kleiner als der zweite." }
if ($Wert 1 - eq $Wert 2 ) { "Beide Werte sind gleich groß." }
```
Diese Bedingungen könnte man alternativ mit Else schreiben, um dann zwei If-
Bedingungen zu verschachteln.


```
Listing 7.29 Drei Bedingungen unter Einsatz von If und Else
if ($Wert 1 - gt $Wert 2 )
{ "Der erste Wert ist größer als der zweite." }
else
{
if ($Wert 1 - lt $Wert 2 ) { "Der erste Wert ist kleiner als der zweite." }
else { "Beide Werte sind gleich groß." }
}
```
Noch etwas prägnanter geht es mit ElseIf. Hinter ElseIf kann man eine weitere
Bedingung angeben.

```
Listing 7.30 Drei Bedingungen unter Einsatz von If, ElseIf und Else
if ($Wert 1 - gt $Wert 2 )
{ "Der erste Wert ist größer als der zweite." }
elseif ($Wert 1 - lt $Wert 2 )
{ "Der erste Wert ist kleiner als der zweite." }
else { "Beide Werte sind gleich groß." }
```
7.16.2 Ternärer Operator

Statt für Befehlsblöcke kann man If... Else auch für Ausdrücke als
sogenannter "Ternärer Operator" (Ternary Operator) nutzen. In dem folgenden
Beispiel erhält $Anzeige abhängig von der Bedingung einen anderen Wert:

```
[DateTime]::Now.Second
$Bedingung = [DateTime]::Now.Second % 2 - eq 0
$Bedingung
$Anzeige = if ($Bedingung) { "gerade" } else { "ungerade" }
$Anzeige
```
Seit PowerShell 7.0 kann man für den ternären Operator auch die in z. B. C++, C#
und Java übliche Schreibweise

```
Bedingung? True-Fall : False-Fall
```
verwenden:


```
[DateTime]::Now.Second
$Bedingung = [DateTime]::Now.Second % 2 - eq 0
$Bedingung
$Anzeige =? ($Bedingung) { "gerade" } : { "ungerade" }
$Anzeige
```
Weiteres Beispiel:

```
$ausgabe = (Test-Path c:\temp)? "Temp-Verzeichnis vorhanden" : "Temp-
Verzeichnis nicht vorhanden"
$ausgabe
$ausgabe = (Test-NetConnection MeinServer 123 ).
PingSucceeded? "Server erreichbar" : "Server nicht erreichbar!"
$ausgabe
```
In einem weiteren Beispiel (Reaktion auf die Boolean-Variable $istOnline) soll im
else-Fall nur eine leere Zeichenkette zu liefern sein. Hier kann man bei if den else-
Fall weglassen. Bei dem neuen Operator? : geht dies nicht. Die PowerShell
würde sich beschweren mit "Missing ':' in the ternary expression.". Hier muss man
immer dann eine leere Zeichenfolge liefern.

Mit if.. .else:

```
Write-host "$c ist$(if (-not $istOnline) { " NICHT" }) erreichbar" - Fore
groundColor
"$(if ($istOnline) { "Green" } else { "Red" })"
```
Mit ternärem Operator:

```
Write-host "$c ist$(-not $istOnline? ' NICHT' : '') erreichbar" - Foregr
oundColor
"$($istOnline? "Green" : "Red")"
```
7.16.3 Switch-Bedingung

Mit einer Switch-Bedingung kann man auf elegante Weise viele Fälle
unterscheiden, weil man übersichtlich Bedingungen und Anweisungsblöcke
aneinanderreihen kann.


Man kann eine hinter switch angegebene Variable mit einer festen Wertemenge
vergleichen.

```
Listing 7.31 Viele Bedingungen mit Switch
[1_Basiswissen\PowerShellLanguage\Switch.ps1]
"Welche Note geben Sie diesem Buch?"
$note = Read-Host
switch ($note)
{
1 { $ergebnis = "sehr gut"}
2 { $ergebnis ="gut"}
3 { $ergebnis ="befriedigend"}
4 { $ergebnis ="ausreichend"}
5 { $ergebnis ="mangelhaft"}
6 { $ergebnis ="ungenügend"}
default { $ergebnis ="Ungültige Note" }
}
```
Auch ein Vergleich mit regulären Ausdrücken ist möglich.

```
Listing 7.32 Reguläre Ausdrücke vergleichen mit Switch [1_Basiswissen\PowerShellLanguage\
Switch.ps1]
$text = 'anfragen@IT-Visions.de'
# oder $text = "http://www.dotnet-doktor"
# oder $text = "ftp://ftp.heise.de/" # öffentlicher FTP-Server von Heis
e.de
switch -Regex ($text)
{
'^ftp\://.*$' { "$_ ist eine FTP-Adresse"; Break }
'^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$' { "$_ ist eine E-Mail-Adres
se"; Break }
'^http[s]?\://.*$' { "$_ ist eine Webadresse"; Break }
}
```
7.17 Unterroutinen (Prozedur/Funktionen)


Um die Übersichtlichkeit eines Skripts zu verbessern und Wiederholungen von
Programmcode an mehreren Stellen im Skript zu vermeiden, besteht die
Möglichkeit, wiederkehrende Programmzeilen in sogenannte Unterroutinen zu
kapseln und anstelle der wiederkehrenden Befehle nur noch die Unterroutinen
aufzurufen. Dadurch erhöht sich einerseits die Lesbarkeit; es werden nicht mehr
alle Befehle, sondern nur noch eine Funktion aufgerufen. Des Weiteren schlägt
sich eine Änderung an der Funktion sofort im gesamten Skript nieder.

7.17.1 Prozedur versus Funktion

Eine Unterroutine, die keinen Wert als Ergebnis ihrer Ausführung zurückliefert,
wird o auch als "Prozedur" bezeichnet. Im Kontrast dazu heißen Unterroutinen
mit Rückgabewert "Funktion".

Die PowerShell macht keinen großen Unterschied. In beiden Fällen wird die
Unterroutine definiert durch:

```
function Name { Anweisungsblock }
```
Es gibt in der PowerShell-Skriptsprache, wie in vielen anderen Sprachen, das
Schlüsselwort return, um eine Unterroutine vorzeitig zu verlassen. Dabei kann
man einen Wert übergeben, der dem Aufruf zurückgesendet werden soll.

```
function Name { Anweisungsblock ... return xy }
```
```
ACHTUNG: Anders als in vielen anderen Programmiersprachen ist return
aber nicht die einzige Möglichkeit, einen Rückgabewert zu liefern.
Vielmehr wird alles zum Rückgabewert, was nicht explizit mit Write-Host,
Write-Debug oder Write-Warning (sowie direkt über die Standardausgabe,
z. B. von klassischen Konsolenanwendungen) ausgegeben wird.
```
7.17.2 Prozeduren

Das erste Beispiel zeigt eine Prozedur. Die Prozedur macht zwei Ausgaben und
eine Berechnung. Die Rückgabe an den Aufrufer ist $null (repräsentiert "Kein


Wert").

```
Listing 7.33 Dies ist eine echte Prozedur.
function Get-AltersProzedur()
{
Write-Host "Dieser Funktion wurde übergeben: $($args[ 0 ]) und $($args
[ 1 ])"
$Tage = [int] ([System.DateTime]::now - [DateTime]$Args[ 1 ]).TotalDays
Write-Host "$($args[ 0 ]) ist $Tage Tage alt!"
}
```
Der Aufruf würde so aussehen:

```
# Normaler Aufruf
Get-AltersProzedur "Max Müller" 08.09.1970
# Test, ob wirklich $null zurückkommt --> Erfüllt!
if ((Get-AltersProzedur "Max Müller" 08.09.1970) - eq $null) { "$null!" }
```
```
HINWEIS: Beim Aufruf einer PowerShell-Funktion verwendet man keine
runden Klammern und kein Komma zur Parametertrennung. Hier ist ein
Unterschied zum Aufruf von Methoden in Objekten (siehe Anhang A
"Crashkurs ‚Objektorientierung"). Der Einsatz von runden Klammern und
Kommata Get-AltersProzedur("Max Mammern, "08.09.1970") würde dazu
führen, dass die Prozedur nur einen Parameterwert bekommt, der ein
Array mit zwei Elementen ist.
Der Aufruf von Funktionen unterscheidet sich nicht vom Aufruf von
Commandlets. Dies ist auch das Ziel: Man will Commandlets und
Funktionen äquivalent benutzen können. Tatsächlich sind einige
Commandlets in Form von Funktionen implementiert. Es ist durchaus
guter Stil, Funktionen nach denselben Namenskonventionen wie
Commandlets (Verb-Substantiv) aufzubauen.
```
7.17.3 Funktionen (mit Rückgabewerten)


Bei der nachstehenden PowerShell-Unterroutine könnte man auf den ersten Blick
geneigt sein zu sagen, dass es sich auch um eine Prozedur ohne Rückgabewert
handelt.

```
Listing 7.34 Dies ist eine Funktion mit zwei Rückgabewerten.
function Get-AltersFunktion 1 ()
{
"Dieser Funktion wurde übergeben: $($args[ 0 ]) und $($args[ 1 ])"
$Tage = [int] ([System.DateTime]::now - [DateTime]$Args[ 1 ]).TotalDays
"$($args[ 0 ]) ist $Tage Tage alt!"
}
```
Das ist aber nicht korrekt, denn

```
if ((Get-Altersfunktion 1 "Max Müller" 08.09.1970) - eq $null) { "null!" }
else
{ "nicht null!"}
```
liefert "nicht null!". Die obige Unterroutine ist eine Funktion, die zwei
Zeichenketten zurückliefert. Im Kapitel "Ausgaben" steht zwar, dass "lose"
Literale und Variablen ausgegeben werden, aber wenn solch ein "loser" Ausdruck
in einer Unterroutine steht, dann wird der Wert des Ausdrucks zusätzlich zum
Rückgabewert der Methode. Die Ausgabe wird unterdrückt, wenn der Aufrufer
den Rückgabewert weiterverarbeitet. Die Ausgabe findet nur statt, wenn der
Aufrufer den Rückgabewert ignoriert. Gleiches gilt für Pipelines.

Eine Testfunktion hil dem Verständnis. Diese Routine erzeugt zwei Ausgaben
direkt mit Write-Host zu Beginn und zum Ende der Verarbeitung. Dazwischen gibt
es vier Zeilen, die eine Ausgabe erzeugen, die zum Rückgabewert wird.


Listing 7.35 Testfunktion für die folgende Tabelle

```
function TestFunktion()
{
Write-Host "Beginn der Funktion..."
Get-Service d*
Get-Date | foreach { $_.ToShortDateString() }
2 + 2
$name="Holger"
$name
Write-Host "Ende der Funktion!"
}
```

Tabelle 7.7 Verschiedene Aufrufformen und deren Ausgabe

```
Art des
Aufrufs
```
```
Ausgabe
```
```
TestFunktion
```
```
Erläuterung: Der Aufrufer verwendet die Rückgabewerte nicht.
Daher gibt die Funktion sie direkt aus, was man daran erkennt,
dass die Werte zwischen "Beginn" und "Ende" stehen.
$x =
TestFunktion Erläuterung: Der Aufrufer verwendet die Rückgabewerte,
indem er sie in einer Variablen speichert. Daher gibt die
Funktion nichts aus.
TestFunktion
| foreach {
$_.GetType()
}
```
```
Erläuterung: Der Aufrufer sendet die Objekte über die Pipeline
an Foreach-Object. Nun mag überraschen, dass die Ausgaben
zwischen "Beginn" und "Ende" stehen, was darauf hindeuten
würde, dass die Funktion die Ausgaben macht. Das ist aber
nicht so, weil der Aufrufer das Ergebnis ja verarbeitet. Der
Grund dafür, dass die Werte zwischen "Beginn" und "Ende"
stehen, liegt an der asynchronen Verarbeitung der Pipeline.
Foreach-Object verarbeitet die von der Unterroutine gelieferten
Objekte schon, bevor diese überhaupt fertig ist. An der
Ausgabe sieht man genau, dass die Unterroutine eine
heterogene Menge von Werten liefert.
TestFunktion
| Sort-
Object |
foreach {
```

```
$_.Get-
Type() }
```
```
Erläuterung: Nun steht die Ausgabe nach dem "Ende", denn
das Sort-Object verhindert die asynchrone Verarbeitung.
$x =
TestFunktion
$x | foreach
{
$_.GetType()
}
```
```
Erläuterung: Die Ausgabe steht nach dem "Ende", weil der
Aufrufer die Werte erst in einer Variablen speichert und dann
an die Pipeline sendet. Zwischen zwei Zeilen findet keine
asynchrone Verarbeitung statt.
```
```
HINWEIS: return xy ist äquivalent zu xy; return
Funktionen können auch mit den Schlüsselwörtern break und continue
vorzeitig verlassen werden. Dann gibt es keinen Rückgabewert der
Funktion, aber die "losen" Konstanten und Variablen werden ausgegeben.
Das Skript wird zudem beendet.
```
7.17.4 Art der Rückgabewerte

Bei der PowerShell sind alle Datentypen als Rückgabewerte erlaubt. Anders als in
anderen Programmiersprachen ist eine beliebige Anzahl von Rückgabewerten
erlaubt, die in eine Liste (vom Typ Array von Object, in der PowerShell-Notation:
Object[]) geliefert werden. Eine Unterscheidung gibt es noch, ob ein oder
mehrere Werte zurückgegeben werden. Wenn nur ein Wert zurückgegeben wird,
dann ist der Rückgabewert keine Liste mit einem Element, sondern genau dieser


eine Wert. Dies beweist das folgende Skript. Zu bedenken ist, dass Count kein
Ergebnis liefert, wenn $x keine Liste ist.

```
function Get-ReturnValues([int] $Anz) # Anz legt die Anzahl der Rückgabe
werte fest
{
for([int] $i=0;$i -lt $Anz;$i++) { $i }
}
```
```
$x = (Get-ReturnValues 1 )
"Get-ReturnValues 1 --> Typ: { 0 }, Anzahl { 1 }" - f $x.GetType(), $x.Count
$x = (Get-ReturnValues 2 )
"Get-ReturnValues 2 --> Typ: { 0 }, Anzahl { 1 }" - f $x.GetType(), $x.Count
$x = (Get-ReturnValues 1000000 )
"Get-ReturnValues 1000000 --> Typ: { 0 }, Anzahl { 1 }" - f $x.GetType(), $x.
Count
```
```
Testskript zum Prüfen der Art der Rückgabewerte
```
Bild 7.16 Ausgabe des obigen Skripts

7.17.5 Parameterübergabe

Zwischen Funktion und Prozedur gibt es also in der PowerShell nur einen
marginalen Unterschied. Ein interessanterer Unterschied sind die verschiedenen
Formen der Parameterübergabe. Im Beispiel Get-AltersFunktion 1 () waren die
Parameter weder explizit benannt noch typisiert. Dies hat den Vorteil, dass man
leicht beliebig viele Parameter in beliebiger Form übergeben kann. Der Nachteil
ist jedoch, dass die PowerShell nicht prüfen kann, ob Anzahl und Art der
Parameter stimmen. Folgender Aufruf führt zu einem Abbruch in dem Moment,
wo eine Rechenoperation mit dem Datum stattfinden soll:

```
Get-Altersfunktion 1 "Max Müller" "unsinn"
```

Es gibt drei andere Formen der Parameterübergabe (siehe auch nächstes Listing):

```
Benannte Parameter: Get-Altersfunktion 2 ($Name, $Geb) { ... }
Benannte und typisierte Parameter im Funktionskopf: Get-
Altersfunktion 3 ([string] $Name, [DateTime] $Geb) { ... }
Benannte und typisierte Parameter im Funktionsrumpf: Get-
Altersfunktion 4 { param([string] $Name, [DateTime] $Geb) ... }
```

```
Listing 7.36 Vergleich der verschiedenen Parameterformen
# Parameter unbenannt
function Get-Altersfunktion 1 ()
{
"Dieser Funktion wurde übergeben: $($args[ 0 ]) und $($args[ 1 ])"
$Tage = [int] ([System.DateTime]::now - [DateTime]$Args[ 1 ]).TotalDays
return "$($args[ 0 ]) ist $Tage Tage alt!"
}
```
```
# Parameter benannt
function Get-Altersfunktion 2 ($Name, $Geb)
{
"Dieser Funktion wurde übergeben: $name und $geb"
$Tage = [int] ([System.DateTime]::now - [DateTime]$Geb).TotalDays
return "$Name ist $Tage Tage alt!"
}
# Parameter benannt und typisiert
function Get-Altersfunktion 3 ([string] $Name, [DateTime] $Geb)
{
"Dieser Funktion wurde übergeben: $name und $geb"
$Tage = [int] ([System.DateTime]::now - $Geb).TotalDays
return "$Name ist $Tage Tage alt!"
}
```
```
# Parameter benannt und typisiert - andere Syntaxform
function Get-Altersfunktion 4
{
param([string] $Name, [DateTime] $Geb)
"Dieser Funktion wurde übergeben: $name und $geb"
$Tage = [int] ([System.DateTime]::now - $Geb).TotalDays
return "$Name ist $Tage Tage alt!"
}
```
Der Aufruf ist in allen vier Fällen gleich. Der Unterschied ist nur, dass im Fall der
typisierten Parameter der Fehler schon beim Aufruf der Unterroutine auffällt
(cannot process argument transformation on parameter 'Geb'. Cannot convert
value "unsinn" to type "System. DateTime"), so dass die Routine gar nicht erst
gestartet wird.


```
ACHTUNG: Eine falsche Anzahl von Parametern moniert die PowerShell in
keinem Fall. $args[x] kann man immer zum Zugriff auf die übergebenen
Parameter verwenden.
Dies bedeutet auch, dass es in der PowerShell keine Überladung von
Unterroutinen geben kann. Überladung bedeutet in anderen Sprachen,
dass es mehrere gleichnamige Unterroutinen geben darf, die sich nur
hinsichtlich der Parameterzahl oder Parameterart unterscheiden. Beim
Aufruf wird anhand der übergebenen Parameter entschieden, welche
Unterroutine aufgerufen wird. In der PowerShell hingegen wird – falls es
mehrere gleichnamige gibt – immer die erste verfügbare Unterroutine mit
allen Parametern aufgerufen.
Es gibt aber Überladungen in der .NET-Klassenbibliothek und bei Aufrufen
von Methoden in .NET-Klassen berücksichtigt die PowerShell dies und ru
die passende Methode auf.
```
7.18 Eingebaute Funktionen

Wie schon erwähnt, sind einige Commandlets als PowerShell-Funktion realisiert
(z. B. Clear-Host). Die Ausführung des Befehls dir function: listet alle Funktionen
auf und zeigt, dass auch einige als Kompatibilität zur klassischen Windows-
Konsole erhalten gebliebene Anweisungen wie C: und mkdir als eingebaute
Funktionen der PowerShell realisiert sind.


Bild 7.17 Eingebaute Funktionen der PowerShell

7.19 Fehlerausgabe

Die Ausgabe von Fehlern ist in PowerShell bis einschließlich PowerShell 6.2 auf
zwei Weisen (NormalView und CategoryView) und seit PowerShell 7.0 auf drei
Weisen möglich (Normal-View, CategoryView und NormalView).

Dies steuert der PowerShell-Nutzer über die eingebaute Variable $ErrorView. Vor
PowerShell 7.0 war "NormalView" der Standard. Seit PowerShell 7.0 ist
"ConciseView" der neue, übersichtlichere Standard. Die stark verkürzte und o
nicht hilfreiche Ansicht "CategoryView" gibt es weiterhin.


Listing 7.37 Test der Fehlerausgabe
[Fehlerausgabe.ps1]

```
#$Host.PrivateData.ErrorAccentColor = "orange" # dfeualt ist cyan
```
```
"Standard bei ErrorView ist: " + $ErrorView
Write-host "########### Fehlerausgabe mit NormalView" - ForegroundColor Y
ellow
$ErrorView = "NormalView"
"Beispielfehler 1: Division durch 0"
1 / 0
"Beispielfehler 2: Ungültiger Pfad"
Dir c:\unsinn
```
```
Write-host "########### Fehlerausgabe mit CategoryView" - ForegroundColor
Yellow
$ErrorView = "CategoryView"
"Beispielfehler 1: Division durch 0"
1 / 0
"Beispielfehler 2: Ungültiger Pfad"
Dir c:\unsinn
```
```
Write-host "########### Fehlerausgabe mit ConciseView" - ForegroundColor
Yellow
$ErrorView = "ConciseView"
```
```
"Beispielfehler 1: Division durch 0"
1 / 0
"Beispielfehler 2: Ungültiger Pfad"
Dir c:\unsinn
```

Bild 7.18 Wirkung der verschiedenen Optionen für $ErrorView

```
HINWEIS: Farben bei den Fehlern sieht man nur in Implementierungen
der Power-Shell-Konsole, die ANSI Color Escape Sequences (VT100)
unterstützen.
```
7.20 Fehlerbehandlung


Die PowerShell bietet vier Arten der Fehlerbehandlung:

```
$? (seit PowerShell 1.0)
&& und || (seit PowerShell 7.0)
Trap (seit PowerShell 1.0)
Try-Catch-Finally (seit PowerShell 2.0)
Darüberhinhaus behandelt das Kapitel auch die Konfiguration des Verhaltens
im Fehlerfalle mit dem Parameter -ErrorAction und der eingebauten
Variable $ErrorActionPreference sowie die Abfrage der Fehlerdetails mit
$error und Get-Error.
```
7.20.1 Fehlerstatus mit $? und $LastExitCode

Die einfachste Form der Fehlerbehandlung kann mit der eingebauten Variable $?
erfolgen. Diese Variable zeigt durch einen Boolean-Wert (also den Wert $true
oder $false) an, ob der vorhergehende Befehl erfolgreich war.

Wie die folgende Abbildung belegt, ist es völlig in der Hand des einzelnen
Commandlets, was ein Fehler ist.

So liefert zum Beispiel Get-Process auf die Abfrage nach einem Prozess mit
Namen "Unsinn" einen Fehler, weil es einen solchen nicht gibt, aber auf die Frage
nach allen Prozessen, die mit "Usinn*" beginnen, keinen Fehler, sondern eine
leere Menge.

```
ACHTUNG: Wichtig ist, dass Sie verstehen, dass man $? nur einziges Mal
an der Konsole abfragen kann. Wenn man $? ein zweites Mal direkt
danach aufru, bezieht sich der neue Status immer auf den Status des
letzten Befehls, also die erste Abfrage $? – und diese Abfrage ist immer
erfolgreich ($true), selbst wenn der enthaltene Wert $false war. In einem
Skript ist die Abfrage mehrfach möglich, solange $? nur Teil einer
Bedingung ist und kein weiterer Befehl ausgeführt wurde.
```

Bild 7.19 Einsatz des Fehlerstatus $? im Konsolenfenster

```
Listing 7.38 Einsatzbeispiel für Fehlerstatus $? in einem Skript
[Fehlerbehandlung.ps1]
md W:\LogFiles
if (-not $?) { Write-Warning "Befehl war NICHT erfolgreich!"}
else {
"Befehl war erfolgreich. Kopiere Dateien..."
Copy-Item C:\temp\ W:\LogFiles
}
```

```
Listing 7.39 Verhalten von $? in einem Skript
[Fehlerbehandlung.ps1]
Get-Process Unsinn
if ($?) { Write-Host ('$?=' + "$? d. h. Prozess gefunden!") }
if (-not $?) { Write-Host ('$?=' + "$? d. h. Prozess nicht gefunden!") }
$? # liefert nun true, weil der letzte Befehl Write-Host war!!!
```
```
Get-Process Unsinn 1
$status = $?
if ($status) { Write-Host ('$?=' + "$? d. h. Prozess gefunden!") }
if (-not $status) { Write-Host ('$?=' + "$? d. h. Prozess nicht gefunde
n!") }
$status # liefert false, weil wir uns das Ergebnis gemerkt haben
```
```
# Man kann natürlich auch else einsetzen! :-)
Get-Process Unsinn 1
$status = $?
if ($status) { Write-Host ('$?=' + "$? d. h. Prozess gefunden!") }
else { Write-Host ('$?=' + "$? d. h. Prozess nicht gefunden!") }
$status # liefert false, weil wir uns das Ergebnis gemerkt haben
```
Die eingebaute Variable $? Funktioniert auch mit klassischen
Kommandozeilenbefehlen, z. B. in Verbindung mit dotnet.exe oder git.exe.
Klassische Kommandozeilenbefehle melden den Status mit Zahlen (0 bedeuter
kein Fehler, <> 0 bedeutet Fehler) zurück. Diese Zahl kann man in der PowerShell
via $LastExitCode abfragen.


Bild 7.20 Einsatz des Fehlerstatus $? und von $LastExitCode bei klassischen Kommandozeilenbefehlen

7.20.2 Pipelineverkettingsoperatoren && und ||

In der klassischen Windows-Konsole (cmd.exe) und Unix-Shell gibt es seit langem
die Operatoren && ("and") und || ("or") zur Verkettung von Befehlen.

```
Der Befehl nach && wird ausgeführt, wenn der vorherige Befehl ohne Fehler
ablief.
Der Befehl nach || wird ausgeführt, wenn der vorherige Befehl einen Fehler
verursachte.
```
Beispiel aus der klassischen CMD:

```
node.exe --version && echo "NodeJS installiert" || echo "NodeJS nicht ge
funden!"
```
Auch wenn die Operatoren && und || bereits seit PowerShell 2.0 vorgesehen und
reserviert waren, funktionieren sie in der PowerShell leider erst ab Version 7.0.
Die Pipelineverkettungsoperatoren genannten Operatoren && und ||
funktionieren seit PowerShell 7.0 sowohl mit einzelnen Commandlets und
einzelnen klassischen Kommandozeilenbefehlen als auch mit Pipelines. Es ist
möglich, einen oder beide Operatoren in einer Zeile einzusetzen.


```
HINWEIS: Dass auch Pipelines mit dem Pipeline-Operator in Verbindung
mit && und || möglich sind, ist erlaubt, weil der Pipeline-Operator die
Befehle | stärker aneinander bindet (Vorrang hat) gegenüber && und ||.
Die Pipelineverkettungsoperatoren greifen auf die eingebaute Variablen
$? und $LASTEXITCODE zurück, um den Fehlerstatus abzufragen. Damit
funktionieren die Verkettungsoperatoren nicht nur mit PowerShell-
Commandlets, sondern auch klassischen Kommandozeilenbefehlen wie
ping.exe, git.exe, node.exe, docker.exe.
```
Diese Befehlszeile in PowerShell ab Version 7.0

```
Get-Process Unsinn && Write-Host "Prozess gefunden!" ||
Write-Host "Prozess nicht gefunden!"
```
ist gleichbedeutend zu der alten Schreibweise mit if:

```
Get-Process Unsinn
if ($?) { Write-Host "Prozess gefunden!" }
if (-not $?) { Write-Host "Prozess nicht gefunden!" }
```
Weitere Beispiele:

```
node.exe --version && echo "NodeJS installiert" || echo "NodeJS nicht ge
funden!"
ping MeinServer 123 && "Server erreichbar" || "Server nicht erreichbar"
Get-Process Unsinn && Write-Host "Prozess gefunden!" ||
Write-Host "Prozess nicht gefunden!"
Get-Process Outlook && Write-Host "Prozess gefunden!" ||
Write-Host "Prozess nicht gefunden!"
Get-Process notepad | Stop-Process && Write-Host "Alle notepad-
Prozesse beendet. Starte notepad neu" | notepad.exe ||
Write-Host "notepad konnte nicht beendet werden!"
```
```
ACHTUNG: Der Befehlsteil nach || wird auch ausgeführt, wenn es nicht in
dem Befehl vor &&, sondern in dem Befehl nach && einen Fehler gab.
```

7.20.3 Fehlerbehandlung mit Trap

Die PowerShell unterscheidet zwischen Fehlern, die unbedingt ein Ende der
Ausführung des Befehls/des Skripts erfordern (Terminating Error), und Fehlern,
die es erlauben, dass die Ausführung beim nächsten Befehl fortgesetzt wird (Non-
Terminating Error). Abbrechende Fehler können durch Trap-Anweisungen
abgefangen werden. Nichtabbrechende Fehler können zu abbrechenden Fehlern
gemacht werden.

Trap fängt aufgetretene abbrechende Fehler ab und führt den angegebenen Code
aus. $_ enthält dann Informationen zu dem Fehler in Form einer Instanz von
System.Management. Automation.ErrorRecord. Das Unterobjekt $_. Exception ist
der eigentliche Fehler in Form einer Instanz einer Klasse, die von System.
Exception erbt. Über $_. Exception.GetType(). FullName erhält man den
Fehlertyp, durch $_. Exception.Message den Fehlertext.

Break oder Continue entscheiden, ob das Skript nach dem Fehler fortgesetzt wird.
Das Standardverhalten ist Continue. Mit Exit kann ein definitives sofortiges
Skriptende herbeigeführt werden.

Mit dem folgenden Beispiel können Sie selbst das Fehlerverhalten der PowerShell
testen und mit den verschiedenen Reaktionsmöglichkeiten experimentieren. Der
Fehler wird ausgelöst durch den Aufruf Copy- Item mit falschem Pfad (ein
nichtabbrechender Fehler) und "Get-Dir" (das Commandlet gibt es nicht, ein
abbrechender Fehler).


Listing 7.40 Trap5_Copy.ps 1
[1_Basiswissen/PowerShellLanguage/TrapDemo_Copy.ps1]

```
# Beispiel zum Testen von Fehlerabfangen
trap {
Write-Host ("### ABGEFANGENER FEHLER: " + $_.Exception.Message)
#Write-Error ("Fehler: " + $_.Exception.Message)
#continue
#break
#exit
#throw "test"
}
```
```
"Beispiel zum Testen von Fehlerabfangen"
"Erst geht alles gut..."
copy w:\daten\lieferanten w:\temp\Daten
"Dann läuft es nicht mehr so gut (falscher Pfad)"
copy w:\daten\lieferanten k:\daten\lieferanten
"Und dann folgt Unsinn (falsches Commandlet)"
Get-Dir k:\daten\lieferanten
"Ende des Scripts"
```

Tabelle 7.8 Verhalten der PowerShell im Fehlerfall bei der Verwendung von Trap

```
Trap Reaktion
Nicht
vorhanden
```
```
PowerShell zeigt Fehlermeldungen für Copy-Item ("drive does
not exists") und Get-Dir ("not recognized as a cmdlet, function,
program oder script file") und setzt die Ausführung bis zum Ende
fort.
```
```
Vorhanden,
nur mit
Write-Host
```
```
Es erscheint für den abbrechenden Fehler zusätzlich zu der
PowerShell-Fehlermeldung auch der eigene Fehlertext aus dem
Trap-Block.
```
```
Vorhanden,
mit
continue
```
```
Es erscheint für den abbrechenden Fehler nur der eigene
Fehlertext aus dem Trap-Block.
```
```
Vorhanden,
mit break
```
```
Nach dem abbrechenden Fehler erscheinen der eigene
Fehlertext und dann die Fehlermeldung der PowerShell. Danach
```

```
bricht das Skript ab (d. h., die Ausgabe "Ende des Skripts" wird
nicht mehr erzeugt).
```
```
Vorhanden,
mit exit
```
```
Nach dem abbrechenden Fehler erscheint der eigene Fehlertext.
Dann bricht die Ausführung sofort ab.
```
Trap-Blöcke können durch Angabe eines Fehlertyps in eckigen Klammern
(Fehlerklasse) auf bestimmte Fehlerarten beschränkt werden. Daher kann es
mehrere Trap-Blöcke in einem Skript geben.

7.20.4 Fehlerbehandlung mit Try-Catch-Finally

Die Trap-Anweisung fängt alle Fehler im aktuellen Gültigkeitsbereich ab. Eine
Trap-Anweisung in einer Funktion gilt für den ganzen Programmcode in der
Funktion. Eine Trap-Anweisung in globalem Programmcode gilt für den ganzen
globalen Code. Es ist unerheblich, wo die Trap-Anweisung steht (am Anfang, in
der Mitte, am Ende), sie gilt immer für den gesamten Gültigkeitsbereich.

Seit PowerShell 2.0 hat Microso das aus den .NET-Sprachen bekannte Try-
Catch-Finally als zweite Alternative der Fehlerbehandlung mit Trap eingeführt.
Try enthält den Codeblock, der fehlschlagen könnte. Catch behandelt auretende
Fehler, wobei der erste abbrechende Fehler die Kontrolle in den Catch-Block
verlagert. Finally (als optionaler Block) wird in jedem Fall am Ende ausgeführt.


HINWEIS: Während man mit einer Trap-Anweisung alle Fehler in dem
aktuellen Gültigkeitsbereich abfängt, bezieht sich Try-Catch immer nur
auf Fehler im Try-Block. Die Frage, ob man Trap oder Try-Catch bevorzugt,
ist eine Geschmackssache.


```
Listing 7.41 Beispiel für den Einsatz von Try-Catch-Finally
#######################################
# PowerShell-Skript
# (C) Dr. Holger Schwichtenberg
########################################
```
```
# Beispiel zum Testen von Fehlerabfangen
```
```
try
{
"Beispiel zum Testen von Fehlerabfangen"
"Erst geht alles gut ..."
copy x:\data\projects w:\temp\Projects -Force
"Dann laeuft es nicht mehr so gut (falscher Pfad) (aber wir machen weite
r:
continue)"
copy x:\data\customers w:\temp\customers -ea continue
Und dann folgt Unsinn: falsches Commandlet (da wird -continue ignorier
t!)"
```
```
Get-Dir w:\temp\customers -ea continue
"Kopiervorgang abgeschlossen!"
}
```
```
catch
{
$fehler = $_
Write-Host ("### ABGEFANGENER FEHLER: " + $_.Exception.Message) - Foregro
undColor
yellow
}
finally
{
"Ende des Skripts"
}
```
Innerhalb des Catch-Blocks ist $_ eine Instanz der Klasse
System.Management.Automation. ErrorRecord, wobei über das Attribut Exception
zu der aus dem .NET Framework bekannten Instanz eine .NET-Fehlerklasse


kommt. Details über den Umfang der bereitgestellten Fehlerinformationen zeigt
die folgende Abbildung.

Bild 7.21 Inhalt eines ErrorRecord-Objekts


7.20.5 Konfiguration des Fehlerverhaltens

Die Möglichkeiten werden noch vielfältiger, weil jedes einzelne Commandlet über
die Parameter -ErrorAction (kurz -ea) und -WarningAction (-wa) zudem
bestimmen kann, wie mit Fehlern (oder Warnungen) umgegangen werden soll:

```
Stop: Der Fehler wird ausgegeben und die Ausführung bricht ab. (Alle Non-
Terminating-Fehler werden damit zu Terminating-Fehlern.)
Continue: Der Fehler wird ausgegeben und die Ausführung wird fortgesetzt.
SilentlyContinue: Der Fehler wird nicht ausgegeben und die Ausführung wird
fortgesetzt.
Inquire: Der Benutzer wird gefragt, ob er die Ausführung trotz des Fehlers
fortsetzen möchte.
```
Alle möglichen Kombinationen von -ErrorAction und Trap durchzuspielen würde
den Rahmen dieses Buchs sprengen. Daher werden im Folgenden nur einige
ausgewählte Fälle beschrieben.

```
HINWEIS: Die Anwendung von -ErrorAction hat nur Auswirkung auf
existierende Commandlets. Das in dem Beispiel verwendete, nicht
vorhandene Commandlet "Get-Dir" kann darauf nicht reagieren.
```
Tabelle 7.9 Verhalten der PowerShell im Fehlerfall bei der Verwendung von Trap und -ErrorAction


7.20.6 $ErrorActionPreference


Über die globale eingebaute Variable $ErrorActionPreference kann man das
Standardverhalten für -ErrorAction für alle Commandlets setzen. Der Wert muss
als Zeichenkette übergeben werden. Die Standardeinstellung ist "Continue".

Es folgt ein Beispiel, in dem mehrfach eine Division durch die Zahl 0 ausgeführt
wird, um einen Fehler zu erzeugen. Dabei wird jeweils die $ErrorActionPreference
geändert.

```
Listing 7.42 Beispiel für den Einsatz von $ErrorActionPreference
"Regulärer Programmstart"
```
```
"Aktueller Fehlerbehandlungsstandard: $ErrorActionPreference"
```
```
"1. Versuch"
# Fehler machen
write-host ( 1 / $null)
```
```
"2. Versuch"
$ErrorActionPreference = "silentlycontinue"
# Fehler machen
write-host ( 1 / $null)
```
```
"3. Versuch"
# Fehler machen
$ErrorActionPreference = "stop"
write-host ( 1 / $null)
```
```
"Reguläres Programmende"
```
Das Beispiel führt zu folgender Ausgabe. Man beachte, dass das Programm beim
ersten Versuch mit Fehlermeldung fortgesetzt wird, beim zweiten keine
Fehlermeldung erfolgt und beim dritten Versuch das Programm mit
Fehlermeldung abbricht.


Bild 7.22 Ausgabe des obigen Beispiels

7.20.7 Fehler speichern mit ErrorVariable

Unabhängig von der Einstellung beim Parameter -ErrorAction für ein
Commandlet kann man die Fehlerinformation durch Angabe des Parameters -
ErrorVariable (kurz: - ev) in einer beliebigen Variablen ablegen.

```
TIPP: Dabei ist nach -ErrorVariable der Variablenname ohne das
führende Dollarzeichen anzugeben.
```
Beispiel:

```
Get-Localuser unsinn -ErrorVariable letzterfehler -ErrorAction SilentlyC
ontinue
```
Die Variable $letzterfehler enthält nun den Fehler in einem Objekt des Typs
System. Management.Automation.ErrorRecord.

So kann man nur den Fehlertext selbst ausgeben:

```
$letzterfehler.Exception.Message
```

Bild 7.23 Beispiel für den Einsatz von -ErrorVariable

7.20.8 Letzte Fehler

Die eingebaute Variable $Error enthält die gesamte Geschichte der aufgetretenen
Fehler in Form von Objekten des Typs
System.Management.Automation.ErrorRecord, die jeweils in Unterobjekten Details
liefern, z. B. das .NET-Fehlerobjekt in der Eigenscha Exception.

$Error[ 0 ] ist der letzte aufgetretene Fehler.

Seit PowerShell 7.0 kann man den letzten Fehler alternativ mit dem Commandlet
Get-Error abrufen. Get-Error liefert eine Instanz von
System.Management.Automation. ErrorRecord#PSExtendedError. Mit dem
Parameter -newest x kann man die x letzten Fehler abrufen.

PowerShell 7 zeigt für Instanzen der Klasse ErrorRecord eine deutlich
detailliertere Ausgabe als die Windows PowerShell.


Bild 7.24 Vergleich der Fehlerausgabe in Windows PowerShell 5.1 und PowerShell 7


Bild 7.25 Vergleich der Klassen ErrorRecord und ErrorRecord#PSExtendedError

7.21 Laufzeitfehler erzeugen

Mit Throw kann man innerhalb und außerhalb von Trap-Blöcken beliebige eigene
Fehler erzeugen. Throw erzeugt einen abbrechenden Fehler der Klasse
System.Management.Automation.RuntimeException. Man kann aber auch eine
andere Fehlerklasse in eckigen Klammern angeben. Die angegebene Klasse muss
von System. Exception abgeleitet sein.

```
throw "Fehlertext"
throw [System.ApplicationException] "Fehlertext"
```
7.22 Objektorientiertes Programmieren mit

Klassen

Viele PowerShell-Nutzer, insbesondere solche, die auch als Entwickler mit
objektorientierten Sprachen arbeiten, vermissten in der Windows PowerShell in


den Versionen 1.0 bis 4.0 die Möglichkeit, eigene Klassen direkt in der
PowerShell-Skriptsprachensyntax zu definieren. Bisher musste man dafür auf die
Syntax von C# oder Visual Basic .NET zurückgreifen, die man in PowerShell-
Skripte einbetten kann.

Seit Windows PowerShell 5.0 und auch in PowerShell 6/7 gibt es nun die
vermissten Sprachfeatures. Das nächste Listing zeigt den Einsatz des neuen
Schlüsselworts class. Eine Power-Shell-Klasse kann Attribute und Methoden
sowie Konstruktoren enthalten – Letztere beide können auch überladen werden.
Statische Mitglieder sind mit dem Schlüsselwort static möglich. Auch Vererbung
und die Implementierung von Schnittstellen unterstützt die Skriptsprache mit
einem Doppelpunkt hinter dem Klassennamen.

Bild 7.26 Möglichkeiten und Nutzung von PowerShell-Klassen

Das folgende Listing zeigt die Implementierung und Verwendung der im obigen
Schaubild dargestellten selbst definierten PowerShell-Klasse "Benutzer".


Listing 7.43 Klassen und Vererbung in PowerShell (seit Version 5.0)
[1_Basiswissen/PowerShellOOP/WPS5_Klassen_Benutzer.ps1]

```
# Definition einer Klasse
class Benutzer
{
# Statische Mitglieder
static [Int 64 ] $Anzahl
# Instanzmitglieder
[string] $Name
[int 32 ] $ID
[DateTime] $Datum
hidden [string] $Rechte = "eingeschränkte Rechte"
```

# Interne Methode
hidden [void] Init([int 32 ] $neueid)
{
$this.id = $neueid
"Neuer Benutzer erzeugt!"
}

# Konstruktor 1: parameterlos
Benutzer()
{
[Benutzer]::Anzahl = [Benutzer]::Anzahl + 1
$this.Init([Benutzer]::Anzahl)
}

# Konstruktor 2: mit Parameter
Benutzer($neueid)
{
$this.Init($neueid)
}

# öffentliche Methode
[string] GetInfo([bool] $mitDatum)
{
if ($mitDatum) {
return "$($this.ID): $($this.Name) wurde am $($this.Datum.
ToShortDateString()) als Benutzer angelegt."
}
else
{
return "$($this.ID): $($this.Name)"
}
}
}

# Erbende Klasse
class Admin : Benutzer
{
# Konstruktor mit Parameter


```
Admin($neueid) : base($neueid)
{
$this.Rechte = "volle Rechte"
}
```
```
}
```
```
# Objektinstanziierung
$b = [Admin]::new( 123 )
```
```
# Befüllen des Objekts
$b.Name = "Holger Schwichtenberg"
$b.Datum = Get-Date "22.12.2015"
```
```
# Ausgaben
$b.GetInfo($true)
"$($b.Name) hat $($b.Rechte)"
```
Allerdings sind alle Klassenmitglieder in PowerShell-Klassen öffentlich ("public").
Die aus anderen objektorientierten Programmiersprachen wie C++, C# und Java
bekannten Sichtbarkeiten "private" und "protected" sind nicht vorgesehen. Das
Schlüsselwort hidden versteckt ein Klassenmitglied nur bei der IntelliSense-
Eingabeunterstützung. Ein Aufruf ist aber weiterhin möglich, wie obiges Listing
anhand des Attributs $Rechte beweist. Verglichen mit anderen .NET-Sprachen
fehlt der PowerShell auch weiterhin die Möglichkeit, Namensräume zu definieren,
Ereignisse in Klassen zu implementieren und eigene Schnittstellen zu
deklarieren.


HINWEIS: Zu beachten ist, dass Microso das Verhalten von Methoden in
Power-Shell-Klassen an das Verhalten von Methoden in anderen
objektorientierten Sprachen angepasst hat und damit von dem Verhalten
von Funktionen in PowerShell abrückt (weil laut PowerShell-Chefarchitekt
Jeffrey Snoover das besondere Verhalten der PowerShell-Funktionen im
Nachhinein als "günstig" angesehen wird, man dies aber heute aus
Kompatibilitätsgründen nicht mehr ändern kann).

```
Eine Methode in einer PowerShell-Klasse wird mit runden Klammern
aufgerufen und die Parameterwerte werden durch Kommata
getrennt. Dies ist für Funktionen nicht möglich. Dort dürfen keine
Klammern genutzt werden und die Parameter werden durch
Leerzeichen getrennt.
Es gibt nur einen einzigen Rückgabewert einer Methode in einer
PowerShell-Klasse, nämlich genau den Wert, der nach Return steht.
PowerShell-Funktionen liefern hingegen auch alle "losen", nicht für
eine Variablenzuweisung oder explizite Ausgabe verwendeten
Ausdrücke zurück. Es kann daher bei PowerShell-Funktionen beliebig
viele Rückgabewerte geben.
```

### 8 Ausgaben

Dieses Kapitel behandelt die verschiedenen Möglichkeiten zur
Erzeugung bzw. Beeinflussung von Bildschirm- und Sprachausgaben in
der PowerShell.


Tabelle 8.1 Wichtige Ausgabe-Commandlets

```
Format-
Table ()
```
Tabellenausgabe

```
Format-List
(fl)
```
detaillierte Liste

```
Format-Wide
(fw)
```
mehrspaltige Liste

```
Format-Hex Verwandelt eine Zeichenkette in eine Folge von
Hexadezimalzahlen
```
```
Out-Host
(oh)
```
```
Ausgabe an Konsolen mit Optionen zur Farbe und
seitenweisen Ausgabe
```
```
Out-GridView
(ogv)
```
Grafische Tabelle mit Filter- und Sortieroptionen

Out-File Speichern in Datei

```
Out-Printer
(lp)
```
Ausgabe an Drucker

```
Out-Speech Sprachausgabe (in der PowerShell-Erweiterung
PSCX)
```
```
Out-Null Die Objekte der Pipeline werden nicht
weitergegeben
```
8.1 Ausgabe-Commandlets


Ein normales Commandlet sollte keine eigene Bildschirmausgabe
erzeugen, sondern allenfalls eine Menge von Objekten in die Pipeline
legen. Es ist bestimmten Commandlets vorbehalten, eine Ausgabe zu
erzeugen. Beispiele für diese Commandlets sind:

```
Write-Host: Ist das Standardausgabecommandlet, das immer
verwendet wird, wenn man ein Literal oder eine Variable einfach
verwendet. Also "Hallo Welt!" ist das Gleiche wie Write-Host
"Hallo Welt!"
Out-Default: Standardausgabe gemäß der PowerShell-
Konfiguration (DotNetTypes.Format.ps 1 xml), siehe folgendes
Kapitel
Out-Host (kurz: oh): wie Out-Default mit zusätzlicher Option zur
seitenweisen Ausgabe
```
Bild 8.1 Ausgabe mit Format-Wide

```
Out-Null: Die Objekte der Pipeline werden nicht weitergegeben. Der
Einsatz von Out-Null ist sinnvoll, wenn ein Commandlet ein
Rückgabeobjekt liefert, das man nicht benötigt und das auch nicht
auf dem Bildschirm ausgegeben werden soll.
```

```
Out-GridView (kurz: ogv): Ausgabe in grafischer Tabelle mit Such-
und Filterfunktionen (vorhanden seit PowerShell 2.0)
Format-Wide (kurz: fw): ein- oder mehrspaltige Liste
Format-List (kurz: fl): detaillierte Liste
Format-Table (kurz: ft): Tabellenausgabe
```
Bild 8.2 Ausgabe mit Format-List


Bild 8.3 Ausgabe mit Format-Table

```
HINWEIS: Bei den Ausgabe-Commandlets können Sie jeweils
die auszugebenden Attribute mit dem Parameter -Property
(kurz -p) festlegen. Dieser Parameter ist immer der erste
erwartete Parameter und daher entfällt der Name in der Regel.
Beispiele:
```
```
Get-Service | Format-Table Name, Status
Get-Service | Format-List Name, Status
```
Bei Format-Wide kann man nur ein Attribut nennen:

```
Get-Service | Format-Wide -Property Name
```

```
TIPP: In vielen Fällen geben Ausgabe-Commandlets nicht alle
Attribute eines Objekts aus. Dies liegt an der Standardausgabe
(siehe gleichnamiges Unterkapitel). Sie können alle Attribute
sehen, wenn Sie statt des Parameters -Property einen Stern (*)
angeben.
```
```
Bild 8.4 Format-Table für Get-Service ohne und mit Stern
```
8.2 Benutzerdefinierte

Tabellenformatierung

Bei Format-Table kann man mit Hash-Tabellen angeben, wie die Spalten
formatiert werden sollen. Für jede Spalte kann man eine Hash-Tabelle
mit folgenden Angaben anlegen:

```
Label: Spaltenüberschri
Expression: beliebiger PowerShell-Ausdruck, der die Werte liefert,
auch Berechnung
Width: Spaltenbreite
Format: Formatierungsbefehl
```

Praxislösung 1: Laufende Prozesse

Es folgt ein Beispiel einer Tabelle mit drei Spalten:

```
fünf Zeichen für die Prozessnummer in der ersten Spalte
       20 Zeichen für den Prozessnamen
elf Zeichen für die Speichernutzung, wobei die Angabe in Megabyte
erfolgt und mit maximal einer Nachkommastelle
Get-Process | Sort-Object workingset 64 - desc | ft @{Label="Nr";
Expression={$_.ID};
Width= 5 }, @{Label="Name"; Expression={$_.Processname}; Width= 20
}, @{Label="Speicher
MB"; Expression={$_.WorkingSet 64 / 1 MB}; Width=11; Format="{0:0
0000.0}" }
```
Bild 8.5 Ausgabe des obigen Befehls

Praxislösung 2: Verfügbare PowerShell-Module


Ein zweites Beispiel ist die Ausgabe einer Tabelle der verfügbaren
PowerShell-Module, die in fünf Spalten den Modulnamen und den
Modultyp zeigt sowie die Anzahl der Befehle insgesamt und getrennt
nach Commandlets und Funktionen.

```
Get-Module -ListAvailable | ft @{expression={ $_.name }; label
="Name"; width= 40 },
moduletype, `
@{expression={ $_.exportedcommands.count }; label="Gesamtanzahl
Befehle"; width= 10 }, `
@{expression={ $_.exportedcmdlets.count }; label="Anzahl Comman
dlets"; width= 10 }, `
@{expression={ $_.exportedfunctions.count }; label="Anzahl Func
tions"; width= 10 }
```

Bild 8.6 Angepasste Ausgabe der Modulliste. Diese Abbildung zeigt nur einen Teil der
Ausgabe.


8.3 Benutzerdefinierte Listenausgabe

Auch über die Ausgabe von Format-List (alias fl) kann man Hash-
Tabellen steuern. Allerdings gibt es dafür keine Angabe Width. Wenn
man diese verwendet, meldet die PowerShell den Fehler "Der Schlüssel
"Width" ist ungültig.".

Beispiel: Benutzerdefinierte und sortierte Listenausgabe der laufenden
Prozesse

```
Get-Process | Sort-Object workingset 64 - desc | fl @{Label="Nr";
Expression={$_.ID};
Width= 5 }, @{Label="Name"; Expression={$_.Processname} }, @{Labe
l="Speicher MB";
Expression={$_.WorkingSet 64 / 1 MB}; Format="{0:00000.0}" }
```
8.4 Mehrspaltige Ausgabe

Eine mehrspaltige Ausgabe realisiert man mit Format-Wide unter Angabe
der Spaltenanzahl im Parameter -Column.

Beispiel: Sortierte Ausgabe der laufenden Dienste in vier Spalten

```
Get-Service | Where status -eq running | Sort-Object | Format-W
ide -Property Name
```
- column 4

Eine Ausgabe von Zeichenketten will so aber nicht gelingen. Die
folgende Ausgabe ist nur einspaltig:

```
"a","b","c","d",1,2,3,4 | Format-Wide -column 2 # nur einspalti
g
```

In diesem Fall muss man etwas tricksen mit einem speziellen Ausdruck
bei -Property, der dafür sorgt, dass das aktuelle Objekt als Ganzes
ausgegeben wird, und alle internen Verarbeitungsschritte mit -force
ausschalten.

```
"a","b","c","d",1,2,3,4 | Format-Wide -Property @{Expression=
{$_}} - column 2 - Force
```
Das ist zum Beispiel wichtig, wenn man eine Objektmenge in der
Pipeline zuvor auf Zeichenketten reduziert hat:

```
Get-Service | where status -eq running | sort-object | foreach
{ $_.name } | Format-
Wide -Property Name -column 4 # nur einspaltig :-(
Get-Service | where status -eq running | sort-object | foreach
{ $_.name } | Format-
Wide -Property @{Expression={$_}} - column 4 - Force # richtig =
vierspaltig!
```

Bild 8.7 Vierspaltige Ausgabe der laufenden Dienste mit Format-Wide

8.5 Out-GridView

Das Commandlet Out-GridView gab es schon einmal in der Beta-Version
der PowerShell 1.0, es schae es dann aber nicht in das endgültige
Produkt. In PowerShell 2.0 kehrte es schließlich zurück. Out-GridView
zeigt den aktuellen Inhalt der Pipeline in einem separaten Fenster in
einer grafischen Tabelle an und bietet dort Filtermöglichkeiten.

Beispiel: Get-Process | Out-GridView


```
ACHTUNG: Die grafische Benutzeroberfläche, die das
Commandlet zeigt, basiert auf der Windows Presentation
Foundation (WPF). Da es WPF nur unter Windows gibt,
funktioniert dieses Commandlet nicht in PowerShell unter Linux
und macOS.
```
Suchen

Eine Eingabe im Text "Filter" führt eine Volltextsuche über alle Spalten
aus. Über die Funktion "Kriterien hinzufügen" kann man grundsätzlich
auch komplexere Abfragen über einzelne Spalten definieren. Aus dem
darüber erreichbaren Drop-down-Feld können Sie eine Auswahl aus
allen Eigenschaen treffen. In der daraus resultierenden Zeile können
die Bedingungen definiert werden.

ACHTUNG: Leider gibt es aber nur Filterkriterien für Zeichenketten,
nicht aber Vergleichsoperationen wie größer und kleiner für Zahlen
(siehe Abbildung: für den Zahlenwert "WorkingSet" (WS) wird kein
größer oder kleiner angeboten).


Bild 8.8 Anzeige der Prozessliste mit Out-GridView

Bild 8.9 Volltextsuche in der Prozessliste mit Out-GridView


Bild 8.10 Definition einer Abfrage im Out-GridView-Fenster

8.6 Standardausgabe

Wenn am Ende einer Pipeline keine Ausgabefunktion genannt ist,
verwendet die PowerShell automatisch das Commandlet Out-Default.
Out-Default bedient sich bei der Ausgabe einer Standardvorgabe
("View"), die in der Datei DotNetTypes.Format.ps 1 xml im
Installationsordner der PowerShell abgelegt ist. Dort kann man
beispielsweise für den Typ System.Diagnostics. Process nachlesen,
dass die Ausgabe in einer achtspaltigen Tabelle erfolgen soll (siehe
folgende Abbildung).

Wenn dort keine Standardvorgabe existiert, verwendet die PowerShell
folgende Regeln:

```
Alle Attribute (inkl. Noteproperties) werden ausgegeben.
Die Ausgabe erfolgt mit Format-Table, solange es wenig Spalten
sind.
Bei mehr Spalten wird Format-List verwendet.
```

Bild 8.11 Ausschnitt aus der Beschreibung der Standardausgabe für den Typ
System.Diagnostics. Process in DotNetTypes.Format.ps 1 xml

Die in DotNetTypes.Format.ps 1 xml abgelegten Views kann man mit dem
Commandlet Get-ViewDefinition aus den PSCX ausgeben. Dabei ist zu
beachten, dass die Views für .NET-Klassen und WMI-Klassen definiert


sind, nicht für Commandlets. Anstelle von Get-Process muss man also
den Rückgabetyp System.Diagnostics.Process angeben.

Beispiel:

```
Get-ViewDefinition.ps 1 System.Diagnostics.Process
```
Bei der Ausführung werden Sie feststellen, dass es Views für diese
Klasse gibt: "process", "starttime" und "priority" für die
Tabellenausgabe und "process" für das Ausgabeformat "wide". In den
Ausgabe-Commandlets wie Format-Table kann man die verschiedenen
Views aufrufen. Get-Process | Format-Table -view priority liefert eine
nach Prioritäten gruppierte Prozessliste.

Bild 8.12 Views für die Klasse "Process"


```
ACHTUNG: Die PowerShell gerät in einigen Situationen in
Schwierigkeiten, wenn die verschiedenen Ausgabeformen
miteinander kombiniert werden. Die folgende Befehlsfolge in
einem Skript
```
```
Get-Service d*
Get-Process d* | ft
```
führt zum Fehler (siehe Abbildung).

```
Bild 8.13 Ausgabeproblem
```
```
Die Lösung besteht in diesem Fall darin, Format-Table (ft) beide
Male explizit zu nennen.
```
```
Get-Service d* | ft
Get-Process d* | ft
```
8.7 Einschränkung der Ausgabe

Die Ausgabebefehle erlauben die Spezifikation der Objektattribute, die
ausgegeben werden sollen, z. B.:


```
Get-Process | Format-Table -property id,processname,workingset
```
erzeugt eine Tabelle der Prozesse mit Prozess-ID, Name des Prozesses
und Speichernutzung. Attributnamen können dabei auch durch den
Platzhalter * abgekürzt werden. Der Alias für Format-Table ist ft. Den
Parameternamen -Property kann man auch als -prop abkürzen:

```
Get-Process | FT -prop id,processn*,working*
```
Warnung: Eine Abkürzung auf nur einen Buchstaben (-p) funktioniert
kurioserweise nicht auf einigen älteren PowerShell-Installationen. Auf
einigen Systemen wird eine Doppeldeutigkeit mit dem Parameter -
PipelineVariable gemeldet (siehe dazu Kapitel "Einzelbefehle der
PowerShell/Commandlets/Abkürzungen für Parameter").

```
HINWEIS: Die gleiche Ausgabe können Sie auch erzielen, wenn
Sie Select-Object einsetzen:
```
```
Get-Process | Select-Object id, processname, workingset
```
```
Technisch gesehen ist dies aber etwas anderes: Select-Object
reduziert die Objekte in der Pipeline auf die drei genannten
Eigenschaen. Danach wirkt die Standardausgabe für
Prozessobjekte mit Format-Table, auch ohne dass dies hier
angegeben ist. Nach Select-Object könnte man die Objekte aber
auch noch anders weiterverarbeiten. Nach einem Format-Table
sind die Objekte in Zeichenketten umgewandelt und nicht mehr
elegant weiterverarbeitbar.
```
8.8 Seitenweise Ausgabe


Viele Ausgaben sind zu lang, um sie auf einer Bildschirmseite darstellen
zu können. Manche Ausgaben sind sogar länger als der Puffer des
PowerShell-Fensters (z. B. Get-Command Get-Help). Die seitenweise
Ausgabe erzwingt man mit dem Parameter -paging (kurz -p) im Out-
Host-Commandlet, was aber nur in der PowerShell-Konsole, nicht aber
in der ISE funktioniert. Die ISE meldet bei der Nutzung dieses
Parameters "The method or operation is not implemented.".

Beispiel:

```
Get-Service | Out-Host -p
```
```
HINWEIS: Es gibt alternativ auch eine Funktion more, die die
gleiche Aufgabe zu erfüllen scheint. Allerdings ist die Nutzung
im Einzelfall nicht so schön. more basiert nämlich auf dem alten
more.com-Befehl und ist blockierend, d. h., Sie sehen die erste
Ausgabeseite erst, wenn das letzte Objekt angekommen ist. Out-
Host -p arbeitet hingegen asynchron. Versuchen Sie mal:
```
```
Get-ChildItem c:\ - Recurse | Out-Host -p
```
im Vergleich zu:

```
Get-ChildItem c:\ - Recurse | more
```

Bild 8.14 Seitenweise Ausgabe mit Out-Host -p

8.9 Ausgabe einzelner Werte

Um ein bestimmtes Literal oder den Inhalt einer Variablen auszugeben,
muss man diesen nur an der Konsole eingeben (siehe folgende
Abbildung). Auch alle Literale und Variablen, die "lose" in einem Skript
stehen, zum Beispiel in der zweiten Zeile dieser Befehlsfolge:

```
$name = "Holger"
$name
```

Alternativ kann man für eine Ausgabe von Literalen und Variablen
explizit die Commandlets Write-Host, Write-Warning und Write-Error
verwenden. Write-Warning und Write-Error erzeugen die Ausgabe
hervorgehoben (im Standard gelb und rot).

Bild 8.15 Ausgabe von Konstanten und Variablen

Bei Write-Host kann man die Farben genau angeben:

```
Write-Host "Hallo Holger" - foregroundcolor red -backgroundcolor
white
```
Um in einer Ausgabe Literale und Variablen zu mischen, muss man
diese entweder mit + verknüpfen:

```
$a + " ist erreichbar unter " + $b + ". Diese Information hat d
en Stand: " + $c + "."
```
oder aber die Variablen direkt in die Zeichenkette einbetten. Im
Gegensatz zu anderen Sprachen wertet die PowerShell die Zeichenkette
aus und sucht dort nach dem Zeichen $ (Variablenauflösung):


```
"$a ist erreichbar unter $b. Diese Information hat den Stand:
$c."
```
Zur Zusammensetzung von Zeichenketten kann man in der PowerShell
auch die in .NET gebräuchlichen Platzhalter und Formatkennzeichner
(z. B. d = Datum in Langform) verwenden. Dafür ist nach der
Zeichenkette der Ausgabeoperator -f zu benutzen. Diese
Ausgabeoption ist aufgrund der Formatierungsmöglichkeiten die
mächtigste:

```
"{ 0 } ist erreichbar unter { 1 }. Diese Information hat den Stand:
{2:d}." - f $a, $b, $c
```

TIPP: Um die möglichen Farben zu erfahren, geben Sie ein

```
Get-Help Write-Host -Parameter ForeGroundColor
```
Das folgende Listing fasst die drei äquivalenten Möglichkeiten
zusammen.


```
Listing 8.1 Formatierte Ausgabe
[Ausgabe.ps1]
$a = "Holger Schwichtenberg"
$b = "buero@IT-Visions.de"
$c = Get-Date
```
```
# Möglichkeit 1
$a + " ist erreichbar unter " + $b + ". Diese Information hat d
en Stand: " + $c + "."
```
```
# Möglichkeit 2
"$a ist erreichbar unter $b. Diese Information hat den Stand:
$c."
```
```
# Möglichkeit 3
"{ 0 } ist erreichbar unter { 1 }. Diese Information hat den Stand:
{2:D}." - f $a, $b, $c
```
Das obige Skript gibt Folgendes aus:

```
Holger Schwichtenberg ist erreichbar unter buero@IT-Visions.de.
Diese Information hat
den Stand: 14.09.2013 16:53:13.
Holger Schwichtenberg ist erreichbar unter buero@IT-Visions.de.
Diese Information hat
den Stand: 14.09.2013 16:53:13.
Holger Schwichtenberg ist erreichbar unter buero@IT-Visions.de.
Diese Information hat
den Stand: Donnerstag, 14. September 2013.
```
8.10 Details zum Ausgabeoperator


Der Ausgabeoperator –f ist die mächtigste Form der Zusammensetzung
von Zeichenketten aus verschiedenen Werten. Innerhalb der
Zeichenkette legt man in geschweien Klammern Platzhalter fest,
wobei die Zählung mit 0 beginnt. Nach dem Operator - f führt man
dann die einzelnen Werte auf.

Beispiel: "Sehr geehrter Herr {0}, wir freuen uns, Sie in {1} zu
begrüßen!" - f $Name, $Ort Platzhalter dürfen sich wiederholen. Dies
bedeutet, dass aus

```
$Name = "Müller"
$Ort = "Essen"
"Sehr geehrter Herr { 0 }, wir freuen uns, Sie in { 1 } zu begrüße
n! Herr { 0 }, Sie werden
in { 1 } vieles erleben!" - f $Name, $Ort
```
folgender Text entsteht:

```
Sehr geehrter Herr Müller, wir freuen uns, Sie in Essen zu begr
üßen! Herr Müller, Sie
werden in Essen vieles erleben!
```
Im Platzhalter kann man Formatierungen festlegen.

Der folgende Ausdruck würde eigentlich dies ausgeben:

Ausdruck Ausgabe

```
$Name = "Müller" $Geb = [DateTime]
"8.9.1970"
"Herr { 0 }, geboren am { 1 }, ist { 2 }
Tage alt!" - f $Name, $Geb, [INT]
([DateTime]::Now-$Geb).TotalDays
```
Herr Müller, geboren am

09. 08. 1970 00:00:00, ist
14 411 Tage alt!

Eine andere Formatierung könnte so aussehen:

Ausdruck Ausgabe


```
$Name = "Müller" $Geb = [DateTime]
"8.9.1970"
"Herr {0,-10}, geboren am {1:d}, ist
{2:0,000} Tage alt!" - f $Name, $Geb, [INT]
([DateTime]::Now-$Geb).TotalDays
```
```
Herr Müller,
geboren am 09. 08.
1970, ist 14 411 Tage
alt!
```
Zur Erläuterung: ":-10" sorgt für eine linksbündige Ausgabe mit einem
Platz von mindestens 10 Zeichen (positive Zahlen sorgen für
rechtsbündige Ausgaben), ":d" reduziert die Anzeige auf das Datum und
":0,000" erzeugt das Tausendertrennzeichen.

Ein weiteres Beispiel für die Ausgabe der Prozessliste mit Foreach-
Object (alias %):

```
Get-Process | % { "{0,-40} | {1:0,000.00}MB" - f $_.Name, ($_.w
s/ 1 MB)}
```
```
ACHTUNG: Bitte beachten Sie: Der Einsatz von Komma und
Punkten in den Formatbeschreibungen ist hier kein Fehler. Die
Syntax orientiert sich an amerikanischen Standards. Dort ist der
Punkt das Nachkommastellentrennzeichen und das Komma das
Tausendertrennzeichen.
Die daraus resultierende Ausgabe orientiert sich aber immer an
der aktuellen Systemeinstellung bzw. anderslautenden
Vorgaben innerhalb der PowerShell.
```

Tabelle 8.2 Vordefinierte Formatierungen

Symbol Beschreibung Beispiel Ergebnis

```
c Währung "{0:c}" – f 1 000
000
```
1 000 000,00

```
d Dezimalzahl "{0:d}" – f 1
000 000
```
1 000 000

```
e Wissenschalich "{0:e}" – f 1 000
000
```
1,000000e+ 006

```
f Festkommazahl "{0:f}" – f 1 000
000
```
1 000 000,00

```
g Generisch "{0:g}" – f 1
000 000
```
1 000 000

```
n Tausendertrennzeichen "{0:n}" – f 1
000 000
```
1 000 000,00

```
x Hexadezimal "{0:x4}" – f 1
000 000
```
f 4240

```
d Kurzes Datumsformat "{0:d}" – f
[DateTime]
"1.22.2010
00:44:15"
```
22. 01. 2010

```
D Langes Datumsformat "{0:D}" – f
[DateTime]
"1.22.2010
00:44:15"
```
```
Freitag, 22.
Januar 2010
```
t Kurzes Zeitformat "{0:t}" – f 00:44


```
[DateTime]
"1.22.2010
00:44:15"
```
T Langes Zeitformat "{0:T}" – f
[DateTime]
"1.22.2010
00:44:15"

00:44:15

f Datum und Uhrzeit
komplett (kurz)

```
"{0:f}" – f
[DateTime]
"1.22.2010
00:44:15"
```
```
Freitag, 22.
Januar 2010
00:44
```
F Datum und Uhrzeit
komplett (lang)

```
"{0:F}" – f
[DateTime]
"1.22.2010
00:44:15"
```
```
Freitag, 22.
Januar 2010
00:44:15
```
g Standarddatum (kurz)"{0:g}" – f
[DateTime]
"1.22.2010
00:44:15"

```
22.01.2010
00:44
```
G Standarddatum (lang)"{0:G}" – f
[DateTime]
"1.22.2010
00:44:15"

```
22.01.2010
00:44:15
```
M Tag des Monats "{0:M}" – f
[DateTime]
"1.22.2010
00:44:15"

22 Januar

Y Monat und Jahr "{0:Y}" – f Januar 2010


```
[DateTime]
"1.22.2010
00:44:15"
```
r Datumsformat nach
RFC 1123

```
"{0:r}" – f
[DateTime]
"1.22.2010
00:44:15"
```
```
Fri, 22 Jan
2010 00:44:15
GMT
```
s Sortierbares
Datumsformat

```
"{0:s}" – f
[DateTime]
"1.22.2010
00:44:15"
```
```
2010-01-
22 T00:44:15
```
u Universell sortierbares
Datumsformat

```
"{0:u}" – f
[DateTime]
"1.22.2010
00:44:15"
```
```
2010-01-22
00:44:15Z
```
U Universell sortierbares
GMT-Datumsformat

```
"{0:U}" – f
[DateTime]
"1.22.2010
00:44:15"
```
Donnerstag,

21. Januar
2010 23:44:15


Tabelle 8.3 Individualformatierungen

Symbol Beschreibung Aufruf Ergebnis

```
00-Platzhalter "
{0:00.0000}"
```
- f 1 000 000

```
1 000
000,0000
```
# Zahl-Platzhalter "{0:(#).##}"

- f 1 000 000

```
(1 000
000)
```
. Nachkommastellentrennzeichen "{0:0.0}" – f
    1 000 000

```
1 000
000,0
```
```
, Tausendertrennzeichen "{0:0,0}" – f
1 000 000
```
```
1 000
000
```
```
,. Ganzzahliges Vielfaches von
1000
```
```
"{0:0,.}" – f 1
000 000
```
1000

```
% Prozentwert "{0:0%}" – f
1 000 000
```
```
100 000
000 %
```
e Exponenten-Platzhalter "{0:00e+0}"

- f 1 000 000

10 e+ 5

```
dd Tag "{0:dd}" – f
[DateTime]
"1.22.2010
00:44:15"
```
22

```
ddd Wochentagname (kurz)"{0:ddd}" – f
[DateTime]
"1.22.2010
00:44:15"
```
Fr


dddd Wochentagname (lang)"{0:dddd}"

- f
[DateTime]
"1.22.2010
00:44:15"

Freitag

gg Zeitalter "{0:gg}" – f
[DateTime]
"1.22.2010
00:44:15"

n. Chr.

hh Stunde zweistellig "{0:hh}" – f
[DateTime]
"1.22.2010
00:44:15"

12

HH Stunde zweistellig (24 Stunden)"{0:HH}" – f
[DateTime]
"1.22.2010
00:44:15"

00

mm Minute "{0:mm}" – f
[DateTime]
"1.22.2010
00:44:15"

44

MM Monat "{0:MM}" – f
[DateTime]
"1.22.2010
00:44:15"

01

MMM Monatsname (Kürzel)"{0:MMM}"

- f
[DateTime]

Jan


```
"1.22.2010
00:44:15"
```
MMMM Monatsname (ausgeschrieben)"
{0:MMMM}"

- f
[DateTime]
"1.22.2010
00:44:15"

Januar

ss Sekunde "{0:ss}" – f
[DateTime]
"1.22.2010
00:44:15"

15

yy Jahr zweistellig "{0:yy}" – f
[DateTime]
"1.22.2010
00:44:15"

10

yyyy Jahr vierstellig "{0:YYYY}" –
f
[DateTime]
"1.22.2010
00:44:15"

2010

zz Zeitzone (kurz)"{0:zz}" – f
[DateTime]
"1.22.2010
00:44:15"

+ 01

zzz Zeitzone (lang)"{0:zzz}" – f
[DateTime]
"1.22.2010
00:44:15"

+01:00


8.11 Ausgabe von Methodenergebnissen

und Unterobjekten in Pipelines

Manchmal bekommt man Daten nicht aus direkten Eigenschaen
(Attributen), sondern aus Methoden eines Objekts oder aus Attributen
eines Unterobjekts. Ein häufiger Fall ist GetType(), das
Typinformationen über die .NET-Klasse in Form eines System.Type-
Objekts liefert. Nun kann man in den Ausgabe-Commandlets aber
eigentlich nur Attribute angeben.

Die folgende Syntax ist nicht erlaubt:

```
Get-ChildItem c:\windows\w* | ft Name, GetType()
```
Stattdessen muss man etwas umständlicher den Aufruf von GetType()
in einen Ausdruckblock verpacken und schreiben:

```
Get-ChildItem c:\windows\w* | ft Name, { $_.GetType() }
```
Bild 8.16 Aufruf von GetType() innerhalb von Format-Table ()

Ein weiteres Beispiel ist der Zugriff auf die Stundenzahl (Attribut Hours)
im Attribut TotalProcessorTime der Process-Klasse. TotalProcessorTime
ist ein Unterobjekt, das selbst wieder Eigenschaen besitzt.

Falsch:

```
Get-Process | ft ProcessName, .TotalProcessorTime.Hours
```
Richtig:


```
Get-Process | ft ProcessName, { $_.TotalProcessorTime.Hours }
```
8.12 Ausgabe von Methodenergebnissen

und Unterobjekten in

Zeichenketten

Wenn man eine Zeichenkette konstruieren möchte, dann ist die Syntax
bei der Ausgabe von Unterobjekten und Methodenergebnissen etwas
anders. Man muss den Ausdruck in $(... ) einbetten.

Gegeben sei folgendes Beispiel:

```
Listing 8.2 Anwendung von $(... )
# Der Prozess, der am meisten Speicher braucht
$p = Get-Process | Sort-Object -Property WorkingSet 64 - Descendi
ng | Select-Object
```
- First 1
# Ausgabe Versuch 1: falsch
"Der Prozess $p.name braucht am meisten Speicher, nämlich [INT]
($p.WorkingSet 64 /
1 MB) !"
# Ausgabe Versuch 2: falsch
"Der Prozess {$p.name} braucht am meisten Speicher, nämlich {[I
NT] ($p.WorkingSet 64 /
1 MB)} !"
# Ausgabe Versuch 3: richtig
"Der Prozess $($p.name) braucht am meisten Speicher, nämlich
$([INT]
($p.WorkingSet 64 / 1 MB)) MB !"


Hier liefert nur der dritte Versuch das gewünschte Ergebnis. Bei Versuch
1 und 2 wird der Ausdruck ausgegeben statt ausgewertet.

```
HINWEIS: Die abweichende Schreibweise zwischen Pipelines
(siehe vorheriges Unterkapitel) und Zeichenketten ist
notwendig, da {..} in Zeichenketten schon Platzhalter für den
Formatoperator darstellt. In folgendem Fall (Einsatz von -f) ist
$(...) nicht notwendig:
```
```
# Ausgabe Versuch 4
```
"Der Prozess {0} braucht am meisten Speicher, nämlich {1} MB !"

- f $p.name, [INT] ($p.WorkingSet64/1MB)

8.13 Unterdrückung der Ausgabe

Die Existenz der Standardausgabe sorgt dafür, dass alle Rückgabewerte
von Commandlet-Pipelines auch ausgegeben werden. Dies ist nicht
immer erwünscht.

Es gibt vier Alternativen, die Ausgabe der PowerShell zu unterdrücken:

```
Am Ende der Pipeline wird Out-Null verwendet:
Commandlet | Commandlet | Out-Null
```
```
Das Ergebnis der Pipeline wird einer Variablen zugewiesen:
$a = Commandlet | Commandlet
```
```
Das Ergebnis der Pipeline wird auf den Typ [void] konvertiert:
[void] (Commandlet | Commandlet)
```

Das Ergebnis der Pipeline wird an $null zugewiesen:

```
$null = Commandlet | Commandlet
```
8.14 Ausgaben an Drucker

Ausgaben zum Drucker sendet man mit dem Commandlet Out-Printer.
Bei -Name muss der vollständige Druckername des Druckers, der zur
Ausgabe verwendet werden soll, angegeben werden. Ohne diesen
Parameter erfolgt die Ausgabe auf dem Standarddrucker.

Beispiele:

```
Ausgabe der Prozessliste auf den Standarddrucker:
Get-Process | Out-Printer
```
```
Ausgabe der Prozessliste auf einen bestimmten Drucker:
Get-Process | Out-Printer "HP LaserJet on PC142"
```
```
Ausgabe der Liste der angehaltenen Windows-Systemdienste auf
einen bestimmten Drucker (PDF-Generator):
Get-Service | Where-Object status -eq stopped | Out-Printer -Na
me "PDF redirect v2"
```

```
HINWEIS: In PowerShell 1 und 2 würde die letzte Befehlszeile
nicht laufen, weil hier die verkürzte Schreibweise für einfache
Bedingungen bei Where-Object zum Einsatz kommt, die
Microso erst mit PowerShell 3 eingeführt hat.
Das Commandlet Out-Printer funktioniert auch in PowerShell 7
nur unter Windows, nicht auf Linux und macOS.
```
8.15 Ausgaben in Dateien

Mit Out-File schreibt man den Inhalt in eine Datei. Alternativ kann man
Ausgaben an Dateien durch Umleitung senden (siehe nächster
Abschnitt).

Beispiele:

```
Ausgabe der Prozessliste in eine Textdatei (mit Überschreiben des
bisherigen Inhalts):
Get-Process | Out-File "x:\prozessliste.txt"
```
```
Ausgabe der Prozessliste in eine Textdatei (Anhängen an bisherigen
Inhalt):
Get-Process | Out-File "x:\prozessliste.txt" - Append
```
8.16 Umleitungen (Redirection)

Zusätzlich zu den Ausgabe-Commandlets besitzt die PowerShell (wie
andere Shell-Sprachen) die Möglichkeit, Ausgaben umzuleiten. Der


Umleitungsoperator ist > (Ersetzen) bzw. >> (Anhängen) und kann in
verschiedenen Varianten verwendet werden:

> Umleitung der Pipeline-Ausgabe

2 > Umleiten der Ausgabe von Fehlern

```
3 > Umleiten der Ausgabe von Warnungen (seit PowerShell-Version
3.0!)
```
```
4 > Umleiten der Ausgabe von Verbose-Texten (seit PowerShell-
Version 3.0!)
```
```
5 > Umleiten der Ausgabe von Debug-Texten (seit PowerShell-
Version 3.0!)
```
*> Umleiten aller Ausgaben (seit PowerShell-Version 3.0!)

```
TIPP: Die nach > gezeichnete Datei wird von dem neuen Inhalt
überschrieben.
Wenn Sie den Inhalt anhängen wollen, so verwenden Sie >>.
```
Die Dateiliste von u:\Daten wird als Tabelle formatiert in eine Datei
ausgegeben. Eventuell auretende Fehler (z. B. Verzeichnis nicht
vorhanden) werden an eine andere Datei angehängt.

```
dir u:\Daten 2 >> x:\fehler.txt | Format-Table >X:\prozessliste.
txt
```

```
TIPP: Man kann auch einen Ausgabestrom auf einen anderen
Strom umleiten. Dies erfolgt mit der Syntax x>&y, wobei x die
Nummer des sendenden Streams und y die Nummer des
Streams, der die Daten empfängt, ist.
BEISPIEL: Alle Fehlerausgaben werden in die Pipe-Ausgabe
umgeleitet und landen daher mit in Prozessliste.txt:
```
```
dir u:\Daten 2 >&1 | Format-Table >X:\prozessliste.txt
```
8.17 Fortschrittsanzeige

Das Commandlet Write-Progress bietet eine Fortschrittsanzeige. Die
Fortschrittsanzeige ist in der Standardkonsole textbasiert und in der ISE
grafisch. Der Fortschritt kann dabei in -Status rein textbasiert
angegeben werden; dann gibt es keinen Fortschrittsbalken. Für den
Fortschrittsbalken muss man -PercentComplete (eine Zahl zwischen 0
und 100) angeben


```
Listing 8.3 Einsatz von Write-Progress beim Kopieren von Dateien auf mehrere Computer
[1_Basiswissen\Ausgaben\Fortschritt.ps1]
$quelle = "w:\projekte"
$liste = "PC12","PC23","PC34","PC56","PC67"
$count = 0
foreach($pc in $liste)
{
$count++
$prozent = ($count / $liste.Count)* 100
Write-Progress -Activity $pc -Status "Kopiere Dateien" - Percent
Complete $prozent
Copy-Item $quelle "\\$pc\Projekte"
}
```
Bild 8.17 Textbasierte Fortschrittsanzeige in der Standardkonsole

Bild 8.18 Grafische Fortschrittsanzeige in der ISE

8.18 Sprachausgabe

Windows bietet Sprachausgabe und dies kann auch über die
PowerShell angesteuert werden. Die PSCX bieten dafür das


Commandlet Out-Speech:

```
"An error has occurred" | Out-Speech
```
Wer mehr Kontrolle über die Sprachausgabe will, muss die Klasse
System.Speech.Synthesis. SpeechSynthesizer aus der .NET-
Klassenbibliothek oder die COM-Klasse SAPI.SPVoice verwenden. Das
folgende PowerShell-Skript spricht einen Text in allen verfügbaren
Stimmen für das amerikanische

Englisch (Sprachkürzel "en-us") aus.

```
HINWEIS: Das folgende Listing ist ein Vorgriff auf Inhalte, die
später im Kapitel "Verwendung von .NET-Klassen" noch genauer
erörtert werden.
```

Listing 8.4 Sprachausgabe
[1_Basiswissen\Ausgaben\Sprachausgabe.ps1]

```
# Mehr Kontrolle über die Sprachausgabe via .NET FCL
Add-Type -Assembly System.Speech -ErrorAction Stop
```
```
$text = "Es ist ein Fehler passiert am " + (Get-Date)
$synth = New-Object -TypeName 'System.Speech.Synthesis.SpeechSy
nthesizer'
```
- ErrorAction Stop

```
$sprache = [System.Globalization.CultureInfo]::new("de-de")
$voices = $synth.GetInstalledVoices($sprache)
foreach($voice in $voices)
{
"Geschlecht: " + $voice.voiceinfo.Gender
$synth = New-Object -TypeName 'System.Speech.Synthesis.SpeechSy
nthesizer'
```
- ErrorAction Stop
$synth.SelectVoiceByHints($voice.voiceinfo.Gender)
$synth.Speak($text) | Out-Null
}


###### 9 Das PowerShell-

###### Navigationsmodell (PowerShell

###### Provider)

Neben dem Objekt-Pipelining wartet die PowerShell noch mit einem
interessanten Administrationskonzept auf: dem einheitlichen
Navigationsparadigma für alle Arten von Datenmengen. Beim Aufruf des Befehls
Get-PSDrive zeigen sich nicht nur die erwarteten Laufwerke, sondern auch
Umgebungsvariablen (env), die Registrierungsdatenbank (HKCU, HKLM), der
Windows-Zertifikatsspeicher (cert), die PowerShell-Aliase (Alias), PowerShell-
Variablen (Variable) und PowerShell-Funktionen (Function). Die PowerShell
fasst auch diese Daten als Laufwerke auf. Konsequenterweise muss man beim
Aufruf auch einen Doppelpunkt verwenden: Get-ChildItem Alias: listet genau
wie Get-Alias alle definierten Aliase auf.

9.1 Einführungsbeispiel: Navigation in der

Registrierungsdatenbank

In der Registrierungsdatenbank kann der Administrator somit mit den gleichen
Befehlen wie im Dateisystem arbeiten. Beispiele für gültige
Registrierungsdatenbankbefehle sind:

```
Navigation zu HKEY_LOCAL_MACHINE/Soware:
cd hklm:\software
```
```
Kurzform für:
```

```
Set-Location hklm:\software
```
Auflisten der Unterschlüssel des aktuellen Schlüssels:

```
Dir
```
```
Kurzform für:
Get-ChildItem
```
Erzeugen eines Unterschlüssels mit Namen "IT-Visions":

```
md IT-Visions
```
Erzeugen eines Unterschlüssels mit einem Standardwert:

```
New-Item -Name "Website" - Value "www.IT-Visions.de" - type String
```

Bild 9.1 Navigation in und Manipulation der Registrierungsdatenbank

9.2 Provider und Laufwerke

Get-PSDrive zeigt an, dass es verschiedene "Laufwerk"-Provider gibt. Die
Festplatten gehören zum Provider "FileSystem" (FS). Microso nennt die
Provider "Navigation Provider" oder "Commandlet Provider" und will alle
Datenmengen, egal ob flach oder hierarchisch, mit den gleichen Basisverben
(Get, Set, New, Remove etc.) behandeln. Sowohl die Menge der Provider als auch
die Menge der Laufwerke sind erweiterbar.


In der Windows PowerShell 5.1 und PowerShell 6/7 für Windows sind folgende
Laufwerke im Standard enthalten:

```
Windows-Dateisystem (A:, B:, C:, D:, E: etc.)
Windows-Registrierungsdatenbank (HKCU:, HKLM:)
Windows-Umgebungsvariablen (env:)
Windows-Zertifikatsspeicher (cert:)
Funktionen der PowerShell (function:)
Variablen der PowerShell (variable:)
Aliase der PowerShell (alias:)
WSMan-Konfiguration für den WS-Management-Dienst (wsman:)
```
Optional durch Zusatzmodule gibt es zum Beispiel folgende Laufwerke:

```
Active Directory (ad:) – wenn das Active-Directory-PowerShell-Modul aktiv
ist (siehe dazu Kapitel "Active Directory" in Buchteil III)
IIS-Webserver (iis:) – wenn das Modul "WebAdministration" aktiv ist (siehe
dazu Kapitel "Internet Information Server (IIS)" in Buchteil III)
Microso SQL Server (sqlserver:) – wenn das Modul "SQLPS" aktiv ist (siehe
dazu Kapitel "Microso SQL Server-Administration" in Buchteil III)
```

Bild 9.2 Aus Sicht der PowerShell sind Laufwerke auch die Umgebungsvariablen, die Aliase und die
Registrierungsdatenbankeinträge.

Die folgende Abbildung zeigt die in Linux und macOS verfügbaren Laufwerke.

Bild 9.3 Laufwerke in PowerShell 7 unter Ubuntu 16.04

Auch das Active Directory kann man diesem Navigationsparadigma
unterwerfen. In den frühen Beta-Versionen der PowerShell war ein Provider
dafür auch enthalten; er hat es aber nicht in die endgültige Version gescha.
Der Active-Directory-Provider ist jetzt aber als Modul über die Remote Server
Administration Tools (RSAT) bzw. als Bestandteil der Serverrolle Active Directory
Directory Services (AD DS) enthalten bzw. für das alte PowerShell 1.0 als Teil der
PowerShell Community Extensions (PCSX) erhältlich.


TIPP: Die installierten Provider sieht man mit Get-PSProvider.


Tabelle 9.1 Verfügbare PowerShell-Provider

```
Provider Quelle Laufwerke Verfügbar
in
PowerShell
Core
```
```
Alias PowerShell seit 1.0 Alias Ja
```
```
Environment PowerShell seit 1.0 Env Ja
```
```
Filesystem PowerShell seit 1.0 A, B, C, D
etc.
```
```
Ja ( / unter
Linux und
macOS)
```
```
Function PowerShell seit 1.0 Function Ja
```
```
Registry PowerShell seit 1.0 HKLM,
HKCU
```
```
Nur unter
Windows
```
```
Variable PowerShell seit 1.0 Variable Ja
```
```
Certificate PowerShell seit 1.0 cert Nur unter
Windows
```
```
RSS-Feedstore PCSX
[GITHUB.COM/PSCX/PSCX]
```
```
Feed Nein
```
```
Assemblycache PCSX
[GITHUB.COM/PSCX/PSCX]
```
```
Gac Nein
```
```
Directoryservices PCSX
[GITHUB.COM/PSCX/PSCX]
```
```
(NT-4.0-
kom-
patbiler
Name der
Domäne)
```
```
Nein
```
```
Active Directory Active-Directory-
PowerShell-Modul in
Windows Server seit
```
```
AD: Nein
```

```
Version 2008 bzw. im
Microso Remote Server
Administration Tools
(RSAT) seit Windows 7
```
```
WebAdministration
(Internet
Information
Server)
```
```
Active-Directory-
PowerShell-Modul in
Windows Server seit
Version 2008 R 2 bzw. im
Microso Remote Server
Administration Tools
(RSAT) seit Windows 7
```
```
IIS: Nein
```
```
SQLPS (Microso
SQL Server)
```
```
Microso SQL Server seit
Version 2008, Modul
SQLPS
```
```
SQLSERVER: Nein
```
9.3 Navigationsbefehle

Zur Navigation stehen folgende Befehle zur Verfügung:


Tabelle 9.2 Navigationsbefehle

```
Commandlet (mit
Aliase(n))
```
```
Funktion
```
```
Get-Location (pwd) Abrufen des aktuellen Standorts
```
```
Set-Location (cd) Festlegung des aktuellen Standorts
```
```
Get-Item (gi) Holt ein Element
```
```
Get-ChildItem (dir, ls, gpi) Auflisten der Unterelemente
```
```
Get-Content (type, cat,
gc)
```
```
Abruf eines Elementinhalts
```
```
Set-Content (sc) Elementinhalt festlegen
```
```
Add-Content (ac) Elementinhalt ergänzen
```
```
New-Item (ni, mkdir) Erstellen eines Elements (Ast oder Blatt)
```
```
Get-ItemProperty (gp) Attribut abrufen
```
```
Set-ItemProperty (sp) Attribut eines Elements festlegen bzw. anlegen,
wenn nicht vorhanden
```
```
Remove-Item (del, ri,
rmdir, rm, erase)
```
```
Element löschen
```
```
Move-Item (move, mv) Element verschieben
```
```
Copy-Item (copy, cp, cpi) Element kopieren
```
```
Rename-Item (rni, ren) Element umbenennen
```
9.4 Pfadangaben


Pfadangaben in der PowerShell unterstützen verschiedene Platzhalter,
insbesondere:

```
Ein Punkt (.) steht für den aktuellen Ordner.
Zwei Punkte (..) stehen für den übergeordneten Ordner.
Die Tilde (~) steht für das Profilverzeichnis des aktuellen Benutzers (siehe
Abbildung 9.5).
Eine eckige Klammer steht für eines der Zeichen in der Klammer.
```
Beispiel: Der folgende Befehl listet alle Dateien aus dem Windows-Verzeichnis
auf, die mit a, b, c oder w beginnen: Get-ChildItem c:\windows\[abcw]*.*.

Alternativ kann man dies auch schreiben: Get-ChildItem c:\windows\[a-cw]*.*.

Es gibt mehrere Commandlets, die Unterstützung bei der Navigation in
PowerShell-Laufwerken bieten.

Test-Path prü, ob es einen Pfad gibt. Das Ergebnis ist True oder False
(System.Boolean).

```
Test-Path w:\temp
Test-Path HKLM:\software\IT-Visions
```
Resolve-Path löst Platzhalter in Pfadangaben auf und gibt den resultierenden
Pfad als ein Objekt vom Typ System.Management.Automation.PathInfo zurück.


Bild 9.4 Einsatz von Platzhaltern

Bild 9.5 Einsatz von Resolve-Path


Viele Commandlets geben Pfadangaben des Typs
System.Management.Automation.PathInfo aus. Um dies in eine einfache
Zeichenkette (die allerdings dann providerspezifisch ist) umzusetzen, steht das
Commandlet Convert-Path zur Verfügung.

9.5 Beispiel

Das folgende Listing zeigt ein Skript, das eine Hierarchie von Schlüsseln in der
Registrierungsdatenbank ablegt. Dabei wird absichtlich die einfache Addition
von Zahlen in eine Unterroutine gekapselt, um die Rückgabe von Werten an den
Aufrufer mit der return-Anweisung zu zeigen. Literale und Ausdrücke, die ohne
Commandlet im Skript enthalten sind, werden an der Konsole ausgegeben.


Listing 9.1 Ein PowerShell-Skript zur Manipulation der Registrierungsdatenbank
[3_Einsatzgebiete/Registry/Registry_Commandlets.ps1]

```
########################################
# PowerShell-Skript
# Das Skript legt eine Schlüsselhierarchie in der Registrierungsdatenba
nk an.
# (C) Dr. Holger Schwichtenberg
########################################
```
```
# === Unterroutine, die eine Addition ausführt
function Addition
{
return $args[ 0 ] + $args[ 1 ]
}
```
```
# === Unterroutine, die einen Schlüssel in der Registrierungsdatenbank
anlegt
function CreateEntry
{
"Eintrag anlegen..."
```
```
New-Item -Name ("Eintrag #{ 0 }" - f $args[ 0 ]) - value $args[ 1 ] - type Strin
g
```

```
}
```
```
# === Hauptroutine
"PowerShell-Registrierungsdatenbank-Skript (C) Dr. Holger Schwichtenber
g 2006"
```
```
# Navigation in die Registrierungsdatenbank
cd hklm:\software
```
```
# Prüfe, ob Eintrag \software\IT-Visions vorhanden
$b = Get-Item IT-Visions
if ($b.childName -eq "IT-Visions")
{ # Lösche vorhandenen Eintrag mit allen Unterschlüsseln
"Schluessel existiert bereits, loesche..."
cd hklm:\software
del IT-Visions -force -recurse
}
# Erzeuge neuen Eintrag "IT-Visions"
"Erzeuge IT-Visions..."
md IT-Visions
cd IT-Visions
```
```
# Lege Unterschlüssel an
for($a=1;$a -lt 5;$a++)
{
$ergebnis = Addition $a $a
CreateEntry $a $ergebnis
}
```
9.6 Eigene Laufwerke definieren

Das Navigationsmodell der PowerShell erlaubt die Definition eigener Laufwerke,
die dann als Abkürzung verwendet werden können.

Der folgende Befehl definiert ein neues Laufwerk "Skripte:" als Alias für einen
Dateisystempfad:


```
New-PSDrive -Name Skripte -PSProvider FileSystem -Root "x:\Skripte\ps\"
```
Danach kann man mit

```
Dir Skripte:
```
auf den Pfad zugreifen.

```
ACHTUNG: Das neu definierte Laufwerk funktioniert nur innerhalb der
PowerShell und ist nicht in sonstigen Windows-Anwendungen verfügbar.
Genau genommen funktioniert das neue Laufwerk sogar nur innerhalb
der aktuellen Instanz der PowerShell. Zwei PowerShell-Fenster teilen
sich nicht solche Deklarationen!
```
Auch für die Registrierungsdatenbank kann man solche Abkürzungen definieren:

```
New-PSDrive -Name Software -PSProvider Registry -Root HKLM:\SOFTWARE\Mi
crosoft\
Windows\CurrentVersion\Uninstall
```
Die Anzahl der PowerShell-Laufwerke ist im Standard auf 4096 beschränkt. Dies
kann durch die Variable $MaximumDriveCount geändert werden.


# 10 Fernausführung

# (Remoting)

Eine der schmerzlich vermissten Funktionen in der ersten
Windows PowerShell (Version 1.0) war die generelle
Unterstützung für Fernzugriffe auf andere Systeme bzw.
Fernverwaltung von entfernten Systemen. Mit den Bordmitteln
der PowerShell 1.0 konnte man im Wesentlichen nur über WMI
via Distributed COM (DCOM) Daten von anderen Systemen
abrufen. Eine generelle Möglichkeit zur Fernausführung von
Commandlets und Skripten gab es nicht. Hier hat Microso nun
in der Version 2.0 deutlich nachgebessert.

Seit PowerShell 2.0 gibt es über das Protokoll WS-Management
(kurz: WS-Man) die Fernausführungsmöglichkeit ("PowerShell
Remoting" via "PowerShell Remoting Protocol" (PSRP)) für
einzelne Commandlets und ganze Skripte.

WS-Management ist ein Netzwerkprotokoll auf Basis von XML-
Webservices unter Verwendung des Simple Object Access
Protocol (SOAP). WS-Management dient dem Austausch von
Verwaltungsinformationen zwischen (heterogenen)
Computersystemen. WS-Management ist ein Standard der


Desktop Management Task Force (DMTF), der im Jahr 2006
verabschiedet wurde.

WS-Management bietet eine enge Verbindung zum Web Based
Enterprise Management (WBEM) alias Windows Management
Instrumentation (WMI).

Microso bietet eine Implementierung von WS-Management
unter dem Namen "Windows Remote Management" (WinRM) seit
Windows XP und Windows Server 2003.

In Vista und Windows Server 2008 ist die Version 1.1 der
Implementierung enthalten. Windows 7 und Windows Server
2008 R 2 enthalten Version 2.0. Für Windows XP, Windows Vista
sowie Windows Server 2003 (inkl. R2) und Windows Server 2008
gibt es ein Add-on für WinRM v 2 mit Namen "Windows
Management Framework". Seit Windows 8.x und Windows Server
2012 (inkl. R2) gibt es WinRM 3.0, das es auch als Add-on für
Windows 7 und Windows Server 2008/2008 R 2 gibt
[http://www.microso.com/en-us/download/details.aspx?id=](http://www.microso.com/en-us/download/details.aspx?id=) 34595.

Für einen Fernaufruf müssen sowohl der lokale (der Aufrufer, der
Client) als auch der entfernte Computer (der Aufgerufene, der
Server) Windows Remote Management (WinRM) ab Version 2.0
unterstützen. Außerdem muss die PowerShell (ab Version 2.0) auf
beiden Systemen installiert sein. WinRM benutzt im Standard die
Ports 5985 (HTTP) und 5986 (HTTPS). Die Authentifizierung
erfolgt im Normalfall über Kerberos, alternativ sind auch
Basisauthentifizierung, Digest und NTLM möglich.

Die Verbindung zwischen Client und Server kann permanent oder
temporär sein.

Mit PowerShell Remoting ist nicht nur ein Fernaufruf eines
Computers, sondern auch gleichzeitig mehrerer Computer


möglich. So kann man z. B. ein Skript gleichzeitig auf mehreren
entfernten Systemen starten.

```
HINWEIS: Das Remoting in PowerShell 7 wird im Kapitel
zur PowerShell Core 7 besprochen.
```
###### 10.1 RPC-Fernabfrage ohne WS-

###### Management

Einige Commandlets in der PowerShell besitzen eingebaute
Fernabfragemöglichkeiten abseits von WS-Management. Diese
Commandlets haben einen Parameter "-Computername" und die
Fernaufrufmöglichkeiten des Betriebssystems, die auf einem
Remote Procedure Call (RPC) basieren.

Folgende Commandlets besitzen den Parameter "-
Computername" und arbeiten mit DCOM:

```
Clear-EventLog
Limit-EventLog
Get-Counter
New-EventLog
Get-EventLog
Remove-EventLog
Get-HotFix
```

```
Restart-Computer
Get-Process
Show-EventLog
Get-Service
Show-Service
Get-WinEvent
Stop-Computer
Get-WmiObject (schon in PowerShell 1.0 vorhanden)
Write-EventLog
```
Der Fernaufruf mit vorgenannten Commandlets funktioniert
auch, wenn WS-Management nicht installiert und konfiguriert ist.

TIPP: Derartige Commandlets findet man mit:

```
Get-Command | where { $_.parameters.keys -contains
"ComputerName"
```
- and $_.parameters.keys -notcontains "Session"}

Der folgende Befehl ermittelt vom Computer "F170" alle Dienste,
die mit dem Buchstaben "i" beginnen.

```
Get-Service -ComputerName F 170 i*
```
Die Abfrage mehrerer Computer ist nur nacheinander durch
Übergabe in der Pipeline möglich, da man bei diesen


Commandlets bei Computername kein Array als solchen übergeben
kann.

Falsch:

```
Get-Service -ComputerName F173, F 170 i*
```
Richtig:

```
"F171", "F172", "F173" | % { Get-Service i* - ComputerName
$_ }| ft Name, status,
```
- machinename

Über das Attribut MachineName kann man jeweils sehen, welcher
der abgefragten Computer das Ergebnis geliefert hat.

Bild 10.1 Abfrage der Dienste auf zwei Computern

###### 10.2 Anforderungen an PowerShell

###### Remoting


Für einen Fernaufruf via PowerShell Remoting Protocol (PSRP)
müssen sowohl der lokale (der Aufrufer, der Client) als auch der
entfernte Computer (der Aufgerufene, der Server) folgende
Voraussetzungen erfüllen:

```
Microso .NET Framework 2.0 oder höher
Windows PowerShell 2.0 oder höher
Windows Remote Management (WinRM) 2.0 oder höher
```
Bild 10.2 Der WinRM-Dienst in der Diensteliste von Windows

###### 10.3 Rechte für PowerShell-

###### Remoting


Fernaufrufe sind sowohl domänenintern als auch
domänenübergreifend (durch Vertrauensstellungen oder gleiche
Benutzername-Kennwort-Kombination) möglich, im zweiten Fall
allerdings nur unter expliziter Angabe von Benutzernamen und
Kennwort, selbst wenn auf dem Zielsystem eine zu dem
aufrufenden System identische Benutzername-Kennwort-
Kombination existiert. Fernaufrufe können nur Benutzer
ausführen, die auf dem Zielsystem zur Administratorengruppe
gehören. Man kann das Recht zum Fernaufruf durch Änderung
der sogenannten Sitzungskonfigurationen steuern.

Auch auf dem lokalen Computer werden Administratorrechte für
einige Aktionen im Zusammenhang mit dem Fernaufruf benötigt.
Dies sind insbesondere die Einrichtung von WS-Management und
die Konfiguration von PowerShell-Sitzungen. Auch ein Fernaufruf
gegen den eigenen Computer ("Loopback-Aufruf") erfordert
Administratorrechte.

###### 10.4 Einrichten von PowerShell

###### Remoting

Im Auslieferungszustand der PowerShell sind PowerShell-
Fernaufrufe deaktiviert. Mit Enable-PSRemoting konfiguriert man
einen Computer zum Empfang von Fernaufrufen von anderen
Rechnern. Dieser Befehl startet den WinRM-Systemdienst
(Listener), konfiguriert die Windows PowerShell und trägt das
Protokoll WS-Management als Ausnahme in der Windows
Firewall ein. Enable-PSRemoting ist nicht notwendig auf
Computern, die nur (!) PowerShell-Befehle an andere Rechner


senden wollen. Zum Ausführen von Enable-PSRemoting muss man
auf dem System Administrator sein.

Bild 10.3 Erstkonfiguration von PowerShell Remoting mit Enable-PSRemoting

TIPP: Zum Unterdrücken der Nachfragen geben Sie ein:

```
Enable-PSRemoting -force
```
Zum Testen der Einrichtung geben Sie ein:

```
New-PSSession
```
Dann sollte das nachstehende Ergebnis erscheinen.


Bild 10.4 Testen der Fernverbindungskonfiguration mit New-PSSession

```
HINWEIS: In Domänen kann WinRM über die
Gruppenrichtlinie "Computer
Configuration\Administrative Templates\Windows
Components\Windows Remote Management
(WinRM)\WinRM service" konfiguriert werden.
```
Ein Problem bei der Einrichtung könnte sein, dass diese mit der
Fehlermeldung "Set-WSManQuickConfig : WinRM firewall
exception will not work since one of the network connection
types on this machine is set to Public. Change the network
connection type to either Domain or Private and try again."
abbricht. Ein Blick in das Netzwerkcenter von Windows wird
dann zeigen, dass es tatsächlich ein "Public"-Netzwerk gibt
(siehe Beispiel im Bild).


Bild 10.5 "Public Network" verhindert die Einrichtung des PowerShell Remoting.

Lösen kann man dies über secpol.msc (siehe nächste Abbildung).

Bild 10.6 Lösung des "Public Network"-Problems


```
TIPP: Seit PowerShell Version 4.0 kann man alternativ
beim Enable-PSRemoting-Commandlet auch den
Parameter SkipNetworkProfileCheck angeben, wodurch
die Prüfung auf das Netzwerkprofil entfällt.
```
Zum Deaktivieren des PowerShell Remoting gibt es das
Commandlet:

```
Disable-PSRemoting
```
Durch Disable-PSRemoting wird der WinRM-Dienst aber nicht
beendet.

###### 10.5 Überblick über die

###### Fernausführungs-

###### Commandlets

Die wichtigsten Commandlets für PowerShell Remoting sind:

```
Enter-PSSession: Starten einer Fernausführungssitzung im
Telnet-Stil
Invoke-Command: Fernausführung eines einzelnen PowerShell-
Commandlets oder eines Skripts
New-PSSession: Erstellen einer permanenten Verbindung für
die Fernausführung
```

Alle oben genannten Commandlets bieten ein Attribut -
Computername. Bei Enter-PSSession kann man nur einen Computer
angeben, bei Invoke-Command und New- PSSession auch ein Array
mehrerer Computer.

```
HINWEIS: Im Standard vorgesehen ist die Angabe von
Computernamen. IP-Adressen können alternativ
verwendet werden, erfordern aber ein anderes
Authentifizierungsverfahren, da das im Standard
verwendete Kerberos keine IP-Adressen unterstützt (siehe
Unterkapitel "Zugriff auf entfernte Computer außerhalb
der eigenen Domäne").
```
###### 10.6 Interaktive Fernverbindungen

###### im Telnet-Stil

Mit dem Commandlet Enter-PSSession eröffnet man eine
interaktive Sitzung zu einem entfernten System im Stil des
Telnet-Protokolls. Anzugeben ist der Computername, z. B.

```
Enter-PSSession -Computername F 170
```
Nach erfolgreicher Ausführung des Befehls wird der
Computername vor der PowerShell-Eingabeaufforderung
angezeigt. Alle eingegebenen Befehle werden nun auf dem
entfernten System ausgeführt. Alle Ausgaben landen auf dem
lokalen System.


Testen kann man zum Beispiel, indem man mit
[System.Environment]::MachineName den Computernamen abru.

Bild 10.7 Aufbau einer interaktiven Fernsitzung, hier von PowerShell 7.2 zu einem
älteren System mit Windows PowerShell 4.0

HINWEIS: Man kann sich in einer interaktiven Sitzung immer nur
mit genau einem entfernten System verbinden. Man kann aber
auf einem System mehrere Power-Shell-Fenster öffnen und sich
darin mit jeweils einem anderen entfernten System verbinden.


Möglichkeiten einer Fernsitzung

In einer Fernsitzung kann jegliche Form von Änderungen
durchgeführt werden, sowohl durch Ausführung von
Commandlets, z. B.

```
(Get-service BITS) | start-service
```
als auch durch den Aufruf von Methoden

```
(Get-service BITS).Start()
```
Man kann auch Windows-Prozesse starten. Zu beachten ist
jedoch, dass man auf dem entfernten System
Benutzeroberflächen von diesen Prozessen nicht sehen kann,
selbst wenn man dort lokal angemeldet ist.

Zum Verlassen der Fernsitzung gibt man ein:

```
Exit-PSSession
```
###### 10.7 Fernausführung von Befehlen

Um einen einzelnen Befehl auf einem entfernten System
auszuführen, kann man auch das Commandlet Invoke-Command
mit dem Parameter -Computername verwenden. Beim Parameter -
ScriptBlock kann man einen oder mehrere (durch
Zeilenumbruch oder Semikolon getrennte) Befehle angeben und
auch Pipelines nutzen. Nicht nur Commandlets, auch klassische
Kommandozeilenbefehle sind möglich.


```
Listing 10.1 [1_Basiswissen\Remoting\WPS2_Remoting_Script.ps1]
Invoke-Command -ComputerName F 170 - scriptblock { Get-Servi
ce b* }
Invoke-Command -ComputerName F 170 - scriptblock { Get-Servi
ce | Sort-Object status |
ft name, status }
Invoke-Command -computer F 170 - Scriptblock { "Computernam
e: " + [System.
Environment]::MachineName ; "Zeit: " + [DateTime]::Now ;
"Sprache: " +
(Get-Culture) }
Invoke-Command -computer F 170 - Scriptblock { ping http://www.it-
visions.de }
```
Natürlich kann man den Skriptblock vorher auch in einer
Variablen speichern.

```
Listing 10.2 [1_Basiswissen\Remoting\WPS2_Remoting_Script.ps1]
$cmd = {
"Rechnername: $([System.Environment]::MachineName)"
"Benutzername: $([System.Environment]::UserDomainname +
"\" + [System.
Environment]::Username)"
}
Invoke-Command PC 199 - ScriptBlock $cmd
```
Ein Sonderfall ist gegeben, wenn der Skriptblock unterschiedlich
für verschiedene Rechner sein soll. Dann muss der Skriptblock
mit [scriptblock]::Create() erzeugt werden.


```
Listing 10.3 [1_Basiswissen\Remoting\Remoting_DynamicScriptBlock.ps1]
$pcListe = "D140","D141"
foreach($pc in $pcListe)
{
"Abfrage bei $pc"
```
```
$scriptblock = [scriptblock]::Create( `
'"PC ' + $pc + ' nennt sich "' + `
'+ [System.Environment]::MachineName')
```
```
"Erzeugtes Skript..."
$scriptblock
"Skript wird gesendet..."
$ergebnis = Invoke-Command -ScriptBlock $scriptblock -Comp
uterName $pc
$ergebnis
}
```
```
HINWEIS: Alle Commandlets oder Anwendungen, die in
dem Skriptblock gestartet werden, müssen auf dem
Zielsystem verfügbar sein.
```
Auch hier wird das Ergebnis auf dem lokalen System angezeigt,
o mit der zusätzlichen Spalte "PSComputerName", die den
Namen des aufgerufenen Computers enthält.


Bild 10.8 Lokaler Aufruf versus entfernter Aufruf

Allerdings muss man beachten, dass die Ergebnismenge
keineswegs die gleiche Struktur wie bei einem lokalen Aufruf hat.
Die Objekte in der Pipeline sind nicht vom Typ System.
ServiceProcess.ServiceController, sondern
Deserialized.System.ServiceProcess. ServiceController.
Zwischen den Rechnergrenzen hat, für den Transport über das
Netzwerk, eine Serialisierung/Deserialisierung der Objekte
stattgefunden. Dabei sind die Methoden der Objekte "verloren"
gegangen. Methodenaufrufe wie

```
(Invoke-Command -ComputerName F 170 - scriptblock { Get-Serv
ice bits }).Start()
```

sind also nicht möglich!

Bild 10.9 Get-Member nach einem lokalen und einem entfernten Aufruf von Get-
Service


ACHTUNG: Beim Pipelining kann man in eine sehr tiefe
Falle tappen. Ein Benutzer, der merkt, dass

```
(Invoke-Command -ComputerName F 170 - scriptblock { G
et-Service Bits
}).Start()
```
nicht funktioniert, würde wohl auf

```
(Invoke-Command -ComputerName F 170 - scriptblock { G
et-Service Bits Start-
Service
```
ausweichen wollen.

Dieser Befehl würde ohne Fehlermeldung abgeschlossen

- er hätte aber nicht getan, was gewünscht war. In diesem
Fall würde der "BITS"-Dienst auf dem lokalen System,
nicht auf dem entfernten System gestartet. Der Grund
liegt darin, dass Start-Service das PSComputerName-
Attribut ignoriert und nur den Namen des Dienstes
berücksichtigt. Die folgende Abbildung liefert den Beweis.


Bild 10.10 Unerwartetes Verhalten beim Fernaufruf

Viele Commandlets funktionieren so, auch weitreichende wie
Remove-Item. Der folgende Befehl löscht also nicht Textdateien
auf dem entfernten, sondern gleichnamige Dateien auf dem
lokalen System!

```
Invoke-Command -ComputerName F 170 - scriptblock { Get-Item
d:\Daten\*.txt } | remove-
Item
```
Richtig ist hier, den Befehl Remove-Item mit in den Skriptblock zu
nehmen:

```
Invoke-Command -ComputerName F 170 - scriptblock { Get-Item
d:\Daten\*.txt | remove-
Item }
```
Grund für diese Falle ist, dass die von Get- Item gelieferten
Dateiobjekte zwar von der Power-Shell um den Parameter


PSComputername angereichert wurden, aber das Commandlet
Remove-Item diese Zusatzinformation leider ignoriert.

```
HINWEIS: Einige Commandlets in der PowerShell,
darunter Get-Process und Get-Service, bieten auch noch
einen kürzeren Weg für die Fernabfrage an. Bei diesen
Commandlets kann man ein einzelnes entferntes System
über den Parameter –Computer angeben, z. B. Get-Process
```
- Computer F 111 (Details siehe Abschnitt 10.1 "RPC-
Fernabfrage ohne WS-Management").
Vorteil dieser Methode ist, dass man dafür nicht WS-
Management benötigt, also auch ältere Betriebssysteme
abfragen kann, für die es kein WS-Management gibt.
Nachteil ist, dass sich die Fernabfrage immer nur auf den
einzelnen Befehl bezieht. Man kann weder Befehlsfolgen
noch Skripte angeben. Außerdem kann man immer nur
ein einzelnes entferntes System ansprechen.

Noch ein Tipp: Sie können auch einen Skriptblock mit
Zeilenumbrüchen an der Konsole erfassen. Dazu müssen Sie aber
innerhalb des Skriptblocks SHIFT + EINGABE drücken. Erst wenn
Sie den Skriptblock mit der schließenden geschweien Klammer
beendet haben, drücken Sie nur noch EINGABE. Wenn Sie
vorzeitig nur auf EINGABE drücken, wird der Befehl sofort
ausgeführt.


Bild 10.11 Eingabe eines Skriptblocks mit Umbrüchen an der Konsole

###### 10.8 Parameterübergabe an die

###### Fernausführung

O braucht der auf dem entfernten System auszuführende
Skriptblock Werte, die der aufrufende Computer besitzt. Das
erste Beispiel zeigt, wie es falsch ist. $VM und $Path sind leer bei
der Ausführung auf Server79.

```
$VM = "D140"
$Path = "\\D 123 \backup"
```
```
Invoke-Command -ComputerName Server 79 - ScriptBlock {
# falsch. $VM ist leer !!!
"Sichern der VM $vm nach $Path..."
}
```
Richtig ist, den Inhalt von $VM und $Path per Parameter -
Argumentlist an Invoke-Command zu übergeben und dann in dem


fernauszuführenden Skriptblock darauf mit $args[ 0 ] und
$args[ 1 ] zuzugreifen.

```
$VM = "D140"
$Path = "\\D 123 \backup"
#richtig!
Invoke-Command -ComputerName Server 79 - ArgumentList $vm,$P
ath -ScriptBlock {
$VM = $args[ 0 ]
$Path = $args[ 1 ]
"Sichern der VM $vm nach $Path..."
}
```
###### 10.9 Fernausführung von Skripten

Mit Invoke-Command kann man natürlich ein auf dem entfernten
System vorhandenes Skript starten, z. B.:

```
Invoke-Command -computer F 170 - scriptblock { d:\Skripte\WP
S2_Computername.ps 1 }
```
Voraussetzung ist natürlich, dass auf dem entfernten System die
Skriptausführung erlaubt ist und alle für das Skript benötigten
Dateien dort sind.


Bild 10.12 Fehlermeldung, wenn das Starten des Skripts auf einem entfernten
System nicht erlaubt ist

Mit folgendem Befehl kann man die Skriptausführung auf einem
entfernten System aktivieren:

```
Invoke-Command -computer F 170 - scriptblock { Set-execution
policy unrestricted }
```
Das folgende Listing zeigt ein Beispiel, bei dem man die
Skriptausführung aktiviert, ein Skript kopiert, dann ausführt und
anschließend das Skript löscht und die Skriptausführung wieder
deaktiviert.


Listing 10.4 Entfernte Skriptausführung durch Skriptkopieren
[1_Basiswissen/Remoting/WPS2_Remoting_Script.ps1]

```
$computer = "PC170"
$lokalesSkript = "X:\ 1_Basiswissen\Remoting\WPS2_Computer
name.ps1"
"Start Session..."
$s = New-PSSession -ComputerName $computer
```
```
"Enable Script Execution on remote System..."
Invoke-Command -Session $s -scriptblock { Set-executionpol
icy unrestricted }
```
```
"Copy Script..."
Copy-Item $lokalesSkript "\\$computer\c$\temp\wps2_Compute
rname.ps1"
```
```
"Start Script..."
Invoke-Command -Session $s -scriptblock { w:\temp\WPS2_Com
putername.ps 1 }
```
```
"Delete Script..."
Remove-Item "\\$computer\c$\temp\wps2_Computername.ps1"
```
```
"Disable Script Execution on remote System..."
Invoke-Command -Session $s -scriptblock { Set-executionpol
icy default }
```
```
"End Session!"
Remove-PSSession $s
```

Das gleiche Ergebnis kann man aber auch viel einfacher haben,
denn das Commandlet Invoke-Command bietet auch die
Möglichkeit, ein lokales Skript auf den entfernten Computer zu
übertragen und dort zu starten:

```
Invoke-Command -computer PC 170 - FilePath X:\WPS2_Computern
ame.ps 1
```
###### 10.10 Ausführung auf mehreren

###### Computern

Das Commandlet Invoke-Command bietet auch die Möglichkeit,
mehrere Computer in Form eines Arrays (eine durch Komma
getrennte Liste) anzugeben.

Beispiel 1: Setzen von Datum und Uhrzeit auf mehreren
Computern:

```
Invoke-Command -computer F170, F171, F172, F 173 - Script {
Set-date -date }
```
Bild 10.13 Ausführen von Set-Date auf mehreren Computern

Beispiel 2: Auslesen von c:\Temp auf mehreren Computern


```
$computer = F170, F171, F172, F173, F 174
Invoke-Command -computer $computer { Get-ChildItem c:\temp
}
```
```
TIPP: Für den lokalen Computer kann man "localhost"
oder "." verwenden.
```
Das Ergebnis ist eine Gesamtliste der Ergebnisse von allen
genannten Computern. Die Objekte in der Menge besitzen ein
zusätzliches Attribut (NoteProperty) PSComputerName, das den
Namen des Computers zeigt, der das Objekt geliefert hat.
Dadurch ist ein Filtern/Sortieren/Gruppieren auf dem
aufrufenden Computer möglich.

```
HINWEIS: Die PowerShell fragt bei den einzelnen
Computern in der Reihenfolge an, wie sie im Array
angegeben sind. Die Reihenfolge der Ergebnisse ist jedoch
abhängig davon, wann die Ergebnisse eintreffen.
Die Anzahl der gleichzeitigen Verbindungen ist in
PowerShell im Standard auf 32 begrenzt. Er kann mit dem
Parameter -ThrottleLimit bei Invoke-Command verändert
werden.
```

Bild 10.14 Ergebnismenge eines Abrufs von Dienst-Objekten von drei Computern

```
TIPP: Bei der Ausgabe von einigen Klassen (z. B. auch bei
ServiceController) wird PSComputerName automatisch
ausgegeben. Dies kann man durch -HideComputername
unterdrücken.
```
```
Invoke-Command -Computer F170, F 171 - ScriptBlock {
Get-Service I* }
```
- HideComputername

Abbrechen eines Fernbefehls

Zum Abbrechen eines entfernt ausgeführten Befehls kann man
wie bei lokalen Befehlen die Tastenkombination STRG + C
verwenden.

###### 10.11 Sitzungen


Invoke-Command erzeugt im Standard eine temporäre Verbindung.
Alle Definitionen (Variablen und Funktionen), die im Rahmen der
Ausführung von Invoke-Command auf einem entfernten System
erzeugt wurden, sind nach Ende des Befehls wieder ungültig.

Die Alternative ist eine permanente Verbindung (Sitzung). Eine
Sitzung (engl. Session, alias "PSSession") ist Host für die
PowerShell, in der die PowerShell Befehle ausführt. Aus der Sicht
von Windows ist eine Session ein Prozess.

Eine Sitzung gestaltet man durch das Laden von Snap-ins und
Modulen sowie durch die Definition von Variablen, Funktionen
und Aliasen. Alle diese Einstellungen leben so lange, wie die
Sitzung dauert.

Beim Start der PowerShell durch powershell.exe wird
automatisch eine Sitzung erzeugt (Default Session). Durch
Commandlets kann man weitere Sitzungen auf dem lokalen
Computer oder entfernten Computern erzeugen.

```
HINWEIS: Alle Fernaufrufe der PowerShell erfolgen im
Rahmen einer Sitzung. Die PowerShell unterscheidet
temporäre Sitzungen (mit Invoke-Command unter Angabe
eines Computernamens) und permanente Sitzungen (mit
Invoke-Command unter Angabe eines Sitzungsobjekts, das
vorher mit New-PSSession erzeugt wurde).
```
10.11.1 Commandlets zur

Sitzungsverwaltung


Es folgt ein Überblick über die Commandlets zur
Sitzungsverwaltung:

```
New-PSSession: Erzeugen einer neuen Sitzung auf dem
lokalen oder einem entfernten Computer
Get-PSSession: Liste aller Sitzungen, die aus der aktuellen
Sitzung heraus gestartet wurden (zeigt aber nicht Sitzungen,
die andere Computer auf dem lokalen Computer geöffnet
haben)
Remove-PSSession: entfernt eine Session oder alle Sessions
(Remove-PSSession *)
Enter-PSSession: Start einer interaktiven Sitzung auf dem
lokalen oder einem entfernten Computer
Exit-PSSession: Ende einer interaktiven Sitzung
Disable-PSSessionConfiguration: Sperren einer/aller
Sitzungskonfigurationen
Enable-PSSessionConfiguration: Entsperren einer/aller
Sitzungskonfigurationen
Get-PSSessionConfiguration: Auflisten der
Sitzungskonfigurationen
Register-PSSessionConfiguration: permanente Registrierung
einer Sitzungskonfiguration
Set-PSSessionConfiguration: Setzen von Eigenschaen einer
Sitzungskonfiguration
Unregister-PSSessionConfiguration: Löschen einer
Sitzungskonfiguration
```

10.11.2 Sitzungen erstellen

Eine Sitzung erzeugt man über New- PSSession:

```
$s = New-PSSession -computername F 171
```
Auf diese offene Sitzung muss man im Commandlet Invoke-
Command Bezug nehmen. Ein Computername ist dann nicht mehr
erforderlich.

```
Invoke-Command -session $s -scriptblock {$p = Get-Process
}
```
Man kann auch permanente Sitzungen zu mehreren Computern
aufbauen, indem man bei New- PSSession mehrere Computer
angibt:

```
$s = New-PSSession -computername F173, D144, D 145
Invoke-Command -session $s -scriptblock {Get-culture}
```
Alternativ kann man auch mehrere einzelne Sitzungen erstellen
und diese bei Invoke-Command angeben.

```
"Sitzungen erstellen..."
$s 1 = New-PSSession -ComputerName F 173
$s 2 = New-PSSession -ComputerName D 144
$s 3 = New-PSSession -ComputerName D 145
```
```
"Fernzugriff auf alle drei Rechner..."
Invoke-Command -Session $s1, $s2, $s 3 - ScriptBlock { Get-S
ervice spooler }
```

Die PowerShell-Profilskripte werden weder in temporären noch
in permanenten Verbindungen automatisch auf dem entfernten
System geladen. Bei Bedarf müssen sie explizit gestartet werden,
z. B.:

```
Invoke-Command -session $s {. "$home\Documents\WindowsPowe
rShell\Microsoft.
PowerShell_profile.ps1"}
```
```
TIPP: Innerhalb einer Fernsitzung kann man keine
weitere Sitzung zu einem anderen System aufbauen. Es
kommt der Fehler "Sie befinden sich derzeit in einer
Windows PowerShell-PSSession und können mit dem Enter-
PSSession-Cmdlet keine andere PSSession öffnen."
```
10.11.3 Kopieren von Dateien in Sitzungen

Das Commandlet Copy-Item bietet mit dem Parameter -ToSession
eine Möglichkeit, Dateien von dem aktuellen Host via einer
geöffneten Sitzung auf ein Fernsystem zu kopieren:

```
Copy-Item -Path $setupSkript -Destination w:\temp\ - ToSess
ion $s
```
10.11.4 Schließen von Sitzungen


Sitzungen werden automatisch geschlossen, wenn die Sitzung
(Elternsitzung) beendet wird, aus der heraus die Sitzung
(Kindsitzung) gestartet wurde. Entfernte Sitzungen enden zudem
automatisch, wenn entfernte Computer für vier Minuten lang
nicht mehr erreichbar sind. Manuell kann man eine Sitzung mit
Remove-PSSession schließen.

10.11.5 Sitzungskonfigurationen

Eine Sitzungskonfiguration legt durch zahlreiche Einstellungen
fest, wer eine Sitzung aufbauen darf und welche Befehle in der
Sitzung zur Verfügung stehen. Typische Einstellungen sind:

```
Benutzer, die sich mit dem Computer entfernt verbinden
dürfen
Größe der Objekte, die die entfernten Benutzer übertragen
dürfen
Festlegung der verfügbaren Commandlets und Funktionen
```
Die Standardkonfiguration trägt den Namen
"Microso.PowerShell". Auf 64-Bit-Computern gibt es zusätzlich
"Microso.PowerShell32". Seit Windows Server 2008 R 2 gibt es
außerdem "Microso.ServerManager".

Die verfügbaren Konfigurationen mit zahlreichen Details zeigt:

```
Get-PSSessionConfiguration | fl
```
oder alternativ

```
dir wsman:localhost/plugin
```

Im Kapitel "Delegierte Administration" wird behandelt, wie man
eigene, eingeschränkte Sitzungskonfigurationen erstellen kann.

10.11.6 Zugriffsrechte für Fernaufrufe

Im Standard können nur Administratoren Fernaufrufe ausführen.
Man kann aber die Zugriffsrechteliste (Access Control List – ACL)
der Sitzungskonfiguration ändern.

```
Set-PSSessionConfiguration Microsoft.PowerShell -ShowSecur
ityDescriptorUI
```
Etwas kurios für eine kommandozeilenbasierte Shell ist, dass
sich dadurch ein Windows-Fenster öffnet, wie man es von den
Zugriffsrechtelisten von Windows Explorer und der Windows-
Registrierungsdatenbank kennt. Rein kommandozeilenbasiert
kann man arbeiten, indem man im Parameter
SecurityDescriptorSDDL eine SDDL-Zeichenkette (SDDL = Security
Descriptor Definition Language) übergibt.


HINWEIS: Das Commandlet Disable-
PSSessionConfiguration verändert die Zugriffsrechtelisten
für eine oder alle vorhandenen Sitzungskonfigurationen
so, dass kein Benutzer mehr Rechte für den Fernaufruf
hat.

```
Disable-PSSessionConfiguration -name Microsoft.Powe
rShell
```
Die Blockade kann man rückgängig machen mit Enable-
PSSessionConfiguration.


Bild 10.15 Ändern der ACL für die PowerShell-Sitzungskonfiguration

Mit Register-PSSessionConfiguration kann man eine neue
Konfiguration erzeugen. Diese wird permanent auf dem
Computer gespeichert. Der erforderliche Neustart des WS-
Management-Dienstes wird auf Nachfrage ausgeführt.

Der folgende Befehl legt eine neue Konfiguration unter dem
Namen "FBIConfig" an mit einer Erhöhung der Datenmenge auf
200 MB (Standard sind 50 MB) und einem Skript, das beim
Starten der Sitzung ausgeführt werden soll. Das Skript muss lokal
auf dem System vorhanden sein.


```
Register-PSSessionConfiguration -name FBIConfig
```
- MaximumReceivedDataSizePerCommandMB 200
- StartupScript x:\Skripte\WPS2_Remoting_SessionStartSkrip
t.ps 1

Anschließend kann man eine Sitzung mit Bezug auf diese
Konfiguration starten:

```
$s = New-PSSession -ConfigurationName FBIConfig
```
Auch Invoke-Command hat den Parameter -ConfigurationName:

```
Invoke-Command -ConfigurationName "FBIConfig" - scriptblock
{ Start-Service BITS }
```
- computer F 173

Bild 10.16 Ablauf der Registrierung einer Sitzungskonfiguration

In $PSSessionConfigurationName ist der Name der Konfiguration
abgelegt, die verwendet wird, wenn man den Parameter -
ConfigurationName nicht angibt. Den Inhalt dieser Variablen kann
man ändern.


Zum Löschen einer Konfiguration verwendet man:

```
Unregister-PSSessionConfiguration -name FBIConfig
```
###### 10.12 Implizites Remoting

Implizites Remoting ist eine weitere Form des PowerShell
Remoting, bei der für eine entfernt auszuführende PowerShell-
Funktion ein Commandlet auf dem Client als Alias verwendet
wird.

```
HINWEIS: Technisch gesehen wird dabei ein Proxy-
Commandlet verwendet. Wie man dies manuell erstellen
kann, beschreibt das Kapitel "Profiwissen/Entwicklung
von Commandlets in der PowerShell-
Skriptsprache/Erweitern bestehender Commandlets
durch Proxy-Commandlets."
```
Man erstellt eine PowerShell-Remoting-Session:

```
$session = New-PSSession PC 123
```
Man sendet dann in der Sitzung eine Funktion zu dem entfernten
System. Ausgeführt wird dadurch dort nichts.

```
Invoke-Command $session -scriptblock { function Get-Comput
erName { [System.
Environment]::MachineName }}
```

Nun kann man diese Funktion auf dem entfernten System im
Rahmen der Sitzung aufrufen:

```
Invoke-Command $session {Get-ComputerName}
```
Alternativ kann man – via Import-PSSession – das implizite
Remoting einrichten. Dadurch entsteht ein lokales Alias-
Commandlet, das aber nicht lokal ausgeführt wird, sondern im
Rahmen der Sitzung zum Fernsystem gesendet wird:

```
Import-PSSession -Session $session -CommandName Get-Comput
erName
```
Die oben gesendete Funktion auf dem fernen System kann nun
so gestartet werden, ohne Angabe der Sitzung oder des Namens
des Fernsystems:

```
Get-ComputerName
```
```
ACHTUNG: Der Einsatz von implizitem PowerShell
Remoting kann nicht zu den empfehlenswerten
Vorgehensweisen ("Best Practies") zählen, weil man dem
Commandlet nicht ansehen kann, wo es ausgeführt wird.
Das kann zu Unklarheiten führen und zu langsamen
Ausführungszeiten, die nicht direkt erkennbar sind.
```

###### 10.13 Zugriff auf entfernte

###### Computer außerhalb der

###### eigenen Domäne

Der Zugriff auf entfernte Computer außerhalb der eigenen bzw.
einer vertrauenden Domäne ist möglich.

Grundsätzlich gibt es zwei Möglichkeiten für den
domänenübergreifenden Zugriff:

```
Expliziter Eintrag des Zielsystems in die Liste vertrauter
Systeme
Einrichten von Secure Socket Layer (SSL) für die HTTP-
Kommunikation alias HTTPS
```
Herleitung des Problems

Wenn man einen domänenübergreifenden Aufruf versucht (z. B.
Enter-PSSession F 171 ), wird man auf folgende Fehler stoßen:

```
"Die Anforderung kann von WinRM nicht verarbeitet werden. Bei
Verwendung der Kerberos-Authentifizierung ist der folgende
Fehler aufgetreten: Der Netzwerkpfad wurde nicht gefunden.
Mögliche Ursachen:
Der angegebene Benutzername oder das angegebene Kennwort
ist ungültig. – Kerberos wird verwendet, wenn keine
Authentifizierungsmethode und kein Benutzername angegeben
werden.
```

```
Kerberos akzeptiert Domänenbenutzernamen, aber keine
lokalen Benutzernamen.
Der Dienstprinzipalname (Service Principal Name, SPN) für den
Remotecomputernamen und -port ist nicht vorhanden.
Der Clientcomputer und der Remotecomputer befinden sich in
unterschiedlichen Domänen, zwischen denen keine
Vertrauensbeziehung besteht.
Wenn Sie die oben genannten Ursachen überprü haben,
probieren Sie folgende Aktionen aus: – Suchen Sie in der
Ereignisanzeige nach Ereignissen im Zusammenhang mit der
Authentifizierung.
Ändern Sie die Authentifizierungsmethode; fügen Sie den
Zielcomputer der Konfigurationseinstellung ‚TrustedHosts' für
WinRM hinzu, oder verwenden Sie den HTTPS-Transport.
Beachten Sie, dass Computer in der TrustedHosts-Liste
möglicherweise nicht authentifiziert sind."
```
Dieser ausführliche Fehlertext liefert schon recht genaue
Hinweise auf das Problem: Die Authentifizierungsmethode
Kerberos funktioniert nur in Domänen. Es ist also eine andere
Authentifizierungsmethode zu wählen.

Verfügbare Standardauthentifizierungsmethoden sind Default (=
Kerberos), Basic, Negotiate (= Aushandlung zwischen Client und
Server mit dem Simple and Protected GSSAPI Negotiation
Mechanism – SPNEGA), NegotiateWithImplicitCredential,
Credssp, Digest, Kerberos.

Ein neuer Versuch könnte dann also Digest oder Basic sein, also:

```
Enter-PSSession F 171 - Authentication Digest
```

oder

```
Enter-PSSession F 171 - Authentication Basic
```
Nun lautet der Fehlertext in beiden Fällen:

```
"Der WinRM-Client kann die Anforderung nicht verarbeiten.
Wenn der Basic- oder Digest-Authentifizierungsmechanismus
verwendet wird, müssen Anforderungen den Benutzernamen
und das Kennwort enthalten. Fügen Sie den Benutzernamen
oder das Kennwort hinzu, oder ändern Sie den
Authentifizierungsmechanismus, und wiederholen Sie die
Anforderung."
```
Dies bedeutet also, dass die Daten des am lokalen System
angemeldeten Benutzers nicht automatisch übermittelt werden
(selbst wenn es auf dem Zielsystem eine gleiche Kombination
aus Benutzername und Kennwort gibt).

Nun ein dritter Versuch, wobei man Client und Server die
Authentifizierung aushandeln lässt:

```
Enter-PSSession F 171 - Authentication Negotiate -credential
F 171 \hs
```
Die PowerShell zeigt den Authentifizierungsdialog...


Bild 10.17 Authentifizierungsdialog

und dann wieder einen Fehler:

```
Der WinRM-Client kann die Anforderung nicht verarbeiten. Wenn
das Authentifizierungsschema nicht Kerberos ist oder der
Clientcomputer nicht Mitglied einer Domäne ist, muss der
HTTPS-Datentransport verwendet werden, oder der
Zielcomputer muss der TrustedHosts-Konfigurationseinstellung
hinzugefügt werden. Verwenden Sie winrm.cmd, um
TrustedHosts zu konfigurieren. Beachten Sie, dass Computer in
der TrustedHosts-Liste möglicherweise nicht authentifiziert sind.
```
Auch hier ist die Anweisung klar: Entweder ist HTTPS zu
verwenden oder aber ein Eintrag in TrustedHosts vorzunehmen.
Letzteres ist einfacher.

Eintrag in die Liste vertrauter Systeme

Diesen Eintrag kann man über den WSMan-Navigationsprovider
der PowerShell recht elegant auf dem Client vornehmen:


```
cd WSMan:\localhost\Client
Set-Item trustedhosts "F170, F171, F172, F173, F174, F175"
```
- force
Restart-Service winrm

Alternativ können auch IP-Adressen statt Rechnernamen
angegeben und bestehende Werte ergänzt werden:

```
Listing 10.5 [Basiswissen\Remoting\WPS2_WSRM_TrustedHosts.ps1]
$IP = "192.168.1.197"
cd WSMan:\localhost\Client
$alt = Get-Item trustedhosts
"Alt: " + $alt.Value
Set-Item trustedhosts $ip -force -Concatenate
Restart-Service winrm
$neu = Get-Item trustedhosts
"Neu: " + $neu.Value
```
Die Veränderungen der Eigenscha TrustedHosts" erfordern
eigentlich eine Rückbestätigung, daher das -force.
TrustedHostist eine Liste der zu vertrauenden Rechner
(Rechnername oder IP-Adresse). Das Skript muss mit
Administratorrechten gestartet werden.

Ausführen von Befehlen auf entfernten

Computern außerhalb der eigenen Domäne

Danach kann man dann mit einem Befehl wie folgt einen
Fernzugriff ausführen, wobei die PowerShell explizit nach
Benutzername und Kennwort fragen wird, selbst wenn auf dem


Zielsystem die gleiche Benutzername-Kennwort-Kombination
existiert.

```
Invoke-Command F 171 { Get-ChildItem c:\ } - authentication
negotiate -credential
F 171 \hs
```
Bild 10.18 Nachfrage der PowerShell beim Zugriff auf Computer, die nicht zur
(vertrauten) Domäne gehören

Man kann auch eine dauerhae Sitzung zu einem entfernten
Computer, der nicht zur Domäne gehört, erstellen:

```
$s = New-PSSession F 171 - authentication negotiate -credent
ial F 171 \hs
```

```
TIPP: Die Anmeldedaten immer wieder eingeben zu
müssen, kann man vermeiden, indem man sich die
Anmeldedaten in einer Variablen merkt:
```
```
$cred = Get-Credential
```
```
HINWEIS: Man muss die Anmeldedaten nicht pro
Computer eingeben. Sofern Benutzername und Kennwort
auf allen Systemen gleich sind, kann man auch Folgendes
schreiben:
```
```
Listing 10.6 Setzen des Datums mit Set-Date auf mehreren Nicht-
Domänencomputern, die die gleiche Benutzername-Kennwort-
Kombination haben [WPS2_Remoting_MultiComputer_SetDate.ps1]
```
```
$cred = Get-Credential
$s = New-PSSession -auth negotiate -cred $cred -com
puter F170,
F171, F171, F173, F 174
Invoke-Command -Script { Set-date -date "24.6.2009
15:20:00" } - session$s
```
###### 10.14 Verwaltung des WS-

###### Management-Dienstes

In PowerShell ist der WS-Management-Dienst (WS-Man) über
einen PowerShell-Provider (mit Namen "WSMan")


administrierbar. Im Standard erscheint in der Liste das Laufwerk
"WSMan".

Bild 10.19 Liste der PowerShell-Provider in PowerShell

In diesem Laufwerk kann man wie bei anderen Providern mit den
Standard-Navigations-Commandlets wie Get-ChildItem (dir) und
Get-Item/Set-Item arbeiten.

Bild 10.20 Auflisten von WSMan:/localhost

Im Standard erscheint unterhalb der Laufwerkswurzel WSMan:
nur "localhost". Durch das Commandlet Connect-WSMan unter
Angabe eines Computernamens kann man hier aber weitere
Computer integrieren und im Folgenden ansteuern.


Bild 10.21 Einsatz von Connect-WSMan

Die folgende Befehlsfolge zeigt das Setzen der
vertrauenswürdigen Computer, zu denen eine Authentifizierung
mit Basisauthentifizierung oder Digest toleriert werden soll.

```
cd WSMan:\localhost\Client
Set-Item trustedhosts "F170, F171, F172, F173, F174, F175"
```
- force
Restart-Service winrm

Über das WSMan:-Laufwerk kann man auch den verwendeten
Port ändern. Den aktuell verwendeten Port listet man auf mit:

```
Dir wsman:\localhost\listener\*\Port
```
Auf dem Zielsystem ändert man den Port mit (hier wird geändert
auf Port 80):


```
set-item wsman:\localhost\listener\*\Port -value 80 - Force
```
Auf dem Client kann man dann den Port auf Aufruf angeben:

```
Enter-PSSession PC 199 - Port 80
```
###### 10.15 PowerShell Direct für Hyper-V

Ein virtuelles System können Sie grundsätzlich genauso wie ein
physikalisches System fernverwalten über RPC oder PowerShell-
Remoting. Für PowerShell-Remoting muss dies auf dem
Zielsystem aktiviert sein.

Seit Windows 10 und Windows Server 2016 bietet Microso für in
Hyper-V gehostete virtuelle Maschinen eine Vereinfachung unter
dem Namen "PowerShell Direct" an. Hier ist eine PowerShell-
Remoting-Verbindung nicht mehr notwendig. Auch die Firewall
muss nicht geöffnet sein. Die PowerShell redet direkt über den
VMBus von Hyper-V.

Voraussetzungen sind:

```
Der Hyper-V-Host ist Windows 10 oder Windows Server 2016
oder höher.
Der Hyper-V-Gast ist Windows 10 oder Windows Server 2016
oder höher.
Das Gastbetriebssystem muss laufen.
In dem Gastbetriebssystem muss der "Hyper-V VM Session
Service" (vmicvmsession) laufen.
```

```
Der Aufrufer muss Hyper-V-Administrator sein.
Die PowerShell-Konsole muss mit Administratorrechten
laufen.
Der Aufrufer braucht ein Benutzerkonto auf dem
Gastbetriebssystem. Dieses Konto muss aber keine
Administratorrechte haben!
```
Die Commandlets New-PSSession und Invoke-Command haben dafür
die neuen Parameter -VMName und -VMGUID erhalten. Auf eine der
beiden Weisen identifiziert der Nutzer die anzusprechende
virtuelle Maschine.

Bild 10.22 Initiieren einer Sitzung mit PowerShell Direct


Bild 10.23 Nutzen einer PowerShell-Direct-Sitzung

Bild 10.24 Ausführung eines Skriptblocks via PowerShell Direct


```
HINWEIS: Die Befehle, die PowerShell Direct verwenden,
müssen direkt auf dem Hyper-V-Host ausgeführt werden.
Es ist nicht möglich, sich mit PowerShell Remoting mit
dem Hyper-V-Host zu verbinden und diesem dann den
Aurag zu einer PowerShell-Direct-Verbindung zu geben.
Diesen Versuch quittiert die PowerShell mit "Specified
method is not supported."
```
```
TIPP: Auch bei PowerShell Direct ist es möglich, das
Kennwort für das Gastbetriebssystem im Quellcode eines
Skripts zu verankern – wenn man sich der Risiken bewusst
ist.
```
```
$VMName = "VM130"
$cred = new-object System.Management.Automation.PSC
redential -ArgumentList
"VM 130 \hs", (ConvertTo-SecureString "geheim123" - As
PlainText -force)
Enter-PSSession -vmname D 130 - Credential $cred
```
###### 10.16 Praxislösung zu PowerShell

###### Direct

Das folgende Praxisskript zeigt, wie man eine frisch installierte
virtuelle Maschine vom Hyper-V-Host aus konfiguriert:


```
Festlegen einer statischen IP-Adresse
Setzen des DNS-Servers
Umbenennen des Computers
Beitritt zu einer Domäne
Neustart
Alle PowerShell-Skripte erlauben
PowerShell Remoting aktivieren
Zugriff per RDP aktivieren
```
Danach ist dann eine Fernadministration des Rechners als neues
Domänenmitglied per RDP und PowerShell Remoting möglich!


Listing 10.7 [1_Basiswissen\Remoting\WPS5_PowerShell_Direct_PCKonfig.ps1]

```
# Konfiguration einer Windows-VM in HyperV
# (C) Holger Schwichtenberg, http://www.IT-Visions.de, 2013-2016
# Die folgenden Eingabedaten müssen vor dem Start angepass
t werden!
```
```
# Zugang zur VM
$VMName = "F131"
# Kennwörter hier nur zu Testzwecken im Skript. Müssen gg
f. interaktiv abgefragt
werden!
$cred = new-object System.Management.Automation.PSCredenti
al -ArgumentList "$VMName\
administrator", (ConvertTo-SecureString "fbi+123" - AsPlain
Text -force)
$credDomain = new-object System.Management.Automation.PSCr
edential -ArgumentList
"fbi\administrator", (ConvertTo-SecureString "fbi+123" - As
PlainText -force)
```
```
# Daten für neue Konfiguration
$ip = "192.168.1.131"
$DNSServer = "192.168.1.111"
$Gateway = "192.168.1.253"
$Domainname = "fbi.local"
```
```
# Skript-Einstellungen
$ErrorActionPreference = "stop"
```
```
########################
```

# Hilfsfunktion, die auf Verbindung zum Gastbetriebssystem
wartet
function WaitFor-PSDirect([string]$VMName, $cred){
Write-Output "Warte auf PowerShell Direct-Verbindung zu
$VMName mit Benutzer
$($cred.username)"
while ((invoke-command -VMName $VMName -Credential $cre
d {"Test"} - ea
SilentlyContinue) - ne "Test") {Sleep -Seconds 1 }
"$VMName ist verfügbar via PowerShell Direct!"
}

######################## Block 1:
# Festlegen einer statischen IP-Adresse
# Setzen des DNS-Servers
# Umbenennen des Computers
# Beitritt zu einer Domäne
# Neustart

$scriptblock 1 = {
param($Name,$IP,$credDomain,$Gateway,$DNSServer,$Domainnam
e)

$InterfaceName = (Get-netadapter | select-object -first
1 ).name
"Bisheriger Name $([System.Environment]::machinename) mit
Netzadapter $netzadapter"
Get-NetIPAddress
"Neuer Name: $Name mit IP $ip Gateway $Gateway DNSServer
$DNSServer"
Set-NetIPInterface -InterfaceAlias $InterfaceName -Dhcp Di
sabled


New-NetIPAddress -InterfaceAlias $InterfaceName -IPAddress
$IP -DefaultGateway
$Gateway -PrefixLength 24 | out-null
Set-DnsClientServerAddress -InterfaceAlias $InterfaceName

- ServerAddresses $DNSServer
ping $ip
"Rename Computer und Domain Join..."
Add-Computer -NewName $Name -Verbose -DomainName $Domainn
ame -Credential $credDomain
"PowerShell-Direkt-Skript # 1 ist fertig!"
}

# Block 1 ausführen
"Konfiguriere VM $vmname - Schritt 1"
Invoke-Command -VMName $VMName -Credential $cred -ScriptBl
ock $scriptblock 1

- ArgumentList $vmname,$ip,$credDomain,$Gateway,$DNSServe
r,$Domainname
"Reboot"

# Neustart und dann warten, bis Betriebssystem wieder zugr
eifbar!
Restart-VM $VMName -Force
WaitFor-PSDirect $VMName $cred

########################
# Alle PowerShell-Skripte erlauben
# PowerShell Remoting aktivieren
# Zugriff per RDP aktivieren

$scriptblock 2 = {
param()


"PowerShell-Skripte erlauben..."
Set-ExecutionPolicy Unrestricted
"PowerShell-Remoting erlauben..."
Enable-psremoting -force -SkipNetworkProfileCheck
"RDP erlauben..."
set-ItemProperty -Path ‚HKLM:\System\CurrentControlSet\Con
trol\Terminal Server'-name
"fDenyTSConnections" - Value 0
Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
set-ItemProperty -Path ‚HKLM:\System\CurrentControlSet\Con
trol\Terminal Server\
WinStations\RDP-Tcp' - name "UserAuthentication" - Value 1

"PowerShell-Direkt-Skript # 2 ist fertig!"
}

# Block 2 ausführen
"Konfiguriere VM $vmname - Schritt 2"
Invoke-Command -VMName $VMName -Credential $cred -ScriptBl
ock $scriptblock 2
"FERTIG: Fernadministration des Rechners $vmname als neues
Domänenmitglied per RDP
und PowerShell Remoting nun möglich!"


11 PowerShell-Werkzeuge

Dieses Kapitel bespricht die von Microso gelieferte PowerShell-Standardkonsole, das
Integrated Scripting Environment (ISE) sowie weitere nützliche Werkzeuge von Microso und
anderen Anbietern.

```
HINWEIS: Die über die Standardkonsole hinausgehenden Werkzeuge betreffen fast nur
Windows. Einziges PowerShell-Werkzeug für macOS und Linux ist zum
Redaktionsschluss dieses Buchs "Visual Studio Code".
```
11.1 PowerShell-Standardkonsole

Das alte Windows-Konsolenfenster, das von conhost.exe bereitgestellt wird, ist die Basis sowohl
für die klassische Eingabeaufforderung (cmd.exe) als auch für die 2006 eingeführte Windows
PowerShell (powershell.exe) und die PowerShell ab Version 6.0 (pwsh.exe). Es gehört zu den
ältesten Teilen des Windows-Betriebssystems, das viele Jahre von Microso unangetastet blieb.
Nutzer der PowerShell haben im PowerShell-Konsolenfenster etwas mehr
Eingabeunterstützung als in der klassischen Eingabeaufforderung (cmd.exe), vom Komfort des
PowerShell Integrated Scripting Environment (ISE) ist die PowerShell-Konsole aber weit
entfernt.


```
HINWEIS: Microso hat conhost.exe lange unverändert gelassen, dann in den letzten
Jahren aber etwas verbessert. Erst seit Windows 10 und Windows Server 2016 gab es
eine kleine Neuerung: Kopieren und Einfügen mit den Tastenkombinationen Strg + C
und Strg + V. Auf älteren Betriebssystemen ist dies nur mit der Eingabe-Taste (Kopieren)
beziehungsweise rechtem Mausklick (Einfügen) möglich.
In den Versionen Anniversary Update (Version 1609), Creators Update (Version 1703) und
Fall Creators Update (1708) wurde der Farbraum von 16 Farben auf 16 Millionen Farben
erweitert und die Darstellung auf hochauflösenden Displays verbessert. Zudem
unterstützt die Konsole seitdem die in der Unix-Welt üblichen ANSI-Escape-Codes und
VT-Befehlssequenzen. Im Dezember 2018 hatte Microso neue Einstellungen bezüglich
Farben, Scrolling und Cursor-Aussehen für die bestehende Konsole in den Windows 10
Build 18298 eingebaut.
```
11.1.1 Funktionsumfang der Standardkonsole

Die PowerShell-Konsole bietet folgende Funktionen:
Größe und Aussehen des Fensters können über die Eigenschaen gesteuert werden (siehe
Abbildung 11.1).
Kopieren und Einfügen (seit Windows 10 und Windows Server 2016 auch mit
Tastenkombinationen STRG + C/V). In älteren Betriebssystemen geht das aber umständlich
wie seit jeher nur über das Fenstermenü (siehe Abbildung 11.2) bzw. den sogenannten
"Quick Edit Mode".
Befehls- und Pfadeingaben sowie Objektattribute können mit der Tab-Taste vervollständigt
werden.
Ein Rücksprung zu den letzten Befehlen (Anzahl änderbar) ist mit den Pfeiltasten
(hoch/runter) möglich.
Der Abbruch eines laufenden Befehls ist mit STRG + C möglich.


Bild 11.1 Fenstereigenschaen für das PowerShell-Konsolenfenster (links: Windows PowerShell, rechts: PowerShell 7)

Bild 11.2 Nutzung der Zwischenablage im PowerShell-Konsolenfenster vor Windows 10 und Windows Server 2016

11.1.2 Kopieren und Einfügen (Copy/Paste)

Darauf haben Windows-Nutzer jahrzehntelang gewartet: Die Windows-Eingabeaufforderung
kann seit Windows 10 und Windows Server 2016 nun endlich die Zwischenablagefunktionen
Kopieren und Einfügen mit den Tastenkombinationen STRG + C und STRG + V ausführen.


Microso hat die conhost.exe erweitert, die sowohl die Basis für die klassische
Eingabeaufforderung (cmd.exe) als auch die Windows PowerShell (powershell.exe) und die
PowerShell (Core) (pwsh.exe) ist. Weiterhin gibt es aber kein Ausschneiden (STRG + X), und auch
Kopieren und Einfügen ist nicht über Kontextmenüs möglich, wie man es aus anderen Windows-
Anwendungen kennt. Das alte Verfahren zum Kopieren und Einfügen über Markieren und
EINGABE-Taste (Kopieren) bzw. rechten Mausklick (Einfügen) geht weiterhin in den neueren
Windows-Versionen. Auch kann man in den Fenstereigenschaen die Konsole in den alten
"Legacy"-Modus schalten, wenn es Probleme mit Kommandozeilenanwendungen gibt, die
diese Tastenkombinationen anders verwenden.
Leider hängt diese neue Eingabekomfortfunktion am Betriebssystem, d. h., die Installation der
PowerShell 5.x auf älteren Betriebssystemen bringt hier keine Neuerungen. Allenfalls könnte
man abseits der Lizenzbedingungen versuchen, die benötigten Dateien vom aktuellsten
Windows auf eine ältere Version zu kopieren. Ein Versuch, die conhost.exe neben der
conhostv1.dll und der conhostv2.dll zu kopieren, bringt aber nicht den gewünschten Erfolg, denn
die conhost.exe braucht aktuelle APIs aus dem WinSXS-Verzeichnis. Hiermit zu experimentieren
kann große Probleme nach sich ziehen, und daher erscheint ein Betriebssystemupgrade der
einfachere Weg, wenn man die neue Konsole nutzen will.

11.1.3 Tabulatorvervollständigung

Die PowerShell kennt eine bereits im klassischen Kommandozeilenfenster verfügbare
tabulatortastenbasierte Eingabehilfe (in der Entwicklersprache "Tab Auto Completion"
genannt). Im DOS-Kommandozeilenfenster kann man nach Eingabe eines oder mehrerer
Buchstaben die erreichbaren Dateien und Unterverzeichnisse mit der Tabulatortaste Tab
durchlaufen.
In PowerShell funktioniert die Tab Completion für:
Dateinamen und Ordnernamen
Namen von Commandlets, Funktionen und klassische Windows-Befehle
Parameter von Commandlets und Funktionen
Klassenmitglieder (Attribute, Methoden und Ereignisse)
die Namen einiger Systemressourcen, z. B. Dienstnamen bei den Commandlets Get-Service
und Stop-Service sowie Prozessnamen bei Commandlets wie Get-Process und Stop-
Process
Werte von Aufzählungstypen (Enumerationen). Dies ist erst seit PowerShell 7.0
implementiert!


Bild 11.3 Eingabe des Wortanfangs

Bild 11.4 Nach dem Drücken der Tabulatortaste erscheint die erste Alternative.

Bild 11.5 Nach nochmaligem Drücken erscheint die zweite Alternative.

Bild 11.6 Seit PowerShell 7.0 gibt es auch Tabulatorvervollständigung für Werte von Aufzählungstypen.

Bild 11.7 Nach dem Drücken der Tabulatortaste erscheint der erste erlaubte Wert.

11.1.4 Zusätzliche Eingabeunterstützung


Neben den eingebauten Tab-Auto-Complete-Funktionen kann die PowerShell um weitere
Vervollständigungshilfen erweitert werden für Parameter von klassischen
Kommandozeilenbefehlen. Dazu müssen die Kommandozeilenbefehle entsprechende
Unterstützung besitzen, die man mit dem PowerShell-Commandlet Register-ArgumentCompleter
registrieren muss.
Beispiel: Registrierung von Eingabehilfen für die .NET-Kommandozeilenschnittstelle (.NET CLI),
die über den Befehl dotnet complete bereitgestellt wird.

```
# PowerShell parameter completion shim for the dotnet CLI
Register-ArgumentCompleter -Native -CommandName dotnet -ScriptBlock {
param($commandName, $wordToComplete, $cursorPosition)
dotnet complete --position $cursorPosition "$wordToComplete" | ForEach-
Object {
[System.Management.Automation.CompletionResult]::new($_, $_,
'ParameterValue', $_)
}
}
```
Danach reicht es, z. B. dotnet n zu tippen und dann die Tabulatortaste zu drücken, um dotnet
new zu bekommen.
dotnet new c schlägt als Erstes dotnet new classlib vor. Bei weiterem Tabulatur-Tasten-Druck
dann dotnet new console usw.

```
TIPP: Einen Befehl wie Register-ArgumentCompleter hinterlegt man am besten im
Profilscript der PowerShell, um zu vermeiden, dass er immer wieder in jeder neuen
PowerShell-Konsoleninstanz aufgerufen werden muss. Die Erstellung eines solchen
Skripts und das Skript zur Anzeige des Rechtestatus in der Titelleiste finden Sie in Kapitel
23 "Standardeinstellungen ändern mit Profilskripten".
```
11.1.5 PSReadline

Beim Start der PowerShell ab Version 5.x ab Windows 10 und ab Windows Server 2016 fällt
sofort auf, dass Commandlets und auch klassische Windows-Befehle nun in Gelb von der
ansonsten weißen Schrifarbe abgehoben werden.
Bei älteren Windows-Versionen fehlt diese Funktion aber. Das liegt daran, dass Microso auf
aktuellen Windows-Systemen die PowerShell-Erweiterung "PSReadline" [github.com/Power
Shell/PSReadLine] mitliefert. Unter älteren Betriebssystemen mit PowerShell ab Version 3.0
kann man PSReadline mit Install-Module PSReadline nachträglich installieren. Dabei kommt es
o zu mehreren Sicherheitsabfragen, weil erst als Grundlage "NuGet" auf Ihrem System
installiert oder aktualisiert werden muss


In PowerShell 6/7 ist PSReadline automatisch enthalten, allerdings o nicht in der aktuellsten
Version. Abhängig davon, wie PSReadline installiert wurde, können Sie dieses Modul wie
folgend beschrieben aktualisieren.
Wenn es als Systemmodul installiert wurde:

```
Install-Module -Name PSReadLine -Force
```
Wenn Sie das Modul bereits einmal aus der PowerShell Gallery bezogen haben:

```
Update-Module -Name PSReadLine -Force
```
Bild 11.8 In diesem Fall ging die Aktualisierung von PSReadline nicht über Update-Module, sondern nur über Install-Module.


```
HINWEIS: Die Erweiterung "PSReadline" wurde ursprünglich seit dem Jahr 2013 von
Jason Shirk [github.com/lzybkr] auf Github als Open Source-Projekt entwickelt. Im Zuge
der Öffnung von Microso für Open Source wurde die Erweiterung in Windows
integriert. Im Mai 2019 wurde das Projekt von Microso übernommen
[devblogs.microso.com/powershell/powershell- 7 - road-map] und in das offizielle Github-
Repository von Microso überführt [https://github.com/PowerShell/PSReadLine].
```
11.1.5.1 Form der Eingabeunterstützung

PSReadline bietet zwei Eingabemodi an:
Windows-Modus: Der Benutzer erhält nach einer Eingabe von "Get-H" und dem Drücken der
Tabulatortaste den Vorschlag für das erste passende Commandlet (Get-Help) und bei
jedem weiteren Drücken der Tabulatortaste für die folgenden Commandlets (Get-History
und Get-Host).
Emacs-Modus (alias "bash"-Stil): Dabei blättert man beim Drücken der Tabulatortaste nicht
durch die Optionen, sondern der Benutzer erhält eine Liste aller infrage kommenden
Befehle auf dem Bildschirm (siehe folgende Abbildung). Der Benutzer bekommt die
Ausgabe einer Liste der passenden Commandlets nach dem ersten Drücken der
Tabulatortaste. Die Eingabeaufforderung zeigt wieder den eingegebenen Text. Erst wenn
die Eingabe eindeutig ist (hier z. B. bei "Get-Ho"), wird der Befehl vervollständigt. Ebenso
funktioniert die Eingabeunterstützung für andere Konstrukte wie Parameter.

Bild 11.9 Befehlsvorschläge im Emacs-Modus in der PowerShell mit PSReadline


Bild 11.10 Vorschlagliste in PSReadline im Emacs-Modus; hier für Parameter des Commandlets Get-ChildItem

Bei PSReadline erfolgt das Umschalten der Eingabeunterstützungsmodi mit

```
Set-PSReadlineOption -EditMode Emacs
```
und

```
Set-PSReadlineOption -EditMode Windows
```
```
HINWEIS: Durch den EditMode werden auch die Tastaturbindungen beeinflusst. Es gibt
auch noch den EditMode "Vi", der sich aber bei der Darstellung der
Eingabeunterstützung wie der Modus "Windows" verhält.
```
11.1.5.2 Predictive IntelliSense

Seit PSReadline Version 2.1 gibt es auch erweiterte Vorschläge bei der IntelliSense auf Basis
früherer Befehlseingaben des Benutzers. Diese Funktion müssen wir so aktivieren:

```
Set-PSReadLineOption -PredictionSource History
```
Die Farbe der Vorschläge kann man so ändern:

```
Set-PSReadLineOption -Colors @{ InlinePrediction = "$([char] 0 x 1 b)[38;5;238m"}
```
Die Funktion lässt sich wieder deaktivieren mit:

```
Set-PSReadLineOption -PredictionSource None
```

```
HINWEIS: Bisher gibt es nur den Modus "History". Wenn man aber schaut, was Microso
in den letzten Jahren für C# entwickelt hat, kann man mutmaßen, dass es zukünig
auch Vorschläge aus dem Verhalten anderer Nutzer geben wird. Ein erster Ansatz dazu
ist das Modul "Az.Tools.Predictor" mit speziellen Vorschlägen für die Arbeit mit der
Azure-Cloud:
Install-Module -Name Az.Tools.Predictor -AllowPrerelease -Force
```
Bild 11.11 Predictive IntelliSense (Bildquelle: https://devblogs.microso.com/powershell/psreadline- 2 - 2 - ga/)

11.1.5.3 Weitere Tastaturbefehle

Neben der Syntaxfarbhervorhebung bietet PSReadline auch einige weitere Tastaturbefehle:
Undo und Redo mit STRG + Z und STRG + Y sowie eine Befehlshervorhebung im Stil von
bash.
Sprung zwischen Wörtern in einer Zeile mit STRG + PFEIL_LINKS und STRG + PFEIL_
RECHTS
Alternativ zur Tabulatorvervollständigung eine Vorschlagsliste, die mit STRG + Leertaste
auslöst.

```
TIPP: Mit dem Commandlet Get-PSReadLineKeyHandler erhält man eine Liste aller
unterstützten Tastaturbefehle. Mit Set-PSReadLineKeyHandler kann man die Belegung
auch anpassen.
```
11.1.5.4 Farbanpassungen in PSReadline

Die PowerShell verwendet leider einige Farben mit wenig Kontrast. So werden Zeichenketten in
einfachen oder doppelten Anführungszeichen in "DarkCyan" auf dunkelblauem Grund
dargestellt. Falls Sie dies nicht gut lesen können, ändern Sie doch die Farbe auf Cyan:

```
Set-PSReadLineOption -Colors @{ "string"="cyan" }
```

Bild 11.12 Auswirkung der Farbänderung (Achtung: Da das Buch in Schwarz-Weiß gedruckt ist, werden Sie die Farbänderung
im gedruckten Buch kaum sehen können. Schauen Sie in das E-Book!)

Falls Sie beim Eingeben schon einen Fehler gemacht haben, haben Sie rote Schri auf blauem
Untergrund gesehen. Wenn Sie das nicht gut lesen können, geben Sie bitte ein:

```
(Get-Host).PrivateData.ErrorBackgroundColor = "white"
```
Damit stellen Sie auf rote Schri auf weißem Grund für Fehlerausgaben um.

11.1.6 Farbanpassungen mit ANSI-Terminal-Dekorationen


Seit PowerShell 7.2 ist die Unterstützung für ANSI-Terminal-Dekorationen in stabilem Zustand.
Die aktuellen Farbeinstellungen erhalten Sie von der Variablen $PSStyle.


Bild 11.13 Ausgabe von $PSStyle


Man kann die Farbdefinitionen ändern. Allerdings gilt dies nicht generell in der PowerShell,
sondern nur für solche Commandlets, die ANSI-Terminal-Dekorationen unterstützen. Im
nächsten Bild ist die normale Fehlermeldung nach "unsinn" weiter mit `e[ 31 m formatiert. Die
Änderung auf Negativschri

```
$PSStyle.Formatting.Error = "`e[ 41 m"
```
wirkt nur auf Get-Error.

Bild 11.14 Änderung der Dekoration "Error".

```
HINWEIS: ANSI-Terminal-Dekorationen werden in PowerShell 7.2 nur bei Get-Error,
Select-String, Write-Progress und Show-Markdown unterstützt. Bei Get-Childitem ist die
Unterstützung experimentell und muss via Enable-Experimental-Feature
PSAnsiRenderingFileInfo aktiviert werden.
```
11.1.7 Kommandomodus versus Interpretermodus

Normalerweise führt die Konsole alle Befehle nach dem Drücken der Enter-Taste sofort aus.
Wenn man allerdings einen unvollständigen Befehl eingibt (z. B. einen Befehl, der auf das
Pipeline-Symbol | endet), dann geht die Konsole in den sogenannten Interpretermodus, bei
dem die Befehle nicht mehr sofort ausgeführt werden. Der Interpretermodus wird durch die
Eingabeaufforderung >> (siehe folgende Abbildung) angezeigt. Der Interpretermodus gilt so
lange, bis man eine leere Eingabe macht. Dann wird der Befehl ausgeführt.


Bild 11.15 Die Konsole ist im Interpretermodus.

Bild 11.16 Der Interpretermodus wurde durch eine leere Eingabe wieder verlassen.

11.1.8 Zeilenumbrüche in Befehlen

Wenn sich ein Befehl über mehrere Zeilen erstrecken soll, kann man dies in der
Standardkonsole auf drei Weisen bewerkstelligen:
Man beendet die Zeile mit einem Pipe-Symbol und drückt EINGABE. Die Konsole erkennt,
dass der Befehl noch nicht abgeschlossen ist, und erwartet weitere Eingaben. Die
Standardkonsole zeigt dies auch mit zwei Größerzeichen >>, in älteren Versionen mit drei
Größerzeichen >>> an.
Man kann am Ende einer Zeile mit einem Gravis [`], ASCII-Code 96, bewirken, dass die
nächste Zeile mit zum Befehl hinzugerechnet wird.
Man kann SHIFT + EINGABE drücken. Auch dann zeigt die Standardkonsole mit zwei >> bzw.
drei Größerzeichen >>> an, dass weitere Eingaben erwartet werden. Wenn der Befehl
vollständig ist, drückt man nur noch EINGABE.


Bild 11.17 Verschiedene Varianten für Zeilenumbrüche in der Standardkonsole in älteren Versionen mit drei >>>

Bild 11.18 Verschiedene Varianten für Zeilenumbrüche in der Standardkonsole, in neueren Versionen mit drei >>>

11.1.9 Benutzerkontensteuerung/Administratorrechte

Die PowerShell unterliegt wie alle anderen Anwendungen auch der Benutzerkontensteuerung in
den neueren Windows-Versionen und wird daher unter eingeschränkten Rechten gestartet. Das
heißt: Selbst wenn Sie mit einem Administratorkonto am System angemeldet sind, kann die
PowerShell nicht alle administrativen Aufgaben ausführen.
Wie die Einschränkung wirkt und wie man sie wieder aufhebt, hängt dabei stark von dem
verwendeten Betriebssystem ab.

```
HINWEIS: Man kann die Benutzerkontensteuerung komplett ausschalten, damit die
PowerShell immer unter vollen Rechten läu. Man muss sich aber bewusst sein, dass
man damit ein wesentliches Sicherheitsfeature von Windows abschaltet.
```

```
ACHTUNG: Unter Windows Server ab Version 2012 läu die PowerShell-Konsole immer
als Administrator, wenn Sie das eingebaute Konto "Administrator" verwenden und die
zugehörigen Sicherheitsrichtlinien nicht geändert haben. Dies gilt aber wirklich nur für
das Konto namens "Administrator". Andere Administratorenkonten starten die
PowerShell nicht automatisch mit vollen Rechten. Hier darf man das Konto
"Administrator" nicht mit der Administratorfunktion und dem Befehl "Als Administrator
starten" verwechseln!
```
```
Bild 11.19 Diese Sicherheitsrichtlinie startet die PowerShell mit vollen Rechten, wenn das Konto "Administrator" im
Einsatz ist.
```
11.1.10 Feststellen, ob ein Skript in der Konsole läu

Die PowerShell-Konsole liefert in der eingebauten Variablen $host.name die Zeichenkette
"ConsoleHost". Dies gilt sowohl für Windows PowerShell (powershell.exe) als auch für Power-
Shell Core (pwsh.exe) und PowerShell 7 (ebenfalls pwsh.exe).

Bild 11.20 Prüfung von $host.name

11.1.11 Feststellen, unter welchen Rechten die PowerShell

wirklich läu


Seit Windows 7 und Windows Server 2008 R 2 sehen Sie in der Titelleiste der PowerShell durch
den Zusatz "Administrator", ob die PowerShell unter kompletten administrativen Rechten läu
oder nicht.

Bild 11.21 Eine PowerShell-Konsole mit kompletten Administratorrechten

Bild 11.22 Eine PowerShell-Konsole mit eingeschränkten Rechten (obwohl der angemeldete Benutzer Administrator ist)


```
ACHTUNG: Unter Windows Vista und Windows Server 2008 zeigt die PowerShell-Konsole
leider nicht "Administrator:" an. Um in der Titelleiste der PowerShell-Konsole den
Rechtestatus anzuzeigen und gegebenenfalls weitere Anpassungen der Anzeige
vorzunehmen, wie man dies in der folgenden Abbildung sieht, kann man sich ein
PowerShell-Profilskript schreiben. Die Erstellung eines solchen Skripts und das Skript
zur Anzeige des Rechtestatus in der Titelleiste finden Sie in Kapitel 23
"Standardeinstellungen ändern mit Profilskripten".
```
```
Bild 11.23 Zwei PowerShell-Instanzen mit verschiedenen Rechten
```
```
TIPP: Um bei einer laufenden Konsole ohne Titelanzeige festzustellen, welche Rechte
diese besitzt, können Sie das in Windows mitgelieferte Kommandozeilenwerkzeug
whoami.exe mit der Option /all verwenden. Im Fall der vollen Administratorrechte sieht
man dort eine Liste von ca. 20 Berechtigungen. Bei eingeschränkten Rechten sieht man
nur fünf:
SeShutdownPrivilege
SeChangeNotifyPrivilege
SeUndockPrivilege
SeIncreaseWorkingSetPrivilege
SeTimeZonePrivilege
Im Kapitel "Sicherheitseinstellungen" lesen Sie, wie man die Frage, ob
Administratorrechte vorliegen oder nicht, auch über eine .NET-Klasse beantworten
kann.
```
11.1.12 Starten als "Administrator"


Wenn Sie nicht das eingebaute Administratorkonto auf einem Windows Server (ab Version 2012)
verwenden oder die Benutzerkontensteuerung ausgeschaltet haben, müssen Sie für einige
Aufgaben die PowerShell mithilfe des Kontextmenüeintrags Als Administrator ausführen starten.

Bild 11.24 Starten der PowerShell-Konsole als "Administrator" (hier in Windows 11)

Je nach Einstellung der Benutzerkontensteuerung (siehe Systemsteuerung) kommt danach eine
Nachfrage.

Bild 11.25 Zustimmung zur Rechteerhöhung der PowerShell (hier in Windows 11)

11.2 Windows Terminal

Im Mai 2019 hat Microso bekanntgegeben: Windows-Client und der Windows Server sollen ein
neues, als Open Source entwickeltes Kommandozeileneingabefenster mit Namen "Windows
Terminal" erhalten. Das Windows Terminal soll sowohl für die klassische CMD, die PowerShell
und die Shell für Windows for Linux (WSL) nutzbar sein.


Das neue "Windows Terminal" verwaltet Microso zusammen mit dem Quellcode der
klassischen conhost.exe in einem Github-Projekt [https://github.com/microso/terminal].
Mittlerweile liefert Microso das Windows Terminal nicht nur über Github
[https://github.com/microso/terminal/releases], sondern auch den Windows Store aus. In
Windows 11 ist das Windows Terminal im Standard enthalten, muss aber ggf. über den Windows
Store auf die aktuelle Version gebracht werden.

Bild 11.26 Windows Terminal im Windows Store

```
HINWEIS: Im Windows Store gibt es das Windows Terminal zweimal: einmal als aktuelle
Release-Version und einmal als "Preview" mit den neusten, noch nicht stabilen Features.
```
Im Windows Server 2022 ist das Windows Terminal im Standard nicht enthalten, kann dort aber
installiert werden. Dazu laden Sie von GitHub das MSIX-Bundle herunter
[https://github.com/microso/terminal/releases] und installieren dies mit diesem Befehl:

```
Add-AppxPackage C:\Setup\Microsoft.WindowsTerminalPreview_[VERSIONNUMMER]_[HASH]. msix
bundle
```
Die neue Konsole soll nicht nur alle Unicode-Zeichen mithilfe der Grafikkarte gut lesbar
ausgeben können, sondern auch Emoticons beziehungsweise Emojis darstellen. Wenn
Konsolennutzer mehrere Eingabeaufforderungen brauchen, sollen sie nicht mehr mehrere
Fenster öffnen müssen, sondern dies über Registerkarten in einem Fenster erledigen können,
wie man es von Webbrowsern kennt. Der Nutzer soll über Layoutthemen die Gestaltung
individualisieren können. Entwickler sollen Erweiterungen für das neue Terminal schreiben
können. Microso will diese Erweiterungen über einen Marktplatz anbieten.


Im Standard bietet das neue Windows Terminal eine Registerkarte mit Windows PowerShell 5.1.
Man kann weitere Registerkarten mit Windows PowerShell, klassischer Eingabeaufforderung
oder Azure Cloud Shell anlegen.

Bild 11.27 Weitere Registerkarten anlegen im Windows Terminal

Bild 11.28 Im Windows Terminal werden Admin-Rechte durch ein zusätzliches Symbol angezeigt.

Im Einstellungsdialog kann man festlegen, welche Kommandozeilenshell das Windows
Terminal im Standard verwendet.


```
TIPP: Unter Windows 11 kann man das Windows Terminal anstelle von "Windows
Console Host" (conhost.exe) zum Standardterminal in Windows machen! Dann führt
auch der Aufruf von "cmd" im Startmenü nicht mehr zur klassischen conhost.exe,
sondern zum Windows Terminal! Wenn Sie dann doch mal noch die conhost.exe
brauchen, geben Sie einfach im Startmenü "conhost" ein. In einem kommenden
Windows 11-Update soll das Windows Terminal automatisch zum Standard werden
[https://www.golem.de/news/microso-windows-terminal-wird-cmd-alsstandard-in-
windows- 11 - abloesen- 2112 - 161816.html].
```
Bild 11.29 Standardterminal in Windows 11 in den Einstellungen des Windows Terminals festlegen

Die Einstellungen werden nicht in der Registry, sondern in einer Datei abgelegt:

```
C:\Users\xy\AppData\Local\Packages\Microsoft.WindowsTerminal_8wekyb 3 d 8 bbwe\
LocalState\settings.json
```
bzw. für die Preview-Version:

```
C:\Users\xy\AppData\Local\Packages\Microsoft.WindowsTerminalPreview_8wekyb 3 d 8 bbwe\ Loc
alState\settings.json
```
Man kann und darf diese JSON-Datei auch direkt bearbeiten. In den ersten Versionen des
Windows Terminal gab es noch gar keinen Einstellungsdialog und die Bearbeitung der JSON-
Datei war der einzige Weg.


Listing 11.1 Ausschnitt aus settings.json


{
"$schema": "https://aka.ms/terminal-profiles-schema",
// Add custom actions and keybindings to this array.
// To unbind a key combination from your defaults.json, set the command to
"unbound".
// To learn more about actions and keybindings, visit https://aka.ms/terminalkeybi
ndings
"actions":
[
// Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.
json.
// These two lines additionally bind them to Ctrl+C and Ctrl+V.
// To learn more about selection, visit https://aka.ms/terminal-selection
{
"command":
{
"action": "copy",
"singleLine": false
},
" keys": "ctrl+c"
},
{
"command": "paste",
"keys": "ctrl+v"
},
// Press Ctrl+Shift+F to open the search box
{
"command": "find",
"keys": "ctrl+shift+f"
},
// Press Alt+Shift+D to open a new pane.
// - "split": "auto" makes this pane open in the direction that provides the most
surface area.
// - "splitMode": "duplicate" makes the new pane use the focused pane's
profile.
// To learn more about panes, visit https://aka.ms/terminal-panes
{
"command":
{
"action": "splitPane",
"split": "auto",
"splitMode": "duplicate"
},
"keys": "alt+shift+d"
}
],


"copyFormatting": "none",
"copyOnSelect": false,
"defaultProfile": "{ 61 c 54 bbd-c 2 c6-5271-96e7-009a 87 ff 44 bf}",
"profiles":
{
"defaults": {},
"list":
[
{
"commandline": "powershell.exe",
"guid": "{ 61 c 54 bbd-c 2 c6-5271-96e7-009a 87 ff 44 bf}",
"hidden": false,
"name": "Windows PowerShell",
"startingDirectory": "w:\\"
},
{
"commandline": "cmd.exe",
"guid": "{ 0 caa 0 dad-35be-5f56-a 8 ff-afceeeaa 6101 }",
"hidden": false,
"name": "Command Prompt",
"startingDirectory": "w:\\"
},
{
"guid": "{b 453 ae62-4e 3 d-5e58-b989-0a 998 ec 441 b 8 }",
"hidden": false,
"name": "Azure Cloud Shell",
"source": "Windows.Terminal.Azure"
},
{
"guid": "{ 574 e 775 e-4f 2 a-5b96-ac 1 e-a 2962 a 402336 }",
"hidden": false,
"name": "PowerShell",
"source": "Windows.Terminal.PowershellCore",
"startingDirectory": "c:\\"
}
]
},
"schemes":
[
{
"background": "# 0 C 0 C 0 C",
"black": "# 0 C 0 C 0 C",
"blue": "# 0037 DA",
"brightBlack": "#767676",
"brightBlue": "# 3 B 78 FF",
"brightCyan": "# 61 D 6 D6",


```
"brightGreen": "# 16 C 60 C",
"brightPurple": "#B 4009 E",
"brightRed": "#E74856",
"brightWhite": "#F 2 F 2 F2",
"brightYellow": "#F 9 F 1 A5",
"cursorColor": "#FFFFFF",
"cyan": "# 3 A 96 DD",
"foreground": "#CCCCCC",
"green": "# 13 A 10 E",
"name": "Campbell",
"purple": "#881798",
"red": "#C 50 F 1 F",
"selectionBackground": "#FFFFFF",
"white": "#CCCCCC",
"yellow": "#C 19 C00"
},
...
}
```
```
TIPP: Das Windows Terminal liefert bei $host.name genau wie bei der Ausführung in der
alten Windows-Konsole die Ausgabe "ConsoleHost".
Mit Prüfung der Umgebungsvariablen WT_SESSION können Sie feststellen, ob Sie im
Windows Terminal sind:
function Test-WindowsTerminal { test-path env:WT_SESSION }
Die im Kapitel "PowerShell-Standardkonsole" erwähnten Anpassungen der Power-Shell
(PSReadline etc). sind auch im Windows Terminal möglich.
```
11.3 Erweiterung der Konsolen

Neben dem in der PowerShell schon mitgelieferten PSReadline gibt es noch andere
Erweiterungen für die PowerShell-Standardkonsole bzw. Windows-Terminal, z. B.:
Terminal-Icons zur Anzeige von Datei- und Ordnersymbolen
[https://github.com/devblackops/Terminal-Icons]
Posh-Git zur Anzeige von Git-Branch und Git-Status im Prompt
[https://github.com/dahlbyk/posh-git]
Oh-my-Posh zeigt einen farblich verschönerten Prompt inklusive Git-Informationen
[https://ohmyposh.dev/].


Das Installations- und Anwendungsmuster ist in der Regel: einmalige Installation von der
PowerShell-Gallery, dann Import pro Konsole (ggf. im PowerShell-Profil-Skript).

```
Install-Module Terminal-Icons
Import-Module Terminal-Icons
```
bzw.

```
Install-Module posh-git
Import-Module posh-git
```
bzw.

```
Install-Module oh-my-posh
Import-Module oh-my-posh
```
Hier muss man danach noch pro Terminalfenster ausführen (hier gibt es zahlreiche
Konfigurationsoptionen über anpassbare Themes, siehe https://ohmyposh.dev/docs):

```
oh-my-posh init pwsh | Invoke-Expression
```
```
HINWEIS: Für Terminal-Icons und Oh-my-Posh benötigen Sie zusätzlich eine der "Nerd"-
Schriarten von https://www.nerdfonts.com/font-downloads. Die gewählte Schriart
müssen Sie dann in Ihrer Konsolenanwendung festlegen, z. B. in der Konfigurationsdatei
von Windows Terminal (C:\Users\xy\AppData\Local\Packages\ Microso.
WindowsTerminal_ 8 wekyb 3 d 8 bbwe\LocalState\settings.json) eintragen:
...
"profiles":
{
"defaults": {
"font": {
"face": "3270Medium Nerd Font Mono"
}
},
...
```

Bild 11.30 Dateisystemauflistung ohne und mit "Terminal-Icons" (installierte Schriart ist "3270Medium Nerd Font Mono")

Bild 11.31 Einsatz von Posh-Git: Wir sind im aktuellen Git-Branch "NET6" und haben eine Änderung, die nicht eingecheckt ist.


Bild 11.32 Einsatz von Oh-my-Posh: Auch hier sieht man den Git-Branch und dass eine Datei geändert ist.

11.4 PowerShell Integrated Scripting Environment

(ISE)

Die PowerShell 1.0 bot damals als einziges Werkzeug zum Eingeben und Ausführen von
PowerShell-Befehlen und -Skripten die PowerShell-Standardkonsole. Ein komfortabler Editor
fehlte und rief Drittanbieter auf den Plan, z. B. PowerShellPlus und PowerGUI. Das Power-Shell
Integrated Scripting Environment (ISE), in den ersten Alpha-Versionen der Power-Shell 2.0
noch "Graphical PowerShell" genannt, ist eine WPF-basierte Windows-Anwendung, die einen
Editor und eine Ausführungsumgebung für die PowerShell-Einzelbefehle und -Skripte
bereitstellt.
Seit der PowerShell-Version 3.0 ist dieser Editor wesentlich besser geworden und den
Drittanbieterprodukten in vielen Punkten ebenbürtig. Windows PowerShell ISE ist eine
modernere Anwendung mit Eingabeunterstützung in Vorschlagslisten (IntelliSense).

```
ACHTUNG: Windows PowerShell ISE ist naturgemäß nicht verfügbar auf Windows Server
Core und Nano Server, wo es keine grafische Benutzeroberfläche gibt. Dort gibt es nur
die normale PowerShell-Konsole.
```
11.4.1 Start der ISE


Zum Start der ISE ru man entweder das Symbol im Startmenü, die ausführbare Datei
PowerShell_ise.exe oder in der PowerShell den Alias "ise" auf.

Bild 11.33 Befehlsvorschläge in der ISE-Konsole

```
HINWEIS: Auch die ISE gibt es (genau wie die Standardkonsole) in einer 32- und einer
64-Bit-Version. Die 32-Bit-Version (siehe %systemroot%\SysWOW 64 \
WindowsPowerShell\V1.0) ist notwendig, wenn man auf 32-Bit-Komponenten wie den
Microso-Access-32-Bit-Datenbanktreiber zugreifen will.
```
```
TIPP: Man kann nach powershell_ise.exe auch einen Pfad (oder durch Semikolon
getrennt mehrere Pfade) zu Skriptdateien angeben, die geöffnet werden sollen, z. B. ise
x:\skripte\skript1.ps1;x:\skripte\skript2.ps 1.
```
11.4.2 Konsolenbereich

Die PowerShell-ISE-Konsole bietet wie die normale PowerShell-Konsole einen interaktiven
Eingabebereich für Befehle. Anders als bei der normalen PowerShell-Standardkonsole gibt es
hier aber Vorschlagslisten (Eingabeunterstützung) in Form von Drop-down-Menüs (Intelli-
Sense-Eingabeunterstützung) sowohl für Commandlets und deren Parameter als auch für .NET-
Klassen und Klassenmitglieder sowie für Dateisystempfade.


In der PowerShell ISE gibt es zudem rechts einen "Befehls-Add-on" genannten Bereich, in dem
man nach den Namen von PowerShell-Commandlets suchen kann und die Parameter dieser
Befehle als Eingabemaske erhält. Zudem bietet die PowerShell-ISE weitere nützliche Befehle:
Über eine "Remote PowerShell-Registerkarte" (siehe Datei-Menü) kann man Befehle auf
einem entfernten System ausführen (sofern dort PowerShell installiert und die
Fernausführung mit dem Befehl Enable-PSRemoting zugelassen ist).
Die Schrigröße kann man nahtlos zoomen (siehe Regler am unteren rechten Rand,
alternativ auch mit Strg + Mausrad möglich).
In den Einstellungen (Tools/Optionen) kann man sehr genau die Farben und Schriarten für
verschiedene Ausgabearten einstellen.
Direkte Unterstützung für Copy/Paste und Cut/Paste mit Tastatur (Strg + X/C/V) und
Kontextmenüeinträgen
Die PowerShell ISE erlaubt die Entwicklung und Nutzung von Add-ons (z. B.
Rechtschreibprüfung), vgl.
https://social.technet.microso.com/wiki/contents/articles/2969.windows-powershell-ise-
add-on-tools.aspx.

11.4.3 Skriptbereich

Über das Menü Ansicht/Skriptbereich kann man den ISE-Skripteditor einblenden, der sich über
den Konsolenbereich legt.
Ein Skript zu Bearbeitung öffnen kann man auf folgenden Wegen:
"Bearbeiten" im Kontextmenü einer .ps1-Datei im Windows Explorer
Menü Datei/Öffnen in der ISE
Eingabe von psedit mit Dateipfad dem Konsolenbereich der ISE

```
HINWEIS: PSEdit ist eine eingebaute Funktion der PowerShell ISE im Modul "IsePack".
PSEdit kann nicht in der normalen PowerShell-Konsole gestartet werden. Die
Fehlermeldung ist dabei nicht aussagekräig: "Es ist nicht möglich, eine Methode für
einen Ausdruck aufzurufen, der den Wert NULL hat."
```

Bild 11.34 Ein Skript via psedit öffnen

In diesem Skripteditor lassen sich Skripte mit Eingabeunterstützung für Commandlets,
Funktionen, Variablen, Parameter und Klassenmitglieder erfassen, Skripte starten und Skripte
im Debugger schrittweise durchlaufen. Die Ausgaben der Skripte landen in dem
darunterliegenden Konsolenbereich. Einen dedizierten Ausgabebereich wie in der PowerShell
2.0 ISE gibt es seit PowerShell 3.0 ISE nicht mehr.
Ebenso gibt es im ISE-Skripteditor vorgefertigte Codeausschnitte ("Snippets") (siehe Menü
Edit/Ausschnitt starten bzw. START SNIPPET bzw. Taste STRG + J). Darüber hinaus bietet die neue
ISE auch viele andere Komfortfunktionen, die man von anderen Codeeditoren kennt, zum
Beispiel:
Fehlerhervorhebung während der Eingabe (error indication),
Klammerpaarhervorhebung (brace matching),
Übernahme der Codefarben in die Zwischenablage (rich text copy and paste),
Einklappen von Bereichen (Outlining),
kontextsensitive Hilfe (mit Taste F 1 , zum Beispiel auf dem Namen eines Commandlets),
eine Liste der zuletzt verwendeten Dateien.


```
TIPP: Die PowerShell ISE ru das Show-Command-Fenster für ein Commandlet auf,
wenn man das Commandlet im Editor oder Konsolenbereich markiert und dann Strg +
F 1 aufru.
```
```
TIPP: Über das Menü Anzeigen kann man Skriptbereich und Konsolenbereich alternativ
auch vertikal anordnen.
```
Bild 11.35 PowerShell ISE mit Skriptbereich (oben) und Konsolenbereich (unten)

Bild 11.36 Hervorhebung von Fehlern schon bei der Eingabe


11.4.4 ISE-Skriptdebugger

Der ISE-Debugger erlaubt es, ein Skript bei der Ausführung anzuhalten, um Variableninhalte zu
betrachten oder das Skript in Einzelschritten weiterlaufen zu lassen.
Um das Skript während der Ausführung anzuhalten, setzt man in der Skriptzeile einen
Haltepunkt mit der Taste F 9. Die Zeile wird dadurch rot hinterlegt. Es kann in einem Skript
mehrere Haltepunkte geben. Das Skript startet man innerhalb der ISE ganz normal über die
Taste F 5 oder den Pfeil in der Symbolleiste.
Die Ausführung des Skripts stoppt dann beim Erreichen eines Haltepunkts. Der erreichte
Haltepunkt ist orange hinterlegt, und im Konsolenbereich findet man eine Meldung "Treffer
Zeilenhaltepunkt". Nun kann man im Konsolenbereich die aktuellen Variableninhalte
betrachten, indem man die Variablen abru (siehe folgendes Bild). Dass man sich im Debugger
befindet, zeigt der Konsolenbereich mit [DBG] an.

```
HINWEIS: Die aktuell gelb markierte Zeile ist noch nicht ausgeführt. Wenn darin eine
Variable gesetzt wird, steht der neue Wert im Konsolenbereich noch nicht zur Verfügung.
```
Um das Skript weiterlaufen zu lassen, gibt es drei Optionen:
F 5 : Das Skript läu normal weiter bis zum nächsten Haltepunkt oder Programmende.
F 11 : Ausführung der aktuellen Zeile und Sprung zur nächsten Zeile; es wird gegebenenfalls
in eine Unterroutine gesprungen.
F 10 : Ausführung der aktuellen Zeile und Sprung zur nächsten Zeile; Unterroutinenaufrufe
werden "in einem Rutsch", also nicht schrittweise, ausgeführt.

```
HINWEIS: Bitte beachten Sie, dass Sie den Debugger mit Umschalt + F 5 beenden
müssen, bevor Sie eine Skriptdatei bearbeiten oder das Skript neu starten können.
```

Bild 11.37 PowerShell ISE beim Debugging mit Haltepunkt in Zeile 35 und der aktuellen Ausführung in Zeile 37

11.4.5 Unterschiede zur normalen PowerShell-Konsole

Es gibt ein paar beachtenswerte Unterschiede zwischen ISE und der normalen PowerShell-
Konsole.

Klassische Konsolenanwendungen mit interaktiver
Benutzereingabe

Klassische Konsolenanwendungen mit interaktiver Benutzereingabe wie wmic.exe, diskpart.exe,
cmd.exe, netsh.exe und p.exe werden durch die ISE nicht unterstützt. Kein Problem gibt es
dagegen mit interaktiven PowerShell-Commandlets und -Skripten.
Wenn man eine dieser interaktiven Konsolenanwendungen in der ISE startet, sind drei
Reaktionen möglich:
Die ISE weist darauf hin, dass es nicht möglich ist, und startet die Anwendung nicht.


Die ISE startet die Anwendung, es passiert aber nichts. Mit STRG + C kann man die
Anwendung abbrechen.
Die ISE startet die Anwendung und stürzt ab.
Es stellt sich die Frage, wieso die ISE einige Anwendungen als problematisch erkennt, andere
aber nicht. Die ISE verwaltet dafür eine Liste von Anwendungsnamen in der Variablen
$psUnsupportedConsoleApplications und eine Liste von Zeichenketten und macht einen Volltext-
Vergleich (aber ohne Beachtung der Groß-/Kleinschreibung). Die folgende Abbildung zeigt,
wie die PowerShell reagiert, wenn man eine der in der Liste enthaltenen Anwendungen
aufru.
dass nur sehr wenige Namen im Standard in $psUnsupportedConsoleApplications enthalten
sind.
dass die PowerShell keine Ausgabe macht, wenn man p.exe verwendet, was nicht in der
Liste enthalten ist.
wie man einen Eintrag zu der Liste hinzufügen kann. (Achtung: Dies gilt nur für die aktuelle
Instanz der ISE!)
dass man eine Anwendung in der Liste sowohl mit .exe als auch ohne eintragen muss, damit
es funktioniert, egal, ob der Benutzer p.exe oder p eingibt.

Bild 11.38 Interaktive Konsolenanwendungen in der ISE


Blättern in der ISE

Das Blättern in Ausgaben mit der Funktion more und dem Commandlet Out-Host -Paging
funktioniert nicht in der ISE.

Farben und Titelleiste

Man kann die Farbe der ISE-Konsole nicht über die .NET-Klasse [System.Console] setzen. Nicht
möglich ist also:

```
[console]::BackgroundColor = 'red'
```
Richtig ist stattdessen die Verwendung des Objektmodells der ISE, das man über $psISE
erreicht:

```
$psISE.Options.ConsolePaneBackgroundColor = "red"
```
Alternativ:

```
$host.ui.RawUI.BackgroundColor = "red"
```

Bild 11.39 Inhalt der eingebauten Variablen $psISE

Für den Skriptbereich kann man aber nur $psISE verwenden:

```
$psISE.Options.ScriptPaneBackgroundColor = "red";
```
Auch der Zugang über $host.UI.RawUI ist eingeschränkt. Möglich ist hierüber aber z. B. die
Veränderung des Titels:

```
$host.UI.RawUI.WindowTitle = "Holgers PowerShell IDE"
```
11.4.6 Feststellen, ob ein Skript in der ISE läu

Ob ein Skript innerhalb der ISE läu, können Sie feststellen, indem Sie die eingebaute Variable
$host.name abfragen. Diese Variable liefert sowohl bei der Ausführung im Skript- als auch im
Befehlsbereich "Windows PowerShell ISE Host".


Bild 11.40 Abfrage von $host.name

11.4.7 Remote PowerShell mit der PowerShell ISE

Die PowerShell ISE kann einzelne Befehle und ganze Skripte auf einem entfernten System
ausführen. Dies basiert auf PowerShell Remoting und hat daher die im Kapitel 10
"Fernausführung" geschilderten Voraussetzungen.
Für eine Fernverbindung ru man das Menü File/New Remote PowerShell Tab auf. In dem dann
folgenden Dialog gibt man den Namen oder die IP-Adresse des entfernten Systems ein sowie
optional einen Benutzernamen, wenn die Verbindung mit einem anderen Benutzer erfolgen
soll. Wenn ein Benutzername eingegeben wurde, erscheint ein weiterer Dialog zur
Kennworteingabe.
Die folgende Abbildung zeigt die PowerShell ISE mit vier Registerkarten: Die erste Registerkarte
repräsentiert den lokalen Rechner. Die anderen drei sind Fernverbindungen, die man am
Rechnernamen bzw. an der IP-Adresse im Registerkartentitel erkennt. Eine Fernverbindung
zeigt dann im Konsolenbereich auch den Namen bzw. die IP-Adresse. Die in der Befehlsleiste
angezeigten Befehle sind die auf dem Fernsystem verfügbaren Befehle!

```
HINWEIS: Die Dateien, die man über das File-Menü lädt und speichert, kommen aber
immer vom lokalen System (außer, wenn man auch eine Dateisystemverbindung zu dem
entfernten System aufbaut). Ausgeführt werden Skripte aber dann auf dem Fernsystem!
```

Bild 11.41 PowerShell mit einer lokalen Registerkarte und drei Fernverbindungen

11.4.8 Fernbearbeitung von Dateien mit psedit

Aus einer interaktiven Sitzung innerhalb der ISE heraus kann man mit dem Befehl psedit eine
Datei auf dem entfernten System bearbeiten.


Bild 11.42 Fernbearbeitung einer Datei mit psedit

11.4.9 ISE Praxistipp: Zuklappbare Bereiche und Regionen

Zur Verbesserung der Übersicht in einem Skriptcode kann man in der PowerShell ISE im
Skripteditor Bereiche wie Funktionsrümpfe, Bedingungsblöcke und Schleifen
zusammenklappen (siehe Abbildung). Darüber hinaus kann der Skriptersteller beliebige
zuklappbare Bereiche mit den Schlüsselwörtern #region und #endregion definieren (siehe
folgende Abbildung).


Bild 11.43 Zuklappbare Bereiche in der ISE

11.4.10 Erweiterungen

Es gibt diverse Erweiterungen für die PowerShell ISE. Eine Liste finden Sie unter
https://social.technet.microso.com/wiki/contents/articles/2969.windows-powershell-ise-add-on-
tools.aspx

11.5 PowerShell Script Analyzer

Der PowerShell Script Analyzer ist ein Werkzeug, das eine statische Programmcodeanalyse für
PowerShell-Skripte und ganze PowerShell-Module durchführt. Der PowerShell Script Analyzer
enthält eine Reihe von Regeln, die geprü werden mit dem Ziel, die Einhaltung von
Programmierrichtlinien von Microso zu überprüfen. Ergebnis der Prüfung sind Warnungen und
Fehlermeldungen einschließlich Verbesserungsvorschlägen.
Der PowerShell Script Analyzer ist selbst ein PowerShell-Modul; es kann über die PowerShell-
Gallery (www.powershellgallery.com/packages/PSScriptAnalyzer/) oder direkt über das Github-
Repository bezogen werden, in dem Microso es entwickelt
(https://github.com/PowerShell/PSScriptAnalyzer).

```
NuGet Package Manager
Hersteller: Microso
```

```
Preis: Kostenlos
URL: http://www.powershellgallery.com/packages/PSScriptAnalyzer/
```
Regeln des Script Analyzers

Die folgende Tabelle zeigt die derzeit im Script Analyzer realisierten Regeln.


Tabelle 11.1 Diese Tabelle ist das Ergebnis der Ausführung des Befehls Get-ScriptAnalyzerRule

```
RuleName CommonName Severity Description
PSAvoid-UsingCmdlet-
Aliases
```
```
Avoid Using
Cmdlet Aliases
```
```
Warning An alias is an alternate name or
nickname for a cmdlet or for a
command element, such as a
function, script, file, or
executable file. But when
writing scripts that will
potentially need to be
maintained over time, either by
the original author or another
Windows PowerShell scripter,
please consider using full
cmdlet name instead of alias.
Aliases can introduce these
problems, readability,
understandability and
availability.
PSAvoid-Default-
ValueSwitch-Parameter
```
```
Switch
Parameters
Should Not
Default To True
```
```
Warning Switch parameter should not
default to true.
```
```
PSAvoid-UsingEmpty-
CatchBlock
```
```
Avoid Using
Empty Catch
Block
```
```
Warning Empty catch blocks are
considered poor design
decisions because if an error
occurs in the try block, this
error is simply swallowed and
not acted upon. While this does
not inherently lead to bad
things. It can and this should be
avoided if possible. To fix a
violation of this rule, using
Write-Error or throw statements
in catch blocks.
PSAvoid-GlobalVars No Global
Variables
```
```
Warning Checks that global variables are
not used. Global variables are
strongly discouraged as they
can cause errors across
different systems.
PSAvoidInvokingEmpty-
Members
```
```
Avoid Invoking
Empty Members
```
```
Warning Invoking non-constant
members would cause
```

```
potential bugs. Please double
check the syntax to make sure
members invoked are non-
constant.
```
PSAvoid-Using-
Positional-Parameters

```
Avoid Using
Positional
Parameters
```
```
Warning Readability and clarity should
be the goal of any script we
expect to maintain over time.
When calling a command that
takes parameters, where
possible consider using name
parameters as opposed to
positional parameters. To fix a
violation of this rule, please use
named parameters instead of
positional parameters when
calling a command.
```
PSReserved-
CmdletChar

```
Reserved
Cmdlet Chars
```
```
Warning Checks for reserved characters
in cmdlet names. These
characters usually cause a
parsing error. Otherwise they
will generally cause runtime
errors.
```
PSReserved-Params Reserved
Parameters

```
Warning Checks for reserved parameters
in function definitions. If these
parameters are defined by the
user, an error generally occurs.
```
PSAvoid-ShouldConti-
nueWith-outForce

```
Avoid Using
ShouldContinue
Without
Boolean Force
Parameter
```
```
Warning Functions that use
ShouldContinue should have a
boolean force parameter to
allow user to bypass it.
```
PSAvoid-UsingDepre-
cated-Manifest-Fields

```
Avoid Using
Deprecated
Manifest Fields
```
```
Warning "ModuleToProcess" is obsolete
in the latest PowerShell version.
Please update with the latest
field "RootModule" in manifest
files to avoid PowerShell
version inconsistency.
```
PSProvide-
DefaultParameterValue

```
Default
Parameter
Values
```
```
Warning Parameters must have a default
value. To fix a violation of this
rule, please specify a default
value for all parameters
```

PSAvoid-Uninitialized-
Variable

```
Initializing non-
global variables
```
```
Warning Non-global variables must be
initialized. To fix a violation of
this rule, please initialize non-
global variables.
```
PSAvoid-UsingUser-
NameAnd-PassWord-
Params

```
Avoid Using
Username and
Password
Parameters
```
```
Error Functions should only take in a
credential parameter of type
PSCredential instead of
username and password
parameters.
```
PSAvoid-
UsingComputerName-
Hardcoded

```
Avoid Using
ComputerName
Hardcoded
```
```
Error The ComputerName parameter
of a cmdlet should not be
hardcoded as this will expose
sensitive information about the
system.
```
PSAvoid-UsingCon-
vertToSecure
StringWith-PlainText

```
Avoid Using
SecureString
With Plain Text
```
```
Error Using ConvertTo-SecureString
with plain text will expose
secure information.
```
PSAvoid-
UsingInternalURLs

```
Avoid Using
Internal URLs
```
```
Information Using Internal URLs in the
scripts may cause security
problems.
```
PSAvoid-Using-Invoke-
Expression

```
Avoid Using
Invoke-
Expression
```
```
Warning The Invoke-Expression cmdlet
evaluates or runs a specified
string as a command and
returns the results of the
expression or command. It can
be extraordinarily powerful so it
is not that you want to never
use it but you need to be very
careful about using it. In
particular, you are probably on
safe ground if the data only
comes from the program itself.
If you include any data provided
from the user - you need to
protect yourself from Code
Injection. To fix a violation of
this rule, please remove Invoke-
Expression from script and find
other options instead.
```
PSAvoidUsing PlainText- Avoid Using Warning Password parameters that take


ForPassword Plain Text For
Password
Parameter

```
in plaintext will expose
passwords and compromise the
security of your system.
```
PSAvoidUsing
WMICmdlet

```
Avoid Using
Get-WMIObject,
Remove-WMI-
Object, Invoke-
WmiMethod,
Register-Wmi-
Event, Set-Wmi-
Instance
```
```
Warning Depricated. Starting in Windows
PowerShell 3.0, these cmdlets
have been superseded by CIM
cmdlets.
```
PSAvoid-UsingWrite-
Host

```
Avoid Using
Write-Host
```
```
Warning Write-Host or Console.Write
should not be used because it
may not work in some hosts or
there may even be no hosts at
all. Use Write-Output instead.
```
PSUseOutput
TypeCorrectly

```
Use Output
Type Correctly
```
```
Information The return types of a cmdlet
should be declared using the
OutputType attribute.
```
PSMissing-ModuleMani-
festField

```
Module
Manifest Fields
```
```
Warning Some fields of the module
manifest (such as
ModuleVersion) are required.
```
PSPossible-Incorrect-
Comparison-WithNull

```
Null
Comparison
```
```
Warning Checks that $null is on the le
side of any equaltiy
comparisons (eq, ne, ceq, cne,
ieq, ine). When there is an array
on the le side of a null equality
comparison, PowerShell will
check for a $null IN the array
rather than if the array is null. If
the two sides of the
comaprision are switched this is
fixed. Therefore, $null should
always be on the le side of
equality comparisons just in
case.
```
PSProvide Comment-
Help

```
Basic Comment
Help
```
```
Information Checks that all cmdlets have a
help comment. This rule only
checks existence. It does not
check the content of the
comment.
```

PSUseAppro-vedVerbs Cmdlet Verbs Warning Checks that all defined cmdlets
use approved verbs. This is in
line with PowerShell's best
practices.

PSUseCmd-letCorrectly Use Cmdlet
Correctly

```
Warning Cmdlet should be called with
the mandatory parameters.
```
PSUseDecla-
redVarsMore
ThanAssigments

```
Extra Variables Warning Checks that variables are used
in more than just their
assignment. Generally this is a
red flag that a variable is not
needed. This rule does not
check if the assignment and
usage are in the same function.
```
PSUsePS Credential-
Type

```
PSCredential Warning Checks that cmdlets that have a
Credential parameter accept
PSCredential. This comes from
the PowerShell teams best
practices.
```
PSShould Process Should Process Warning Checks that if the
SupportsShouldProcess is
present, the function calls
ShouldProcess/ShouldContinue
and vice versa. Scripts with one
or the other but not both will
generally run into an error or
unexpected behavior.

PSUse-
ShouldProcessFor-
StateChan-
gingFunctions

```
Use
ShouldProcess
For State
Changing
Functions
```
```
Warning Functions that have verbs like
New, Start, Stop, Set, Reset,
Restart that change system
state should support
‚ShouldProcess'.
```
PSUseSingular Nouns Cmdlet Singular
Noun

```
Warning Cmdlet should use singular
instead of plural nouns.
```
PSDSCDsc TestsPresent Dsc tests are
present

```
Information Every DSC resource module
should contain folder "Tests"
with tests for every resource.
Test scripts should have
resource name they are testing
in the file name.
```

PSDSC-DscExamples
Present

```
DSC examples
are present
```
```
Information Every DSC resource module
should contain folder
"Examples" with sample
configurations for every
resource. Sample
configurations should have
resource name they are
demonstrating in the title.
```
PSDSCUse-Verbose-
MessageIn-DSC
Resource

```
Use verbose
message in DSC
resource
```
```
Information It is a best practice to emit
informative, verbose messages
in DSC resource functions. This
helps in debugging issues when
a DSC configuration is executed.
```
PSDSC-UseIdentical-
Mandatory-Parameters-
ForDSC

```
Use identical
mandatory
parameters for
DSC
Get/Test/Set
TargetResource
functions
```
```
Error The Get/Test/Set
TargetResource functions of
DSC resource must have the
same mandatory parameters.
```
PSDSC-UseIdentical-
Parameters-ForDSC

```
Use Identical
Parameters For
DSC Test and
Set Functions
```
```
Error The Test and Set-
TargetResource functions of
DSC Resource must have the
same parameters.
```
PSDSC-StandardDSC-
Functions InResource

```
Use Standard
Get/Set/Test
TargetResource
functions in
DSC Resource
```
```
Error DSC Resource must implement
Get, Set and Test-
TargetResource functions. DSC
Class must implement Get, Set
and Test functions.
```
PSDSC-Return-
CorrectTypes-ForDSC-
Functions

```
Return Correct
Types For DSC
Functions
```
```
Information Set function in DSC class and
Set-Target-Resource in DSC
resource must not return
anything. Get function in DSC
class must return an instance of
the DSC class and Get-Target-
Resource function in DSC
resource must return a
hashtable. Test function in DSC
class and Get-TargetResource
function in DSC resource must
return a boolean.
```

Commandlets des Script Analyzers

Das PSScriptAnalyzer-Modul stellt zwei Commandlets bereit:
Auflisten der Regeln: Get-ScriptAnalyzerRule [-CustomizedRulePath <string[]>] [-Name
<string[]>] [<CommonParameters>] [-Severity <string[]>]:
Ausführen der Prüfung unter Ein- bzw. Ausschluss von Regeln: Invoke-ScriptAnalyzer [-
Path] <string> [-CustomizedRulePath <string[]>] [-ExcludeRule <string[]>] [-
IncludeRule <string[]>] [-Severity <string[]>] [-Recurse] [<CommonParameters>]

Einsatzbeispiele

Es folgen vier Einsatzbeispiele:
Anzeige aller PowerShell-Analyzer-Regeln in einer grafischen Tabelle: Get-
ScriptAnalyzerRule | out-gridview
Speichern aller PowerShell-Analyzer-Regeln in einer von Excel lesbaren CSV-Datei: Get-
ScriptAnalyzerRule | export-csv w:\temp\rules.csv -Delimiter ";"
Ausführen der Analyse für ein Skript: Invoke-ScriptAnalyzer X:\meinskript.ps 1
Ausführen der Analyse für ein Modul: Invoke-ScriptAnalyzer X:\meineModule\pscx

Bild 11.44 Beispielhae Auswertung des Script Analyzers für das Skript "Soware_Installation.ps1"

11.6 PowerShell Analyzer

Der PowerShell Analyzer von Karl Prosser (nicht zu verwechseln mit dem PowerShell Script
Analyzer von Microso!) bietet gegenüber PowerShellPlus noch zwei zusätzliche Funktionen:
Mehrere getrennte Ablaufumgebungen (sogenannte Runspaces)
Visualisierung der Objekte in der Pipeline in einer Tabelle (siehe nächste Abbildung) oder
einem Diagramm


Allerdings fehlen auch zwei wichtige Funktionen: IntelliSense für Klassen und Klassenmitglieder
sowie ein Debugger.

```
PowerShell Analyzer
Hersteller: Shell Tools, LLC
Preis: Kostenfrei
URL: http://www.powershellanalyzer.com
```
Bild 11.45 PowerShell Analyzer

11.7 PowerShell Tools for Visual Studio

Die PowerShell Tools for Visual Studio sind eine Erweiterung für Visual Studio seit Version 2012.
Seit Visual Studio 2015 werden sie bereits als optionale Installationskomponente mit dem
Visual Studio-Setup mitgeliefert. Seit Visual Studio 2017 sind sie ein im Setup zu installierender
"Workload".


Mit dieser Erweiterung kann man PowerShell-Skriptdateien in Visual Studio komfortabel
bearbeiten (mit Farbhervorhebung, IntelliSense-Eingabeunterstützung und einklappbaren
Regionen) und ausführen. Mehrere Skriptdateien können zu einem PowerShell-Projekt
zusammengefasst werden (Projektvorlage "PowerShell Script Project", Dateityp .psproj). Die
Skriptausgaben laden im Output-Fenster von Visual Studio. Das Debugging wird unterstützt.
Auch PowerShell-Module kann man per Vorlage anlegen.

```
PowerShell Tools for Visual Studio
Hersteller: Adam R. Driscoll [https://poshtools.com]
Preis: Kostenlos
URL: Seit Visual Studio 2017 werden die PowerShell Tools bereits im Setup des
Produkts mitgeliefert. Für Visual Studio 2012, 2013 und 2015 gibt es die
PowerShell Tools als getrennten Download:
ƒ▪ PowerShell Tools for Visual Studio 2012:
https://marketplace.visualstudio.com/items?
itemName=AdamRDriscoll.PowerShellToolsforVisualStudio 2012
ƒ▪ PowerShell Tools for Visual Studio 2013:
https://marketplace.visualstudio.com/items?
itemName=AdamRDriscoll.PowerShellToolsforVisualStudio 2013
ƒ▪ PowerShell Tools for Visual Studio 2015:
https://marketplace.visualstudio.com/items?
itemName=AdamRDriscoll.PowerShellToolsforVisualStudio 2015
```
```
TIPP: Für das ältere Visual Studio 2010 gibt es als Alternative das weniger mächtige
PowerStudio [https://marketplace.visualstudio.com/items?
itemName=IanDavis.PowerStudio].
```

Bild 11.46 Bearbeiten einer PowerShell-Skript-Datei in einem PowerShell-Projekt in Visual Studio

11.8 PowerShell Pro Tools for Visual Studio

Die PowerShell Pro Tools for Visual Studio (nicht zu verwechseln mit den kostenfreien
"PowerShell Tools for Visual Studio" des gleichen Autors) bieten drei weitere Funktionen
innerhalb von Visual Studio seit Version 2015:
Unterstützung für die Erstellung grafischer Windows Forms-Benutzeroberflächen
Unterstützung für die Erstellung grafischer WPF- und Windows Forms-Benutzeroberflächen
Packaged Scripts: Verpacken von Skripten in ausführbare Dateien (.EXE)


```
Performance-Analyse von Skripten
Code-Konvertierung von C# in die PowerShell-Skriptsprache
PowerShell Tools for Visual Studio
Hersteller: Adam R. Driscoll (Ironman Soware)
Preis: 99,99 US-Dollar
URL: https://ironmansoware.com/powershell-pro-tools
```
11.9 Visual Studio Developer PowerShell

Nicht verwechseln mit den zuvor gestellten "PowerShell Tools" für Visual Studio darf man die
"Visual Studio Developer PowerShell". Die "Visual Studio Developer PowerShell" ist ein auf
Windows PowerShell 5.1 basierendes Konsolenfenster, das es seit Visual Studio 2019 und in
zwei Firmen gibt:

1. Ein Fenster innerhalb von Visual Studio, das man über Tools/Command Line/Developer
    PowerShell öffnet.
2. Eine eigenständige Anwendung, die automatisch bei Installation von Visual Studio im
    Startmenü von Windows eingerichtet wird.
In der "Visual Studio Developer PowerShell" sind einige Kommandozeilenbefehle (MSBuild.exe,
cl.exe, NMake.exe, ildasm.exe usw) sowie zahlreiche Umgebungsvariablen (siehe nächste
Abbildung) zusätzlich zu den Standardfunktionen der Windows PowerShell eingerichtet.


Bild 11.47 Visual Studio Developer PowerShell innerhalb von Visual Studio


Bild 11.48 Visual Studio Developer PowerShell außerhalb von Visual Studio


11.10 NuGet Package Manager Console (PMC)

Der NuGet Package Manager ist ein Teil von Visual Studio seit Version 2012 (bzw. eine
kostenfreie Erweiterung für Visual Studio 2010) zum Verwalten von Erweiterungspaketen.
Neben einem GUI-Werkzeug gibt es die NuGet Package Manager Console (PMC).
Die PMC basiert auf der Windows PowerShell 5.1 und unterstützt alle PowerShell-Befehle und
zusätzlich einige Befehle für die NuGet-Paketverwaltung in Visual Studio-Projekten (z. B. Find-
Package, Install-Package, Uninstall-Package). Eine Erläuterung dieser Commandlets finden Sie
unter https://docs.microso.com/de-de/nuget/reference/powershell-reference.

Bild 11.49 NuGet Package Manager Console in Visual Studio

```
HINWEIS: Einige NuGet-Pakete wie z. B. ADO.NET Entity Framework und Entity
Framework Core erweitern die PMC um zusätzliche Commandlets wie Add-Migration,
Script-Migration und Update-Database.
```

11.11 Visual Studio Code mit PowerShell-Erweiterung

PowerShell-Skripte kann man auch mit dem von Microso-Plattformen unabhängigen und
kostenfreien Editor Visual Studio Code (VSCode) entwickeln. Dafür ist dort die Erweiterung
"VSCode-PowerShell" [github.com/PowerShell/vscode-powershell] zu installieren (siehe
Abbildung). Die Version 1.0 dieser Erweiterung ist am 10.5.2017 erschienen. Seitdem sind
regelmäßig Updates erschienen. Die Weiterentwicklung der Erweiterung erfolgt ähnlich rasant
wie die Weiterentwicklung des Editors selbst (siehe https://github.com/PowerShell/vscode-
powershell).

Bild 11.50 Installation der PowerShell-Erweiterung in Visual Studio Code

VSCode läu nicht nur unter Windows (ab Windows 7), sondern auch unter macOS und Linux.
VSCode ist keine Portierung des großen Visual Studio, sondern ein eigenständiges Produkt. Die
Unterstützung für VSCode ist die logische Folge daraus, dass Microso Power-Shell nun auch
auf anderen Betriebssystemen anbietet.


```
HINWEIS: Die PowerShell-Erweiterungen in VSCode verwenden die
Sowarekomponente "PowerShell Editor Services"
[https://github.com/PowerShell/PowerShellEditorServices], die über das Language Server
Protocol (LSP) mit dem Editor kommunizieren.
```
VSCode bietet mit PowerShell-Erweiterung u. a. folgende Funktionen:
Syntaxfarbhervorhebung
Codeausschnitte (Code Snippets)
Eingabeunterstützung für Commandlets, Funktionen, Variablen, Parameter und
Klassenmitglieder
Vorschläge zur Verbesserung von Skripten durch PowerShell Script Analyzer
Go to Definition/Find References für Commandlets und Variablen
Starten von Skripten (Taste F 5 ) oder Skriptteilen (Taste F 8 )
Aufruf der Hilfe mit STRG + F 1
Lokales Skriptdebugging

Bild 11.51 In Visual Studio Code gibt es stilistische Verbesserungsvorschläge für PowerShell-Skripte (z. B. Verzicht auf
Verwendungen von Aliasen) mit dem PowerShell Script Analyzer.


Bild 11.52 Ausführen eines PowerShell-Skripts in VSCode

```
PowerShell Extension for Visual Studio Code (VSCode)
Hersteller: Microso
Preis: kostenfrei
URL: https://marketplace.visualstudio.com/items?itemName=ms-vscode.PowerShell
Github: https://github.com/PowerShell/vscode-powershell
```
```
TIPP: Die in Visual Studio Code integrierte PowerShell liefert bei $host.name die
Zeichenkette "Visual Studio Code Host". Dies ist der Host, der PowerShell-Skripte
innerhalb von Visual Studio Code ausführt. Wenn man in der PowerShell aber im
Terminalbereich eine PowerShell-Konsole (powershell.exe oder pwsh.exe) direkt öffnet,
dann liefert $host.name die Zeichenkette "ConsoleHost".
```
11.12 PowerShell-Erweiterungen für andere Editoren


Neben VSCode gibt es auch andere Editor-Erweiterungen, die auf den "PowerShell Editor
Services" [https://github.com/PowerShell/PowerShellEditorServices] basieren:
PowerShell-Plug-in für IntelliJ: github.com/ant-druha/intellij-powershell
PowerShell-Plug-in für Emacs: github.com/kiennq/lsp-powershell
PowerShell-Plug-in für Vim: github.com/coc-extensions/coc-powershell

11.13 PowerShell Web Access (PSWA)

Seit Windows Server 2012 gibt es neben der Standard-PowerShell-Konsole und der ISE eine
webbasierte Konsole für die PowerShell unter dem Namen "Windows PowerShell Web Access"
(PSWA). Administratoren können hier auf einer zugangsgeschützten Website PowerShell-
Befehle eingeben und das Ergebnis wie in der lokalen Konsole betrachten. Da die Website nicht
auf Silverlight, sondern auf HTML basiert, kann sie auch von Smartphones genutzt werden. Ein
Administrator muss also nun auch im Urlaub am Strand befürchten, dass sein Chef ihn anru
und bittet, "mal eben" etwas umzukonfigurieren.

```
TIPP: Mit PSWA kann man nicht nur den Server verwalten, auf dem PSWA läu, sondern
jeden Rechner mit aktiviertem PowerShell-Remoting im Netzwerk.
```
Installation von PSWA

Für die Nutzung der PSWA ist diese zuerst zu installieren, da sie nicht zum
Standardinstallationsumfang von Windows Server 2012 gehört.

Schritt 1: Installation der Rollen und Features

Im Server Manager sind folgende optionalen Bausteine des Windows Server 2012 zu aktivieren:
Rolle "Web Server (IIS)"
Feature "Windows PowerShell/Windows PowerShell Web Access"


Bild 11.53 Hinzufügen der Rolle "Web Server (IIS)"

Bild 11.54 Einfügen des Features "Windows PowerShell/Windows PowerShell Web Access"


```
TIPP: PSWA kann auch über die PowerShell selbst installiert werden mit dem
Commandlet Install-WindowsFeature aus dem Modul "ServerManager":
Install-WindowsFeature -name web-server,
windowspowershellwebaccess
```
Schritt 2: Anlegen der Webanwendung im IIS

Durch die Installation der Rollen und Features wurde die PSWA-Webanwendung noch nicht im
IIS angelegt, wohl aber gibt es nun ein PowerShell-Modul "PowerShellWebAccess" mit dem
Commandlet Install-PswaWebApplication, das dies ermöglicht.
Mit dem Parameter -WebSiteName kann man eine bestehende IIS-Website angeben, in der PSWA
installiert werden soll. Dabei lässt sich dann mit -WebApplicationName der Name der IIS-
Anwendung innerhalb dieser Website festlegen.
Wünscht man eine Standardeinrichtung in der Standardwebsite unter dem Standardnamen
"PSWA", kann man einfach Folgendes ausführen:

```
Install-PswaWebApplication -UseTestCertificate
```
Die Website ist dann erreichbar unter

```
https://localhot/pswa
```
Die Verwendung von UseTestCertificate sorgt dafür, dass die Website mit einem selbst
erstellten SSL-Zertifikat ausgestattet wird. Dies kann man später durch ein offizielles Zertifikat
ersetzen.

```
TIPP: Die Verwendung von SSL ist dringend empfohlen, da sonst Benutzername und
Kennwort sowie alle Befehle unverschlüsselt übertragen würden. Wenn PSWA mit SSL
installiert würde, kommt es beim Versuch des Aufrufs über http ohne SSL zur
Fehlermeldung: "This website uses the Secure Sockets Layer (SSL) protocol, and requires
an HTTPS address. Please update the URL in your browser."
Wenn ein Testzertifikat verwendet wurde, warnt der Browser beim Aufruf mit HTTPS:
"The security certificate presented by this website was not issued by a trusted certificate
authority".
```
```
HINWEIS: Falls Sie den IIS manuell konfigurieren möchten, sei hier auf das Dokument
http://technet.microso.com/en-us/library/hh831611.aspx verwiesen.
```

Schritt 3: Zugriffsrechte vergeben

Im Standard darf sich niemand bei PSWA anmelden. Mit dem Commandlet Add-
PswaAuthorizationRule vergibt man Zugriffsrechte, z. B. erlaubt es die nachstehende Regel allen
Administratoren der Domäne "FBI", über die PSWA-Instanz auf diesem Computer eine
Verbindung zu allen Computern mit allen PowerShell-Konfigurationen aufzunehmen.

```
Add-PswaAuthorizationRule -usergroupname FBI\administrators -ComputerName *
```
- ConfigurationName *

Mit –UserName kann man Rechte für einzelne Benutzer vergeben. Mit -ComputerGroupName lassen
sich die Zugriffsrechte auf Basis von Active-Directory-Computergruppen vergeben. Mit Test-
PswaAuthorizationRule kann man prüfen, ob ein Benutzer Zugang zu einem bestimmten
Computer über PSWA haben wird.
Mit dem Commandlet Get-PswaAuthorizationRule listet man die vergebenen Rechte auf. Mit
Remove-PswaAuthorizationRule lassen sich Rechte wieder löschen.

```
HINWEIS: Neu seit Windows Server 2012 R 2 ist, dass man die Zugriffsrechte unter
Angabe des -Credential-Parameters auch von einem entfernten System aus verwalten
kann.
```
Schritt 4: Konfigurationsänderungen (optional)

Im Standard dürfen sich nur drei Benutzer gleichzeitig an PSWA anmelden. Diese Einstellung
muss man in der Datei c:\Windows\Web\PowerShellWebAccess\wwwroot\web.config vornehmen.
Dort gibt es den Eintrag:

```
<appSettings>
<add key="maxSessionsAllowedPerUser" value="3"/>
</appSettings>
```
Die PSWA hat zudem eine Timeout-Zeit von 20 Minuten. Diese Einstellung ändert man über:

```
<sessionState timeout="20" />
```
Anmelden an PSWA

Die folgende Abbildung zeigt die PSWA-Anmeldeseite.


```
ACHTUNG: Die Angabe eines Computernamens des zu verwaltenden Computers ist
Pflicht. Die PSWA eröffnet dann eine PowerShell-Session auf dem genannten Computer.
Die Angabe "localhost" ist erlaubt, um den Computer zu verwalten, auf dem PSWA
gehostet wird.
```
Bild 11.55 Anmeldung bei PSWA

Verwenden der PSWA

Die PSWA-Webseite zeigt sich nach der Anmeldung im gewohnten Blau mit weißer Schri. In
Gelb erscheinen die eingegebenen Befehle. Die Befehlseingabe erfolgt nicht direkt nach dem
Prompt (>) wie bei der Standardkonsole, sondern in einer eigenen Zeile darunter.


```
ACHTUNG: Mehrzeilige Befehle erzeugt man in der PSWA durch Drücken von Shi +
Enter, während dies ja in der Standardkonsole durch Enter erfolgt, wenn der Befehl
noch nicht abgeschlossen ist. In der PSWA löst Enter allein immer die Befehlsausführung
aus!
```
Bild 11.56 Mehrzeilige Befehlseingabe in der PSWA-Konsole

```
TIPP: Die Farben der PSWA kann man wie in der Standardkonsole bei Write-Host setzen,
z. B. Write-Host "Hallo Holger" - foregroundcolor red -backgroundcolor white.
Auch die Veränderung der Farben für die ganze aktuelle Sitzung ist möglich über eine
eingebaute Variable $host:
$host.UI.RawUI.BackgroundColor = "darkgreen"
Die $host-Variable enthält wie bei den anderen Konsolen auch eine Instanz von
ServerRemoteHost. Die Instanz nennt sich "ServerRemoteHost", Version 1.0.0.0.
```

Bild 11.57 Verbindungsabbruch in der PSWA

Falls es zu einem Verbindungsabbruch kommt, bemüht sich die PSWA, die Verbindung ohne
Neuanmeldung wieder aufzubauen.

```
HINWEIS: Neu seit Windows Server 2012 R 2 sind folgende Funktionen:
Man kann mehrere PSWA-Sitzungen in verschiedenen Registerkarten eines Browsers
öffnen. Vorher musste man mehrere Browserinstanzen dafür starten.
Man kann den Zustand einer PSWA-Sitzung abspeichern (Schaltfläche Save rechts unten
im Bildschirm) und sich später wieder verbinden.
```
11.14 Azure Cloud Shell

Das Azure-Web-Portal zum Verwalten der Microso-Cloud-Dienste bietet eine in den Browser
integrierte PowerShell-Konsole, die die Verwaltung über die Kommandozeile ermöglicht.
Nutzer können in der Cloud Shell zwischen PowerShell und der bash wählen. Die Shell ist auch
in den neuen Azure-Verwaltungs-Apps für iOS und Android verfügbar.

Bild 11.58 Einrichten der Azure Cloud Shell


11.15 ISE Steroids

Die ISE Steroids sind ein Erweiterungspaket für die PowerShell ISE, die zahlreiche
Komfortfunktionen ergänzt, z. B.:
Konsole kann als eigenständiges Fenster aus der ISE herausgelöst werden,
automatisches Einrücken,
Liste aktueller Variablenwerte,
Liste der Funktionen in einer Skriptdatei zum direkten Anspringen der Funktion,
Vorschläge für Skriptverbesserungen,
Umbenennen von Funktionen und Variablen,
erweiterte Suchfunktion,
Signieren von Skripten,
Prüfen der Kompatibilität zu früheren PowerShell-Versionen,
Anlegen von eigenen Code-Snippets,
Integrieren von WPF-Oberflächen in PowerShell-Skripte,
kontextsensitive Hilfe,
Verpacken eines PowerShell-Skripts in eine EXE-Datei.
ISE Steroids
Hersteller: Dr. Tobias Weltner
Preis: Privatlizenz: 39 Dollar, Kommerzieller Lizenz: 190 Dollar. 10 Tage kostenfreier
Test.
URL: https://powershell.one/isesteroids/quickstart/overview

ISE Steroids kann man per PowerShellGet installieren und auch aktualisieren:

```
Install-Module -Name isesteroids -Scope CurrentUser -force
```

Bild 11.59 Durch die ISE Steroids wird die Symbolleiste der ISE stark erweitert.

11.16 PowerShellPlus

PowerShellPlus besteht aus einer verbesserten PowerShell-Konsole (PowerShellPlus Host), die
IntelliSense unterstützt, und einem damit verbundenen Editor (PowerShellPlus Editor).
PowerShellPlus war der erste Editor und die erste PowerShell-Konsole mit IntelliSense.
Inzwischen ist aber die PowerShell ISE von Microso fast ebenbürtig.
PowerShellPlus war ein kommerzielles Produkt, ist aber seit 2012 kostenfrei.

```
PowerShellPlus
Hersteller: Idera
Preis: Kostenfrei
URL: https://www.idera.com/productssolutions/freetools/powershellplus/
```
Bemerkenswerte Funktionen im Vergleich zur ISE sind:
Die Konsole ist eine Weiterentwicklung der normalen Windows-Konsole und versteht daher
alle Befehle, welche die von Microso gelieferte PowerShell-Konsole auch versteht, also
auch interaktive klassische Befehle wie p.exe.
Mitschneiden von Eingaben in der Konsole, die über Tastenkürzel wieder aufgerufen
werden können
Anzeige aller aktuellen Variablen und Details zu ihren Inhalten
Transparente Darstellung des Konsolenfensters möglich
Direkter Zugriff auf PowerShell-Profilskripte


Bild 11.60 IntelliSense für Commandlet-Namen

Bild 11.61 Eine Variante von IntelliSense für Commandlet-Namen


Bild 11.62 IntelliSense für Variablennamen


Bild 11.63 Debugging mit Einzelschrittmodus


Bild 11.64 Anzeige aller aktuellen Variablen und Details zu ihren Inhalten

11.17 PoshConsole

PoshConsole ist eine grafische Konsole für die PowerShell, die mithilfe der neuen .NET-GUI-
Technik "Windows Presentation Foundation" (WPF) geschrieben ist. In der PoshConsole kann
man direkt Grafiken ausgeben (siehe nächste Abbildung).

```
PoshConsole
Hersteller: Joel Bennett
Preis: Kostenfrei
URL: https://github.com/Jaykul/PoshConsole
```

Bild 11.65 Grafische Möglichkeiten der PoshConsole (Quelle: https://www.youtube.com/embed/x 6 A 70 RRkW_Y?autoplay= 1 )

11.18 PowerGUI

PowerGUI ist ein weiterer Editor für die PowerShell. Nach der Übernahme von Quest durch Dell
wurde PowerGUI eingestellt. Eine alte Version findet man aber immer noch im Netz.

```
PowerGUI
Hersteller: Dell (früher: Quest Soware)
Preis: Kostenfrei
URL: https://www.chip.de/downloads/PowerGUI_35180783.html
```
11.19 PrimalScript

Der Universaleditor PrimalScript enthält schon seit Version 4.1 Unterstützung für die Erfassung
von PowerShell-Skripten.


```
PrimalScript
Hersteller: Sapien
Preis: 399 Dollar
URL: http://www.primalscript.com
```
Bild 11.66 Ausgabe eines PowerShell-Skripts in PrimalScript


Bild 11.67 IntelliSense für Commandlets


Bild 11.68 IntelliSense für Klassennamen

11.20 CIM Explorer for PowerShell ISE

Mit dem CIM Explorer for PowerShell Integrated Scripting Environment, dem bei PowerShell
mitgelieferten Editor, können PowerShell-Nutzer die vielen Tausend WMI-Klassen in Windows
erforschen und einfache PowerShell-Skripte zum Abrufen von WMI-Metadaten und WMI-
Instanzen erzeugen lassen.
Den CIM Explorer gibt es kostenfrei in der Microso TechNet Gallery. Voraussetzung sind
PowerShell 3.0 oder 4.0 und .NET Framework 4.5 oder 4.5.1. In der Vergangenheit konnte man
diese Klassen mit den WMI Administrative Tools erforschen. Allerdings laufen diese als ActiveX-
Steuerelemente für den Internet Explorer entwickelten Werkzeuge nicht mehr einwandfrei seit
Windows 8.x.

```
CIM Explorer for PowerShell ISE
Hersteller: Microso
```

```
Preis: Kostenfrei
URL: http://gallery.technet.microso.com/PoweShell-ISE-Addon-CIM- 5 c 9 af 37 a/
```
Das folgende Bild zeigt die Generierung eines PowerShell-Skripts im CIM Explorer, nachdem
man WMI-Namensraum und WMI-Klasse gewählt hat.

Bild 11.69 CIM Explorer


# 12 Windows PowerShell Core

# 5.1 in Windows Nano

# Server

In Windows Nano Server steht nicht die vollständige Windows
PowerShell 5.1, sondern nur eine abgespeckte Variante zur
Verfügung, die sich Windows PowerShell Core 5.1 nennt und
nicht mit der plattformneutralen PowerShell Core seit Version 6.0
verwechselt werden darf.

Bild 12.1 Beim Abruf der Variablen $psversiontable meldet sich die PowerShell auf
Nano Server genauso wie bei den anderen Server 2016-Varianten mit der
Versionsnummer 5.1. Die "PSEdition" zeigt aber "Core" an.


###### 12.1 Installation

PowerShell Core 5.1 ist in Windows Nano Server 2016 und
Windows Nano Server 1709 enthalten und kann nicht getrennt
installiert werden.

###### 12.2 PowerShell-Skriptsprache

Die PowerShell-Skriptsprache steht in Windows PowerShell Core
komplett zur Verfügung.

###### 12.3 Werkzeuge

Da Nano Server selbst keine Oberfläche besitzt, ist nur eine
Fernverwaltung mit PowerShell oder anderen Werkzeugen
möglich.

###### 12.4 Fehlende Funktionen

In PowerShell Core 5.1 folgende Commandlets und Features
(Quelle: docs.microso.com/de-de/windows-server/get-
started/powershell-on-nano-server):

Typadapter [ADSI] und [WMI]


Enable-PSRemoting, Disable-PSRemoting (PowerShell-
Remoting ist in Nano Server immer aktiviert).

Alle WMI-Commandlets der ersten Generation: Get-
WmiObject, Invoke-WmiMethod, Register-WmiEvent,
Remove-WmiObject, Set-WmiInstance (verfügbar sind aber
die neuen WMI-Commandlets mit "CIM" im Namen, z. B. Get-
CimInstance, Invoke-CimMethod, Get-Cim-Class usw.)

Geplante Auräge und das PSScheduledJob-Modul

Computer-Commandlets für den Beitritt zu einer Domäne {
Add | Remove }

Reset-ComputerMachinePassword, Test-
ComputerSecureChannel

Profilskripte (man kann ein Startskript für eingehende
Remoteverbindungen mit Set-PSSessionConfiguration
hinzufügen)

Clipboard-Command

EventLog-Commandlets { Clear | Get | Limit | New | Remove |
Show | Write } (verfügbar sind New-WinEvent and Get-
WinEvent)

Get-PfxCertificate

TraceSource-Commandlets { Get | Set }

Counter-Commandlets { Get | Export | Import }

Einige webbezogene Commandlets { New-WebServiceProxy,
Send-MailMessage, ConvertTo-Html }

Protokollierung und Ablaufverfolgung mit dem
PSDiagnostics-Modul


Get-HotFix

Commandlets für implizites Remoting { Export-PSSession |
Import-PSSession }

New-PSTransportOption

PowerShell-Transaktionen und Transaktions-Commandlets {
Complete | Get | Start | Undo | Use }

PowerShell-Workflows

Out-Printer

Update-List


# 13 PowerShell 7 für

# Windows, Linux und

# macOS

Dieses Kapitel beschäigt sich mit der plattformneutralen
PowerShell 7. Sie können dieses Kapitel überspringen, wenn Sie
nur die klassische Windows PowerShell einsetzen wollen.

## 13.1 Motivation für den Einsatz der

## PowerShell 7 auf Linux und

## macOS

Die berechtigte Frage ist, wozu Microso überhaupt eine
Portierung der PowerShell auf Linux und macOS erstellt hat, wo
es dort doch mit bash, ksh, tcsh, zsh, fish & Co viele etablierte
Shells gibt.

Microso ist seit den Strategieänderungen des neuen Microso-
Chefs Satya Nadella nicht mehr wie bisher die "Windows-Firma",


sondern versteht sich als Cross-Plattform-Sowarehersteller (vgl.
das Buch "Hit Refresh" von Satya Nadella,
[www.faz.net/aktuell/wirtscha/unternehmen/microso-chef-
satya-nadella-veroeffentlicht-buch-15219347.html]). Produkte
wie Visual Studio Code, .NET Core, ASP.NET Core laufen auch auf
Linux und macOS. Entity Framework läu zusätzlich auch auf
Android und iOS. Den Microso SQL Server gibt es auch für Linux.
Microso ist inzwischen im Vorstand der Linux Foundation
[www.linuxfoundation.org] und verdient in seiner Cloud "Azure"
Geld mit dem Betrieb von Linux-Servern. Eine
plattformübergreifende Shell zu haben, bringt Microso Vorteile
im Management seiner Cloud. Allerdings gibt es die bash Shell
auch für Windows, Microso liefert sie sogar mittlerweile als
Bestandteil von Windows 10/11 aus (als Teil des Windows
Subsystem for Linux - WSL).

Der große Vorteil der PowerShell gegenüber bash & Co ist seine
Objektorientierung basierend auf den Commandlets, die das
Zusammenspiel ganz unterschiedlicher Werkzeuge ermöglicht. In
den textbasierten Shells der Linux-Welt ist das Koppeln von
Kommandozeilenwerkzeugen per Textauswertung mit Befehlen
wie grep und awk mitunter eine mühsame Arbeit.

Eingefleischte Windows-Benutzer müssen im Zuge der Öffnung
von Microso für andere Plattformen nun auch häufiger andere
Betriebssysteme, insbesondere Linux, verwenden. Dafür gibt es
gute Gründe, z. B.:

```
Webanwendungen mit ASP.NET Core laufen performanter
(und preiswerter!) unter Linux als unter Windows (sowohl
lokal als auch in der Cloud), weshalb immer mehr
Unternehmen nun diese Hostingoption wählen.
```

```
Die meisten Docker-Container basieren auf Linux-
Betriebssystemen (laufen aber dennoch unter Windows).
Microso SQL Server in einem Linux-basierten Docker-
Container ist deutlich kompakter als in einem Windows-
Container. Binnen Minuten kann man den SQL Server als
Docker-Image herunterladen und binnen zwei Sekunden
starten.
```
Diese Trends betreffen sowohl Entwickler als auch
Administratoren.

Die PowerShell 7 auf Linux und macOS ist in ihrer bisherigen
Ausbaustufe vor allem ein Angebot für Windows-Entwickler und -
Administratoren, die nun auch Linux und/oder macOS
verwenden müssen. Sie finden sich in der neuen Welt wesentlich
leichter zurecht, wenn sie ihr Wissen über die Windows
PowerShell und ihre Pipelines in der neuen Welt
weiterverwenden können.

Eingefleischte Linux- und macOS-Nutzer wird die PowerShell 7
auf ihren Plattformen aber wohl dann erst als Alternative
begeistern können, wenn sie dort mehr Befehle bietet. Aktuell ist
der Funktionsumfang der PowerShell 7 unter Linux und macOS
deutlich geringer als unter Windows. Insbesondere fehlen dort
konkrete Commandlets, um mit den Betriebssystemen und
Anwendungen zu interagieren: Derzeit muss man noch selbst die
Textausgaben der Standard-Kommandozeilenbefehle in Objekte
umwandeln, bevor man von der Macht der PowerShell-OO-
Pipeline profitiert.


```
HINWEIS: Die PowerShell 7 unter Linux und macOS bietet
derzeit vor allem die Grundbefehle für Ein- und Ausgabe
sowie die Verarbeitung in der Pipeline.
```
###### 13.2 Basis der PowerShell 7

Die Windows PowerShell basiert auf dem klassischen .NET
Framework, das es nur für Windows gibt.

Die PowerShell Core 6.x und die PowerShell 7.0 basieren auf .NET
Core, das für Windows, Linux und macOS verfügbar ist. Die
PowerShell 7.1 basiert auf .NET 5.0, dem Nachfolger von .NET
Core.

Die PowerShell 7.2 verwendet die Version 6.0 des modernen
.NET, die am 8.11.2021 zeitgleich zur PowerShell 7.2 erschienen
ist.

Die PowerShell 7.3 verwendet die Version 7.0 des modernen
.NET. Zum Redaktionsschluss dieses Buches ist diese Version
noch in der frühen Preview-Phase. Geplanter
Erscheinungstermin ist November 2022.

.NET muss NICHT vor der Installation der PowerShell 7.x getrennt
installiert werden, denn die PowerShell 7.x ist eine sogenannte
"Self-contained Application" (SCA), die alle notwendigen Teile
der .NET-Laufzeitumgebung mitbringt.


```
HINWEIS: Die Installation der PowerShell 7.2 wurde
bereits im Kapitel "Erste Schritte" besprochen.
```
###### 13.3 Identifizierung der PowerShell

###### 7

Die PowerShell 7 kann man anhand der Ausgaben von
$psversiontable identifizieren. Die PowerShell 7 meldet sich bei
"PSEdition" mit "Core", auch wenn Microso seit PowerShell 7
den in PowerShell Core 6.0 eingeführten Zusatz "Core" nicht
mehr im Produktnamen verwendet.

Bild 13.1 Ausgabe der Versionstabelle von PowerShell 7


###### 13.4 Funktionsumfang der

###### PowerShell 7

Die PowerShell 7 bietet einen etwas anderen Funktionsumfang
als die Windows PowerShell 5.1: Es gibt einige neue
Commandlets, aber es sind auch einige Commandlets der
Windows PowerShell nicht in PowerShell 7 verfügbar. Dabei ist
außerdem noch zu differenzieren zwischen Windows einerseits
und Linux/macOS andererseits.

13.4.1 Funktionsumfang der PowerShell 7

unter Windows

Während in Windows 11 Version 21 H 2 genau 95 der Windows
PowerShell-Befehle in Power-Shell 7 auf Windows fehlen, sind
lediglich 15 neue Befehle hinzugekommen. Gemessen wurde
jeweils mit dem Basissetup, ohne optionale Features und ohne
Zusatzsoware.

In der folgenden Abbildung sieht man die absolute Anzahl der
Befehle (also Commandlets und Funktionen), die Get-Command
liefert. Es gilt:

Anzahl der Befehle in Windows PowerShell 5.1 1682

Neue Befehle in PowerShell 6.0 bis 7.2 + 15

Entfallene Befehle in PowerShell 6.0 bis 7.2 - 95


Anzahl der Befehle im PowerShell 7.2 1602

Bild 13.2 Vergleich der Ausgabe der Versionstabelle und der Anzahl der Befehle von
Windows PowerShell 5.1 (links) und PowerShell 7.2 (rechts) auf Windows 11

```
HINWEIS: Der Zuwachs von 15 Befehlen zwischen
PowerShell Core 6.0 und PowerShell 7.2 ist nicht viel.
Zudem stellt man fest: Es sind keine neuen Befehle in
PowerShell 7.1 und 7.2 hinzugekommen. Allerdings hat
Microso schon in jeder Version einige Parameter ergänzt
und das Verhalten von Befehlen verbessert. Zudem
umfasst diese Statistik nur Commandlets und Funktionen,
nicht aber die Sprachsyntax, in der Microso auch immer
wieder Verbesserungen einbaut.
```

Bei der Ermittlung der Anzahl der Befehle mit Get-Command ist
unter Windows wichtig, dass nicht

```
(Get-Command).count
```
sondern

```
(Get-Command | Sort-Object Name | Get-Unique).count
```
ausgeführt wird.

Dies ist notwendig, da die PowerShell 7 unter Windows auch
Zugriff auf die Modulverzeichnisse der Windows PowerShell hat
und es einige Moduldopplungen gibt (siehe folgende Abbildung).
Ohne Sortierung und Get-Unique würden Commandlets und
Funktionen doppelt in der Liste erscheinen.

```
HINWEIS: Bei der normalen Arbeit mit der PowerShell ist
beim Aufruf eines Befehls eine solche Dopplung kein
Problem, weil die PowerShell immer den Befehl aus dem
Modul mit der höheren Versionsnummer verwendet.
```

Bild 13.3 Doppelte Module mit verschiedenen Versionsnummern in Windows
PowerShell 5.1 und PowerShell 7 auf Windows 10 20 H 1

13.4.2 Funktionsumfang der PowerShell 7

unter Linux und macOS

Die Anzahl der PowerShell 7 ist auf Windows weit größer als auf
Linux und macOS. Auf Linux und macOS sind gerade einmal 270
Befehle in PowerShell 7.2 verfügbar, denn PowerShell 7 unter
Linux und macOS umfasst nur die von der PowerShell gelieferten
Kernbefehle. Anders als auf Windows gibt es keine PowerShell-
Module als Teil des Betriebssystems mit Funktionen zur
Verwaltung des Betriebssystems.


Bild 13.4 Ausgabe der Versionstabelle und der Anzahl der Befehle von Power-Shell
7.2 auf Ubuntu 21.04

Bild 13.5 Ausgabe der Versionstabelle und der Anzahl der Befehle von Power-Shell
7.2 auf maOS 19.0


###### 13.5 Entfallene Befehle in

###### PowerShell 7

Dieses Unterkapitel beschreibt, welche Commandlets und
Funktionen aus der klassischen Windows PowerShell
Versionstand 5.1 nicht in PowerShell 7 enthalten sind.

13.5.1 PowerShell-Befehle, die in

PowerShell 7 fehlen

95 der bisher unter PowerShell 5.1 verfügbaren PowerShell-Kern-
Commandlets gibt es also nicht unter PowerShell 7.2, auch nicht
unter PowerShell 7.2 auf Windows. Zu diesen Funktionen
gehören insbesondere:

```
Alte WMI-Commandlets (WMI v1) wie Get-WmiObject und
Invoke-WmiMethod. Die WMI v2-Commandlets wie Get-
CimInstance und Invoke-CimMethod werden aber unterstützt.
Beitritt zu Domänen mit Add-Computer
Start von Workflows in PowerShell (es gibt die Basistechnik,
Windows Workflow Foundation, nicht in .NET Core).
Verwendung von PowerShell-Snap-Ins (Add-PSSnapin,
Remove-PSSnapin). Es gibt seit PowerShell Core 6.0 nur noch
Module.
Zugriff auf das Windows-Ereignisprotokoll (Get-EventLog,
Write-EventLog u. a.)
```

```
Unterstützung für Transaktionen (Get-Transaction, Complete-
Transaction, Undo-Transaction u. a.)
Commandlets für den Dienst Microso User Experience
Virtualization (UE-V)
```
Im Folgenden sind alle Commandlets aus Windows PowerShell
5.1 auf Windows 11 21 H 2 (Basissetup) genannt, die nicht in
PowerShell 7.2 verfügbar sind:

1. Add-AppvClientConnectionGroup
2. Add-AppvClientPackage
3. Add-AppvPublishingServer
4. Add-Computer
5. Add-PSSnapin
6. Checkpoint-Computer
7. Clear-EventLog
8. Clear-UevAppxPackage
9. Clear-UevConfiguration
10. Complete-Transaction
11. ConvertFrom-String
12. Convert-String
13. Disable-Appv
14. Disable-AppvClientConnectionGroup
15. Disable-ComputerRestore
16. Disable-Uev
17. Disable-UevAppxPackage


18. Disable-UevTemplate
19. Enable-Appv
20. Enable-AppvClientConnectionGroup
21. Enable-ComputerRestore
22. Enable-Uev
23. Enable-UevAppxPackage
24. Enable-UevTemplate
25. Export-Console
26. Export-UevConfiguration
27. Export-UevPackage
28. Get-AppvClientApplication
29. Get-AppvClientConfiguration
30. Get-AppvClientConnectionGroup
31. Get-AppvClientMode
32. Get-AppvClientPackage
33. Get-AppvPublishingServer
34. Get-AppvStatus
35. Get-ComputerRestorePoint
36. Get-ControlPanelItem
37. Get-EventLog
38. Get-PSSnapin
39. Get-Transaction


40. Get-UevAppxPackage
41. Get-UevConfiguration
42. Get-UevStatus
43. Get-UevTemplate
44. Get-UevTemplateProgram
45. Get-WmiObject
46. ImportSystemModules
47. Import-UevConfiguration
48. Invoke-WmiMethod
49. Limit-EventLog
50. more
51. Mount-AppvClientConnectionGroup
52. Mount-AppvClientPackage
53. New-EventLog
54. New-WebServiceProxy
55. Publish-AppvClientPackage
56. Register-UevTemplate
57. Register-WmiEvent
58. Remove-AppvClientConnectionGroup
59. Remove-AppvClientPackage
60. Remove-AppvPublishingServer
61. Remove-Computer


62. Remove-EventLog
63. Remove-PSSnapin
64. Remove-WmiObject
65. Repair-AppvClientConnectionGroup
66. Repair-AppvClientPackage
67. Repair-UevTemplateIndex
68. Reset-ComputerMachinePassword
69. Restore-Computer
70. Restore-UevBackup
71. Restore-UevUserSetting
72. Resume-Job
73. Send-AppvClientReport
74. Set-AppvClientConfiguration
75. Set-AppvClientMode
76. Set-AppvClientPackage
77. Set-AppvPublishingServer
78. Set-UevConfiguration
79. Set-UevTemplateProfile
80. Set-WmiInstance
81. Show-ControlPanelItem
82. Show-EventLog
83. Start-Transaction


84. Stop-AppvClientConnectionGroup
85. Stop-AppvClientPackage
86. Suspend-Job
87. Sync-AppvPublishingServer
88. Test-ComputerSecureChannel
89. Test-UevTemplate
90. Undo-Transaction
91. Unpublish-AppvClientPackage
92. Unregister-UevTemplate
93. Update-UevTemplate
94. Use-Transaction
95. Write-EventLog

```
HINWEIS: Die Anzahl der fehlenden Commandlets hat
sich in PowerShell 7 gegenüber PowerShell Core 6.0 stark
verringert. Das beruht darauf, dass Microso zwischen
.NET Core 2.0 und .NET Core 3.1 sehr viele .NET-Klassen
aus dem klassischen .NET Framework nach .NET Core
portiert hat, insbesondere im Windows Compability Pack
[www.heise.de/developer/meldung/Microso-
veroeffentlicht-Windows-Compatibility-Pack-fuer-NET-
Core-3892367.html].
```

13.5.2 Befehle, die zusätzlich unter Linux

und macOS fehlen

Wenn man die PowerShell 7 unter Linux oder macOS startet,
dann bekommt man bei (Get-Command).Count nicht mehr über
1500 Befehle, sondern nur sehr magere 270 Befehle angezeigt.

Das liegt vorallem daran, dass die vielen in Windows eingebauten
PowerShell-Module zur Verwaltung von
Betriebssystemfunktionen für Linux und macOS nicht existieren.
Zudem fehlen aber auch einige Kernbefehle der PowerShell, z. B.

```
zur Dienstverwaltung (z. B. Start-Service, Resume-Service)
lokalen Benutzer- und Gruppenverwaltung (z. B. Get-
LocalGroup, New-LocalUser)
Verwaltung von Zugriffsrechteliste (Get-Acl, Set-Acl)
Befehle mit grafischen Ausgaben wie Out-GridView, da diese
auf der Windows Presentation Foundation (WPF) basieren
und es in der der PowerShell 7 zugrundeliegenden .NET
Core-Runtime auf Linux und macOS weder WPF noch eine
andere grafische Benutzeroberfläche gibt.
```
Es macht keinen Sinn, hier mehr als 1200 nicht existierende
Befehle im Buch abzudrucken. Die folgende Liste beschränkt sich
daher auf die 63 Befehle, die unter Linux und macOS zusätzlich
zu den Befehlen, die bereits in PowerShell 7 unter Windows nicht
vorhanden sind, fehlen und aus den PowerShell-Kernmodulen
(Modulname beginnt mit Microso.PowerShell) stammen:

1. Add-LocalGroupMember
2. Clear-RecycleBin


3. Connect-PSSession
4. ConvertFrom-SddlString
5. Disable-LocalUser
6. Disable-PSRemoting
7. Disable-PSSessionConfiguration
8. Disconnect-PSSession
9. Enable-LocalUser
10. Enable-PSRemoting
11. Enable-PSSessionConfiguration
12. Export-Counter
13. Export-ODataEndpointProxy
14. Find-DscResource
15. Get-Acl
16. Get-AuthenticodeSignature
17. Get-ComputerInfo
18. Get-Counter
19. Get-HotFix
20. Get-LocalGroup
21. Get-LocalGroupMember
22. Get-LocalUser
23. Get-OperationValidation
24. Get-PSSessionCapability


25. Get-PSSessionConfiguration
26. Get-Service
27. Get-WinEvent
28. Import-Counter
29. Invoke-OperationValidation
30. mkdir
31. New-FileCatalog
32. New-LocalGroup
33. New-LocalUser
34. New-PSSessionConfigurationFile
35. New-Service
36. New-WinEvent
37. Out-GridView
38. Out-Printer
39. Receive-PSSession
40. Register-PSSessionConfiguration
41. Remove-LocalGroup
42. Remove-LocalGroupMember
43. Remove-LocalUser
44. Remove-Service
45. Rename-Computer
46. Rename-LocalGroup


47. Rename-LocalUser
48. Restart-Service
49. Resume-Service
50. Set-Acl
51. Set-AuthenticodeSignature
52. Set-LocalGroup
53. Set-LocalUser
54. Set-PSSessionConfiguration
55. Set-Service
56. Set-TimeZone
57. Show-Command
58. Start-Service
59. Stop-Service
60. Suspend-Service
61. Test-FileCatalog
62. Test-PSSessionConfigurationFile
63. Unregister-PSSessionConfiguration

###### 13.6 Erweiterungsmodule nutzen in

###### PowerShell 7


Das Modulformat von Windows PowerShell und PowerShell 7 ist
kompatibel. Während in PowerShell Core 6.x nur wenige der in
Windows eingebauten PowerShell-Module in Power-Shell Core
verfügbar waren, laufen in PowerShell 7 nun die meisten
Erweiterungsmodule.

Die in Windows eingebauten PowerShell-Module gehören auch
unter PowerShell 7 zum Standardsuchpfad für Module. Der
Befehl

```
$env:PSModulePath -split ";"
```
liefert unter PowerShell 7 auf Windows diese Pfade:

```
C:\Users\xy\Documents\PowerShell\Modules
C:\Program Files\PowerShell\Modules
C:\program files\powershell\ 7 \Modules
C:\Program Files\WindowsPowerShell\Modules
C:\Windows\system 32 \WindowsPowerShell\v1.0\Modules
```
Unter Linux und macOS wird als Trennzeichen der Pfadangaben
ein Doppelpunkt verwendet. Hier muss man eingeben:

```
$env:PSModulePath -split ":"
```
und erhält dann diese Pfade:

```
/home/xy/.local/share/powershell/Modules
/usr/local/share/powershell/Modules
/opt/microso/powershell/ 7 - preview/Modules
```

13.6.1 Nicht-kompatible Module in

Windows

Diese in Windows PowerShell funktionierenden Module laufen
entweder nicht oder nicht korrekt in PowerShell 7:

```
001: AppLocker
002: AppvClient
003: ConfigCI
004: iSCSI
005: ISE
006: Microso.PowerShell.ODataUtils
007: MsDtc
008: PersistentMemory
009: PSScheduledJob
010: PSWorkflow
011: PSWorkflowUtility
012: StorageBusCache
Diese Liste ermittelte man mit dem folgenden Listing in der
PowerShell 7. Das Listing läu nicht in Windows PowerShell,
da es den Parameter -SkipEditionCheck dort nicht gibt. -
SkipEditionCheck sorgt dafür, dass Get-Module auch Module
liefert, die installiert, aber nicht nutzbar sind.
```

```
Listing 13.1 [/PSCore/Module.ps1]
# Liste der nicht-kompatiblen Module in den Core-Editionen
der PowerShell
$m 1 = (Get-Module -list | Sort-Object name | Get-Unique)
$m 2 = (Get-Module -list -SkipEditionCheck | Sort-Object na
me | Get-Unique)
```
```
"Alle nutzbaren Module: " + $m1.Count
"Alle installierten Module: " + $m2.Count
```
```
Compare-Object $m 1 $m 2
```
Diese nicht-kompatiblen Module haben in ihrer Eigenscha
CompatiblePSEditions nicht stehen, dass sie kompatibel zu
"Core" sind (Auch PowerShell 7 versteht sich als "Core"-Edition,
auch wenn dies im Namen nicht mehr verwendet wird).

Bild 13.6 Eigenscha CompatiblePSEditions bei einem zu PowerShell 7 kompatiblen
und einem nicht kompatiblen PowerShell-Modul

Wenn man versucht, diese nicht kompatiblen Module mit Import-
Module in PowerShell 7 zu laden, kommt es bei einigen zu einer
Fehlermeldung, bei anderen erscheint aber nur eine Warnung.


Diese besagt, dass PowerShell 7 eine PowerShell Remoting-
Verbindung zu einer Instanz der Windows PowerShell aufbaut
und dort die Befehle ausführt. Dieses Verfahren nennt Microso
"WinPSCompatSession"; dies gibt es natürlich nur unter
Windows, nicht auf Linux und macOS, denn dort gibt es keine
Windows PowerShell. Zu beachten sind zwei Dinge:

```
Alle Objekte sind wegen des Einsatzes von PowerShell
Remoting serialisiert und deserialisert. Das Objekt hat dabei
alle seine Methoden verloren außer den Standardmethoden
ToString() und GetType(), die jedes .NET-Objekt besitzt.
Auch der Einsatz von WinPSCompatSession bedeutet nicht,
dass die Commandlets vollständig und korrekt unter
PowerShell 7 funktionieren.
```

Bild 13.7 Import nicht kompatibler PowerShell-Module in PowerShell 7

13.6.2 Fehlende Module in macOS und

Linux

Unter macOS und Linux fehlen gegenüber PowerShell 7 auf
Windows insbesondere alle Module, die nicht zur PowerShell,
sondern zu Windows gehören. Hier ist es einfacher, statt der
wirklich langen Liste der Module, die es nicht gibt, aufzulisten,
welche es überhaupt gibt.


Unter Linux und macOS gibt bringt die PowerShell 7 nur folgende
neun Module mit sich:

1. "Microso.PowerShell.Archive"
2. "Microso.PowerShell.Host"
3. "Microso.PowerShell.Management"
4. "Microso.PowerShell.Security"
5. "Microso.PowerShell.Utility"
6. "PackageManagement"
7. "PowerShellGet"
8. "PSReadLine"
9. "ThreadJob"

Weitere PowerShell-Module sind aber installierbar (z. B. über die
PowerShell Gallery).

13.6.3 Module der PowerShell Gallery in

PowerShell 7

Während beim Start der plattformneutralen PowerShell die
Suche nach den für Linux und macOS verfügbaren PowerShell-
Modulen in der PowerShell Gallery sehr mühsam war, ist auch die
PowerShell Gallery inzwischen auf die plattformneutrale
PowerShell eingerichtet. Zum Redaktionsschluss dieses Buchs
liefert die PowerShell Gallery immerhin 861 Module, die auch auf
Linux laufen, und 583 Module, die auch auf macOS laufen.

Webadressen:


```
http://www.powershellgallery.com/packages?q=Tag% 3 Alinux
http://www.powershellgallery.com/packages?q=Tag% 3 Amac
```
Bild 13.8 Suche nach Linux-fähigen PowerShell-Modulen auf der Website der
PowerShell Gallery

Die folgende Abbildung, in der die Linux-fähigen PowerShell-
Module nach Hersteller sortiert werden,


```
Find-Module -tag:Linux | Group-Object companyname | Sort-O
bject count -desc
```
offenbart: Fast die Häle der Module, die zum Redaktionsschluss
verfügbar sind, stammen von Amazon zur Automatisierung von
Amazon Web Services (AWS). Die zweite große Gruppe stammt
von Oracle (OCI steht für Oracle Cloud Infrastructure).

Bild 13.9 Online-Suche in der PowerShell Gallery nach Linux-fähigen PowerShell-
Modulen mit Find-Module

Die Suche nach Modulen von Microso bringt zum
Redaktionsschluss dieses Buchs lediglich zwei Treffer (die mit der


Azure-Cloud zu tun haben):

```
Find-Module -tag:Linux | where companyname -like *micro* |
ft
name,companyname,version
```
Bild 13.10 Suche nach PowerShell-Modulen für Linux von Microso

Zwei weitere Linux-fähige Azure-PowerShell-Module von
Microso findet man bei der Suche nach "Azure" im
Firmennamen.

```
Find-Module -tag:Linux | where { ($_.companyname -like "*m
icrosoft*") - or ($_.
companyname -like "*azure*")} | ft name,companyname,versio
n
```
Bild 13.11 Suche nach PowerShell-Modulen für Linux von Microso, erweitert um die
Suche nach "Azure"


###### 13.7 Geänderte Funktionen in

###### PowerShell 7

Neben den entfallenen Commandlets gibt es weitere
Änderungen, sogenannte "Breaking Changes", zwischen der
klassischen Windows PowerShell Versionstand 5.1 und der
PowerShell Core 6.x sowie PowerShell 7, die bewirken können,
dass alte Windows PowerShell-Skripte nicht mehr auf der
PowerShell ab 6.0 laufen. Die Änderungen können nicht nur
bewirken, dass die Skripte mit Fehlern abbrechen, sondern auch,
dass sich das Verhalten der Skripte ändert.

13.7.1 Änderungen der Parameter von

pwsh.exe

Seit PowerShell 6.x ist der Parameter -Command nicht mehr der
Standardparameter von pwsh.exe, sondern Microso verwendet
nun -File. Dies bedeutet, dass der in der klassischen Windows-
Konsole oder der PowerShell-Konsole ausgeführte Befehl

```
powershell.exe $psversiontable
```
mit PowerShell ab 6.0, also der pwsh.exe bzw. pwsh, nicht mehr
funktioniert, weil ein Dateiname statt eines Befehls erwartet
wird. Es erscheint der Fehler: "The argument '$psversiontable' is
not recognized as the name of a script file. Check the spelling of
the name, or if a path was included, verify that the path is correct
and try again."


Hier muss man schreiben:

```
pwsh.exe -command $psversiontable
```
Manche IT-Experten werden nun sagen: Es war nie eine gute Idee,
unbenannte Parameter zu verwenden.

13.7.2 Geänderte Pfade

Damit die Windows PowerShell und die PowerShell ab 6.0 auf
einem Windows-System koexistieren können, wurden in der
PowerShell ab 6.0 die Suchpfade für Module und Profilskripte
geändert.

Die Standardpfade in der PowerShell 7 unter Windows sind:

Modulpfade:

```
C:\Users\xy\Documents\PowerShell\Modules
C:\Program Files\PowerShell\Modules
C:\Program Files\powershell\ 7 \Modules
C:\Program Files\WindowsPowerShell\Modules
C:\ WINDOWS \system 32 \WindowsPowerShell\v1.0\Modules
C:\SYSWOW 64 \system 32 \WindowsPowerShell\v1.0\Modules
```
Profilpfade:

```
C:\
Users\xy\Documents\PowerShell\Microso.PowerShell_profil
e.ps 1
```

```
C:\Program
Files\PowerShell\ 7 \Microso.PowerShell_profile.ps 1
C:\ Users\xy\Documents\PowerShell\profile.ps 1
C:\Program Files\PowerShell\ 7 \profile.ps 1
```
Die Pfade unter Linux sind:

Modulpfade:

```
/home/xy/.local/share/powershell/Modules
/usr/local/share/powershell/Modules
/opt/microso/powershell/ 7 - preview/Modules
```
Profilpfade:

```
/home/xy/.config/powershell/Microso.PowerShell_profile.ps 1
/opt/microso/powershell/ 7 -
preview/Microso.PowerShell_profile.ps 1
/home/xy/.config/powershell/profile.ps 1
/opt/microso/powershell/ 7 - preview/profile.ps 1
```
Mit dem folgenden Skript können Sie diese Pfade ermitteln. Bitte
beachten Sie

```
die exakte Groß-Kleinschreibung der Umgebungsvariablen
PSModulePath für Linux und macOS
die notwendige Fallunterscheidung bei Split(), weil die
Pfade unter Windows durch ein Semikolon, unter Linux und
macOS aber durch einen Doppelpunkt getrennt werden! Sie
können nicht. Split(";").Split(":") verketten, weil der
Doppelpunkt ja unter Windows das Trennzeichen für den
Laufwerksbuchstaben ist!
```

```
Listing 13.2 [/PSCore/Pfade.ps1]
Write-Host "Home-Pfad:"-ForegroundColor Yellow
$PSHOME
Write-host "Modulpfade:" - ForegroundColor Yellow
$module = (get-item env:PSModulePath).Value
if ($IsWindows) { $module.Split(";") }
else { $module.Split(";").Split(":") }
Write-host "Profilpfade:" - ForegroundColor Yellow
$profile.CurrentUserCurrentHost #oder $profile
$profile.AllUsersCurrentHost
$profile.CurrentUserAllHosts
$profile.AllUsersAllHosts
```
Bild 13.12 Pfade der PowerShell 7 unter Ubuntu

13.7.3 Weitere Änderungen

Es gibt zahlreiche weitere Änderungen zwischen Windows
PowerShell 5.1 und PowerShell 7, insbesondere an den
Parametern und dem Verhalten einiger Commandlets sowie der
eingebauten Variablen. Dies dokumentiert Microso in
[https://docs.microso.com/en-us/powershell/scripting/whats-
new/differences-from-windows-powershell?view=powershell-7.2].


Hier nur vier Beispiele:

```
Einigen Commandlets fehlt der Parameter -Computername,
sofern die Implementierung auf DCOM basierte. Dazu
gehören z. B. die Commandlets Get-Service und Get-
Process.
Das Commandlet Export-CSV exportiert seit PowerShell 6.0 in
der ersten Zeile im Standard keine Typinformationen mehr.
Für eine CSV-Datei ohne diese erste Zeile brauchte man in
Windows PowerShell den Parameter -NoTypeInformation.
Nun in PowerShell ab Version 6.0 braucht man -
IncludeTypeInformation, um wieder zum alten
Standardveralten zu kommen.
Get-Help bietet keinen Parameter -ShowWindow mehr, da
dieses Fenster auf der Windows Presentation Foundation
(WPF) basiert, die es in .NET Core nicht gibt.
Invoke-WebRequest unterstützt nur noch HTTP, kein FTP mehr.
```
###### 13.8 Neue Funktionen der

###### PowerShell 7

Dieses Unterkapitel beschreibt einige neue Funktionen in der
PowerShell 7 gegenüber Windows PowerShell 5.1.

13.8.1 Neue eingebaute Variablen


Seit PowerShell Core 6.x gib es vier neue
eingebaute/vordefinierte Variablen, die mit Boolean- Variablen
das Betriebssystem anzeigen (IsLinux, IsWindows, IsmacOS) und
definieren, ob .NET Core (IsCoreCLR) als Basis verwendet wird.

Bild 13.13 Die neuen Is-Variablen in PowerShell 7

13.8.2 Neue Commandlets

PowerShell 7.2 bietet gegenüber der Window PowerShell 5.1
lediglich 15 neue Commandlets. Die Commandlets werden in den
jeweiligen Buchkapiteln erörtert.

```
HINWEIS: Wie im Vorwort erläutert, kann dieses Buch
nicht alle PowerShell- Commandlets besprechen. Dies gilt
auch für die neuen Commandlets.
```
1. ConvertFrom-Markdown
2. Disable-ExperimentalFeature
3. Enable-ExperimentalFeature


4. Find-DSCResource
5. Get-Error
6. Get-ExperimentalFeature
7. Get-MarkdownOption
8. Get-Uptime
9. Join-String
10. Remove-Alias
11. Remove-Service
12. Set-MarkdownOption
13. Show-Markdown
14. Start-ThreadJob
15. Test-Json

```
HINWEIS: Diese 15 neuen Commandlets hat Microso alle
schon in PowerShell 6.x und 7.0 eingeführt. In PowerShell
7.1 und 7.2 gibt es keinerlei neue Commandlets, sondern
nur Fehlerbehebungen und kleine Verbesserungen am
Verhalten einiger Commandlets.
```
13.8.3 Sonstige Verbesserungen in

PowerShell 7


Aus der Programmiersprache C# hat Microso den Null
Coalescing Operator ??, den Null Coalescing Assigment Operator
??= und den Null Conditional Operator ?. in die PowerShell-
Skriptsprache übernommen.

Es wurden einige Commandlets bzw. Datentypen erweitert:

```
Bei dem Commandlet Get-Service liefert PowerShell ab
Version 6.0 im ServiceController-Objekt mehr Attribute als
die Windows PowerShell: Neu sind die Eigenschaen
UserName, Description, DelayedAutoStart, BinaryPathName
und StartupType.
Ab PowerShell 6.0 kann man auch mit Set-Service das
Dienstkonto für einen Systemdienst setzen.
Get-Process liefert den benötigten Speicher der Prozesse im
Attribut WorkingSet 64 nicht mehr wie bisher in Kilobyte,
sondern in Megabytes aus.
```
13.8.4 Experimentelle Features in

PowerShell 7

Jede Version der PowerShell seit Version 7 enthält auch immer
einige Features, die Microso noch als "expertimentell"
deklariert, die also

```
noch nicht vollständig sind,
nicht in allen Situationen korrekt funktionieren,
ggf. wieder ausgebaut werden.
```

```
TIPP: Man muss sich gut überlegen, ob man solche
Features nutzen will. Ich rate davon ab. Es ist nicht
sichergestellt, dass die experimentellen Features in der
kommenden Version dann als stabile Funktionen
erscheinen!
```
Für alle, die dennoch mit solchen experimentellen Features
arbeiten wollen, soll hier kurz erklärt werden, wie man diese
aktiviert.

Es gibt dafür drei Commandlets, deren Namen selbsterklärend
sind:

```
Get-ExperimentalFeature
Enable-ExperimentalFeature
Disable-ExperimentalFeature
```
```
HINWEIS: Nicht selbsterklärend ist, dass die Aktivierung
oder Deaktivierung eines experimentellen Features nicht
für die aktuelle PowerShell-Sitzung gilt, sondern erst für
neu gestartete.
```

Bild 13.14 Liste der experimentellen Features und Aktivierung eines Features

Die folgende Abbildung zeigt die Aktivierung des Features
PSAnsiRenderingFileInfo, das experimentell in PowerShell 7.2 ist.

```
Enable-ExperimentalFeature PSAnsiRenderingFileInfo
```
Danach kommt Farbe in der Liste der Ordner und Dateien bei
Get-Childitem (alias Dir) zum Vorschein.


Bild 13.15 Aktivierung eines experimentellen Features

Die zugehörigen Farbdefinitionen findet man unter
$PSStyle.fileinfo

Bild 13.16 Farbedefinitionen für das Feature PSAnsiRenderingFileInfo

###### 13.9 PowerShell 7-Konsole


Die PowerShell 7-Konsole ist im Installationspaket von
PowerShell 7 enthalten. Die Konsole ist realisiert in der Datei
pwsh.exe (unter Windows) bzw. pwsh (unter Linux und macOS).

Auch das PowerShell-Modul PSReadline für die
Eingabeunterstützung wird in PowerShell 7 mitgeliefert.
Während aber die PowerShell 7 unter Windows im Standard den
Eingabemodus "Windows" verwendet, ist unter macOS und Linux
"Emacs" eingestellt.

Daher verhält sich die Konsole etwas anders: Während der
Benutzer unter Windows nach einer Eingabe von "Get-H" und
dem Drücken der Tabulatortaste den Vorschlag für das erste
passende Commandlet (Get-Help) und bei jedem weiteren
Drücken der Tabulatortaste für die folgenden Commandlets (Get-
History und Get-Host) erhält, bekommt der Benutzer unter
macOS und Linux die Ausgabe einer Liste der passenden
Commandlets nach dem ersten Drücken der Tabulatortaste. Die
Eingabeaufforderung zeigt wieder den eingegebenen Text. Erst
wenn die Eingabe eindeutig ist (hier z. B. bei "Get-Ho"), wird der
Befehl vervollständigt. Ebenso funktioniert die
Eingabeunterstützung für andere Konstrukte wie Parameter.

Bild 13.17 Eingabeunterstützung unter Linux im Emacs-Modus


```
TIPP: Bei PSReadline erfolgt das Umschalten der Modi
mit
```
```
Set-PSReadlineOption -EditMode Emacs
```
und

```
Set-PSReadlineOption -EditMode Windows
```
###### 13.10 Praxislösung:

###### Fallunterscheidung für

###### PowerShell-Varianten

Wenn Sie ein Skript schreiben wollen, das sowohl unter Windows
PowerShell als auch in der modernen PowerShell läu, werden
Sie ggf. Fallunterscheidungen in Ihre Skripte einbauen müssen.
Sie können zwischen den PowerShell-Varianten mit Hilfe der
Eigenscha PSEdition innerhalb der Hashtable, die
$psversiontable liefert, unterscheiden. PSEdition liefert
"Desktop" für die Windows PowerShell bis Version 5.1 und "Core"
für die moderne PowerShell ab Version 6.0.


```
HINWEIS: Die Begriffe "Desktop" und "Core" scheinen im
ersten Moment unpassend. Sie haben sich historisch
entwickelt: Das moderne .NET hieß Anfangs ".NET Core"
(und heißt auch heute intern noch so). Zur Abgrenzung
sprach Microso in der Anfangszeit von dem klassischen
.NET Framework als ".NET Desktop Framework" – auch
wenn man damit nicht nur Desktop-Anwendungen,
sondern auch Web-Anwendungen entwickeln konnte.
Allerdings konnte man mit .NET Core in der Anfangszeit
eben keine Desktop-Anwendungen entwickeln. Somit war
damals "Core" und "Desktop" der Gegensatz. Diese
Begriffe sind geblieben, auch wenn mit dem modernen
.NET heutzutage auch Desktop-Anwendungen entwickelt
werden können.
```
Beispiel: Ausgabe der PSEdition

```
Write-host ("Aktuelle Edition: " + $PSVersionTable.PSEditi
on) - NoNewline
if ($PSVersionTable.PSEdition -eq "Desktop") { " also: Win
dows PowerShell (bis
Version 5.1)" }
if ($PSVersionTable.PSEdition -eq "Core") { " also: PowerS
hell (ab Version 6.0)" }
```
Beispiel: Ausführung eines Befehls, den es nur in der Windows
PowerShell gibt (Edition "Desktop")

```
if ($PSVersionTable.PSEdition -eq "Desktop") { "Anzahl der
verfügbaren Snap-Ins: " + (Get-PSSnapin).Count }
```

Beispiel: Ausführung eines Befehls, den es nur in der modernen
PowerShell gibt (Edition "Core")

```
if ($PSVersionTable.PSEdition -eq "Core") { Get-Uptime }
```
```
TIPP: Wenn man Unterschiede zwischen einzelnen
PowerShell-Versionsnummern abfangen will, kann man
auch nach $psversiontable.PSVersion unterscheiden!
```
###### 13.11 VSCode-PowerShell als Editor

###### für PowerShell 7

Zur Bearbeitung von PowerShell-Skripten gibt es auf Linux und
macOS kein PowerShell Integrated Scripting Environment (ISE),
sondern nur Visual Studio Code [code.visualstudio.com] und
dafür die Erweiterung "VSCode-PowerShell"
[github.com/PowerShell/vscode-powershell]. Auch auf Windows
braucht man VSCode, um PowerShell 7-Skripte direkt aus dem
Editor starten zu können.


Bild 13.18 Installation der PowerShell-Erweiterung in Visual Studio Code


Bild 13.19 Eingabeunterstützung für PowerShell-Skripte in Visual Studio Code mit
PowerShell-Erweiterung auf Ubuntu-Linux

Die PowerShell-Erweiterungen für Visual Studio Code installiert
nicht die PowerShell 7 selbst mit. Diese Installation muss separat
erfolgen.

13.11.1 PowerShell zur Skriptausführung

konfigurieren

Wenn man PowerShell-Skripte (.ps 1 - Dateien) direkt aus Visual
Studio Code heraus starten möchte mit der Taste F5, muss man
in Visual Studio Code festlegen, wo sich die Installation der
PowerShell befindet. Unter Windows startet Visual Studio Code


sonst im Standard die Windows PowerShell. Unter Linux und
Ubuntu passiert nichts.

Den Pfad zur PowerShell legt man wahlweise global in der Datei
c:\Users\xy\AppData\ Roaming\Code\User\settings.json (User
Settings) oder lokal für einen Ordner und seine Unterordner fest
in einer Datei \.vscode\settings.json (Workspace Settings). Diese
Dateien kann man einfach bearbeiten, indem man in Visual
Studio Code das Menü "File/Preferences/Settings" wählt. Dort
trägt man entweder in der Registerkarte "User Settings" oder in
der Registerkarte "Workspace Settings" ein:

```
// Für Windows:
"powershell.powerShellExePath": "c:/Program Files/PowerSh
ell/<version>/pwsh.exe"
// Für Linux:
"powershell.powerShellExePath": "/opt/microsoft/powershel
l/<version>/pwsh"
// Für macOS:
"powershell.powerShellExePath": "/usr/local/microsoft/pow
ershell/<version>/pwsh"
```
Dabei ist der Platzhalter <version> durch die aktuelle
Versionsnummer zu ersetzen.

Dieser Eintrag bewirkt, dass beim Start eines PowerShell-Skripts
(.ps 1 ) in Visual Studio Code mit der Taste F 5 nun die PowerShell 7
das Skript startet.


Bild 13.20 Beispiel für einen Eintrag in der globalen Einstellungsdatei "User Settings"
(hier Pfad für Windows)

Bild 13.21 Beispiel für einen Eintrag in der globalen Einstellungsdatei "User Settings"
(hier Pfad für Linux)


13.11.2 PowerShell für das Terminalfenster

in VSCode festlegen

Diese im vorherigen Unterkapitel gezeigte Einstellung
"powershell.powerShellExePath" hat keinen Einfluss auf das
interaktive Terminalfenster von Visual Studio Code, das man
unter dem Menü "View/New Terminal" startet. Hier startet
VSCode im Standard:

```
Unter Windows die moderne PowerShell, wenn nicht
vorhanden, die PowerShell Core.
Unter Linux und macOS die bash Shell: /bin/bash
```
Um die Terminal-Art auf eine installierte PowerShell 7 zu ändern,
wählen Sie in einem Terminalfenster das +-Zeichen und dann
dort "pwsh". Unter "Select Default Profile" können Sie den
Standard ändern.

Bild 13.22 Vor der Änderung des Default Profile: bash auf Ubuntu


Bild 13.23 Nach der Änderung des Default Profile: PowerShell 7 auf Ubuntu

###### 13.12 Verwendung von PowerShell 7

###### auf Linux und macOS

Folgende Punkte sind zu beachten bei der PowerShell ab Version
6.0 auf Linux und macOS:

```
Genau wie in der klassischen Windows PowerShell sind auch
in der PowerShell 6 und 7 die Namen für Commandlets,
Funktionen und Variablen nicht case-sensitive, d. h. also,
Get-Process und get-process, $home und $HOME, dir env: und
DIR ENV: sind gleichbedeutend.
Gleichwohl sind betriebssystemspezifische Namen case-
sensitive, z. B. Umgebungsvariablen. Während also in
Windows PowerShell und PowerShell 6/7 unter Windows die
Befehle dir env:Path, dir env:PATH und dir env:path (sowie
andere Varianten der Groß- und Kleinschreibung)
gleichbedeutend möglich sind, ist unter Linux und macOS
nur dir env:PATH erlaubt.
Wenn in einer Umgebungsvariablen wie PATH oder
PSModulePath mehrere Verzeichnisse vorkommen, sind diese
```

```
unter Windows mit einem Semikolon getrennt, unter Linux
und macOS aber mit einem Doppelpunkt.
```
Die Commandlets liefern auch unter Linux und macOS
Instanzen von .NET-Klassen, z. B. Get-Process liefert
Instanzen der Klasse System.Diagnostics.Process.

Unter Windows ist ps ein Alias für Get-Process und liefert
Instanzen der .NET-Klasse System.Diagnostics.Process. Unter
Linux und macOS ist ps ein eingebauter bash-Befehl für die
Prozessliste, die eine Zeichenkette (System.String) liefert.
Gleiches gilt für md, ls, cat, man, sort u. a. Insbesondere sort
ist der Praxis ein Problem, weil es häufig als Abkürzung für
Sort-Object in der Windows PowerShell eingesetzt wird.

Dir und cd sind aber in der PowerShell seit Version 6.0 Aliase
für PowerShell-Commandlets Get-ChildItem bzw. Set-
Location.

Anders als in den normalen Linux-Shells akzeptiert
PowerShell seit Version 6.0 nicht nur unter Windows,
sondern auch unter Linux beide Schrägstricharten (/ und \)
in Pfaden, z. B. dir c:/users/xy und dir c:\users\xy. Dies
führt allerdings dazu, dass PowerShell Dateien mit einem
Backslash im Namen nicht verarbeiten kann


```
[github.com/PowerShell/PowerShell/issues/3666]. ABER:
Aus der PowerShell aufgerufene normale Linux-
Kommandozeilenwerkzeuge (z. B. git) verstehen weiterhin
nur /.
```
Skriptdateien sollten wie in Windows auf .ps 1 enden, damit
die PowerShell ab Version 6.0 sie als Skriptdateien direkt
ausführt. Ausführungsrechte wie bei bash-Dateien (chmod
777 ./name.ps 1 ) muss man nicht vergeben.

Eine Skript-Ausführungsrichtlinieneinstellung wie unter
Windows PowerShell und Power-Shell ab 6.x unter Windows
gibt es unter Linux und macOS nicht. Get-ExecutionPolicy
liefert im Standard "unrestricted". Set-ExecutionPolicy
scheitert mit "Operation ist not supported on this platform".

Aus der bash heraus startet man ein PowerShell-Skript mit
pwsh ./name.ps 1. Ebenso aus der PowerShell heraus muss
man bash voranstellen: bash ./name.sh.

In der PowerShell ist der Begriff eines Laufwerks weiter
gefasst als in den Betriebssystemen. Während unter
Windows zahlreiche Informationsspeicher als PowerShell-
Laufwerke aufgefasst werden (darunter auch das Active
Directory sowie die Registrierungs- und SQL Server-
Datenbanken), bieten Linux und macOS nur das Dateisystem
(/) und Umgebungsvariablen sowie die PowerShell-
Konstrukte Variablen, Funktionen und Aliase.


```
Unix-basierte Dateisysteme kennen keine Dateiattribute und
daher kann man dort auch Parameter wie -Attributes bei
Get-ChildItem und den Zugriff auf die Attributes-
Eigenscha von Dateisystemobjekten nicht einsetzen. Unter
Linux und macOS versteckt man Dateien und Ordner, indem
man den Namen mit einem Punkt beginnen lässt. Wie unter
Windows nimmt man versteckte Dateien und Ordner mit
dem Parameter -force bei Get-ChildItem (alias dir) in die
Ausgabemenge auf.
```
Bild 13.24 Get-PSDrive und dir env:User unter Linux


Bild 13.25 Get-PSDrive und dir env:User unter macOS

13.12.1 Praxislösung: Linux-Benutzerliste

auswerten

Die Liste der Linux-Benutzerkonten soll ausgewertet werden.
Dies erledigt man unter Linux mit der Ausgabe der Datei
/etc/passwd. Der Linux-Kommandozeilenbefehl cat liefert eine
Zeichenkette mit Zeilenumbrüchen, wobei die einzelnen Werte
durch einen Doppelpunkt getrennt sind, z. B.

```
hplip:x:114:7:HPLIP system user,,,:/var/run/hplip:/bin/false
hs:x:1000:1000:HS,,,:/home/hs:/bin/bash
```
Aus der Sicht der PowerShell ist dies eine Liste der .NET-Klasse
System.String.

Den sinnvollen Einsatz der PowerShell-Commandlets unter Linux
zeigt der nachstehende Befehl, der aus der Systemdatei Datei


/etc/passwd alle Benutzerkonten ausgibt, deren Name mit dem
Buchstaben "S" anfängt und deren User-ID (UID) größer als 100
ist.

```
Import-CSV /etc/passwd -Delimiter ":" - Header Name,Passwd,
UID,GID,Description,Home,Sh ell | where-Object { $_.name -
like "S*" - and [int]$_.UID -gt 100 } | Sort-Object @ {Expr
ession={$_.gid -as [int]}} - desc | Format-Table GID, UID,
Name, Description,Home
```
Das Commandlet Import-CSV sorgt dafür, die Datei /etc/passwd
nicht nur einzulesen, sondern den Inhalt in Objekte mit den bei -
Header genannten Attributen zu konvertieren, sodass mit Where-
Object ein typisiertes Filtern möglich ist. Allerdings ist für die
Bedingung auf UID ebenso wie für das Sortieren auf die Gruppen-
ID (GID) eine Typkonvertierung notwendig, da Import-CSV die
einzelnen Attribute des erzeugten Objekts dann doch als "String"
deklariert.


Bild 13.26 Ausgabe der obigen Befehlskette

13.12.2 Praxislösung: Offene Ports

auswerten

Der Wert der PowerShell 7 unter Linux und macOS liegt in den
mächtigen Pipelining- sowie Ein- und Ausgabe-Commandlets.
Für konkrete Zugriffe auf das Betriebssystem gibt es hingegen für
die PowerShell 7 unter macOS und Linux außer für das
Dateisystem und die Prozessverwaltung noch fast keine
Commandlets. Man wird also o klassische Linux- und macOS-
Kommandozeilenbefehle mit zeichenkettenbasierter
Verarbeitung in die PowerShell einbinden. Im Idealfall wandelt


man auch dabei die Zeichenketten in Objekte um, um im
Folgenden von den Verarbeitungscommandlets der PowerShell
zu profitieren Wie dies geht, soll hier an folgendem Beispiel
erläutert werden: die Auswertung der offenen Firewall-Ports mit
sudo ufw status. Die folgende Abbildung zeigt die Ausgabe
dieses Befehls (hier unter Ubuntu mit einigen zusätzlichen Ports).

Bild 13.27 sudo ufw status

Das folgende Listing zeigt die Auswertung dieser Textausgabe via
PowerShell 7 mit der Fragestellung, dass nur IPv4-Port mit einer
Portnummer größer als 5000 aufgelistet werden sollen. Dabei
wird eine wiederverwendbare PowerShell-Funktion Get-
OpenFirewallPort erstellt.


Listing 13.3 [/PSCore/Linux_Firewallports.ps1]

```
function Get-OpenFirewallPort([boolean] $v 6 )
{
$text = sudo ufw status
# Ãoeberspring alle Zeilen, bis "To beginnt"
$text = $text.Where({$_ - like "*To*"},'SkipUntil')
if (-not $v 6 ) {
# Ausortieren der v6-Zeilen
$text = $text.Where({$_ - notlike "*v 6 *"}) }
# Aussortieren der Linienzeilen
$text = $text.Where({$_ - notlike "*---*"})
# Aussortieren der ersten Zeile mit Ãoeberschriften
$text = $text | select-object -Skip 1
# Umwandeln der Leerzeichen in tabs
#$text.replace(" ",".")
$text = $text -replace ' {2,}',"`t"
# Erstellen von Objekten"
$objekte = $text| ConvertFrom-CSV -Delimiter "`t" - Header
To,Action,From
return $objekte
}
```
```
Write-Host "Offene Ports" - ForegroundColor Yellow
```
```
$ports = Get-OpenFirewallPort $false
"Anzahl der Objekte: " + $ports.Count
"---- Alle Ports, benutzerdefinierte Ausgabe"
$ports | ft from,to,action
"---- Metadaten"
$ports | gm
```

```
"------ Spass mit der PowerShell: offene Ports groesser 50
00"
$ports | where to -gt 5000 | sort-object port | ft from,t
o,action
```
Wer nicht so gut kapseln und übersichtlich den Code schreiben
will, kann das Gleiche auch kurz in einer Pipeline ausdrücken:

```
sudo ufw status | select-string "^[0-9]{ 4 }" | select-strin
g -NotMatch "v6" | foreach { ($_.tostring() - replace'
{2,}',"`t") } | ConvertFrom-CSV -Delimiter "`t" - Header T
o,Action,From | where to -gt 5000 | sort-object port | ft
from,to,action
```
13.12.3 Praxislösung: Dateien unter Linux

und macOS verstecken und

versteckte Dateien auflisten

Im folgenden Skript wird ein Ordner mit drei Dateien und einem
Unterordner angelegt. Eine Datei und der Unterordner werden
versteckt, indem der Name nun mit einem Punkt beginnt. Der
Befehl dir ohne -force findet dann nur noch zwei Dateien. Mit -
force sind es vier Elemente: dir $pfad ".*" - force

Im folgenden Skript wird ein Ordner mit drei Dateien und einem
Unterordner angelegt. Eine Datei und der Unterordner wird
versteckt, indem der Name nun mit einem Punkt beginnt. Der
Befehl dir ohne -force findet dann nur noch zwei Dateien. Mit -
force sind es vier Elemente.


Listing 13.4 [PSCore\Linux\Linux_VersteckteDateien.ps1]

```
$pfad = "/home/hs/Documents/Test"
if (test-path $pfad) { remove-item $pfad -force -Recurse}
```
```
# Ordner mit drei Dateien anlegen
md $pfad
"irgendein Inhalt" | Set-Content "$pfad/datei1.txt"
"irgendein Inhalt" | Set-Content "$pfad/datei2.txt"
"irgendein Inhalt" | Set-Content "$pfad/datei3.txt"
md "$pfad/ordner"
```
```
# Ermitteln der Elementanzahl
Write-Host "Anzahl Elemente: $((dir $pfad).count)" - Foregr
oundColor Yellow # 4
```
```
dir $pfad
# Das geht nicht
Get-item "$pfad/datei3.txt" | % { $_.attributes }
Get-item "$pfad/datei3.txt" | % { $_.attributes = $_.attri
butes -bor "Hidden" }
Get-item "$pfad/datei3.txt" | % { $_.attributes }
Write-Host "Anzahl Elemente: $((dir $pfad).count)" - Foregr
oundColor Yellow # 4
```
```
Write-Host "Verstecken von zwei Elementen..." - ForegroundC
olor Yellow
# Verstecken einer Datei
rename-item "$pfad/datei3.txt" "$pfad/.datei3.txt"
# Verstecken des Ordners
```

```
rename-item "$pfad/ordner" "$pfad/.ordner"
```
```
Write-Host "Anzahl Elemente: $((dir $pfad).count)" - Foregr
oundColor Yellow # 2
dir $pfad
```
```
Write-Host (dir $pfad).count -ForegroundColor Yellow # 2
Write-Host (dir $pfad -force).count -ForegroundColor Yello
w # 4
Write-Host (dir $pfad ".*" - force).Count -ForegroundColor
Yellow # 2
```
13.12.4 Praxislösung: Besitzer von Dateien

ändern

Das folgende Skript nutzt den Linux-Befehl ls -ld, um den
aktuellen Besitzer auszulesen, und chown, um den Besitzer von
Dateien in einem Ordner zu ändern.


```
Listing 13.5 [PSCore\Linux\Linux_Ownership.ps1]
function Get-Owner([string] $path)
{
ls -ld $path | awk 'NR== 1 {print $ 3 }'
}
function Set-Owner([string] $path, [string] $user)
{
$owner = Get-Owner $path
Write-verbose "Owner before: $owner"
& "sudo" chown -c $user $path
$owner = Get-Owner $path
Write-verbose "Owner now: $owner"
}
```
```
$ErrorActionPreference = "stop"
$VerbosePreference = "silentlycontinue"
$dir = "/home/hs/Documents/Test"
```
```
Write-host "Besitzer Ändern #1:" - ForegroundColor Yellow
Write-host "Owner before: $(get-owner $dir)"
Set-Owner $dir root
Write-host "Owner after: $(get-owner $dir)"
Write-host "Besitzer Ändern #2:" - ForegroundColor Yellow
Write-host "Owner before: $(get-owner $dir)"
Set-Owner $dir hs
Write-host "Owner after: $(get-owner $dir)"
```
###### 13.13 PowerShell-Remoting via SSH


PowerShell Remoting via PowerShell Remoting Protocol (PSRP)
ist in PowerShell 7 über WSMan (bei installierter Open
Management Infrastructure (OMI) auf Linux/macOS
[github.com/PowerShell/psl-omi-provider]) oder über SSH (Secure
Shell) möglich. Für die Verwendung von SSH besitzen die
Commandlets Enter-PSSession, New-PSSession und Invoke-
Command die neuen Parameter -SSHTransport, - Hostname und -
KeyFilePath.

13.13.1 OpenSSH auf Windows

Windows 10 Version 1709 ("Fall Creators Update") war die erste
Version von Windows, bei denen sich Win 32 OpenSSH
[github.com/PowerShell/Win 32 - OpenSSH]) als optionales Feature
einfach installieren lässt. Auf älteren Windows-Versionen müssen
Sie die Installation manuell vornehmen, siehe
[github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-
OpenSSH].

Die Installation auf Windows 10 seit Version 1709 kann über den
Settings-Dialog oder per PowerShell erfolgen:

```
Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.
1.0
Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.
1.0
```

```
ACHTUNG: Die Namen der Pakete können sich ändern.
Lassen sie sich von Get-WindowsCapability den aktuellen
Namen geben.
Tatsächlich ist OpenSSH für Windows zum
Redaktionsschluss dieses Buch noch eine Beta-Version,
auch in Windows 11. Dabei hat Microso zwischen der
ersten und der zweiten Beta-Version die Versionsnummer
von 1.0.0-Beta auf 7.6.0-Beta geändert, um nun analog
zum OpenSSH-Projekt auf die Windows-Implementierung
davon zu versionieren. Die 0.0.1.0, die Get-
WindowsCapability anzeigt, ist in dem Zusammenhang
kurios.
```
Bild 13.28 Installation von OpenSSH


Danach sind noch Konfigurationsschritte für den SSH-Server
notwendig, die das folgende Skript ausführt.

```
Listing 13.6 [PSCore_Remoting_SSH_Windows 10 Setup.ps1]
# Quelle: https://blogs.msdn.microsoft.com/powershell/ 201
7 / 12 / 15 /using-the-openssh-
beta-in-windows-10-fall-creators-update-and-windows-server
-1709/
Start-Service ssh-agent
cd c:\Windows\System 32 \OpenSSH
.\ssh-keygen -A
.\ssh-add ssh_host_ed25519_key
Install-Module -Force OpenSSHUtils
Repair-SshdHostKeyPermission -FilePath c:\Windows\System 32
\OpenSSH\ssh_host_ed25519_
key
Start-Service sshd
Get-Service sshd
New-NetFirewallRule -Name sshd -DisplayName 'OpenSSH Serve
r (sshd)' - Service sshd
```
- Enabled True -Direction Inbound -Protocol TCP -Action All
ow -Profile Domain

Die PowerShell muss mit dem Kommandozeilenparameter -sshs
in den SSH-Server eingebunden sein. Dazu muss man die Datei
c:\Windows\System 32 \OpenSSH\sshd_config bearbeiten und
folgende Einträge ändern (vgl.
[github.com/PowerShell/PowerShell/tree/master/demos/SSHRe
moting]):


```
PasswordAuthentication yes
...
Subsystem powershell c:/program files/powershell/ 7 /pwsh.ex
e -sshs -NoLogo
```
- NoProfile

13.13.2 PowerShell Remoting mit SSH

Mit dem folgenden Befehl kann man dann auf ein entferntes
System zugreifen, z. B. von Linux auf ein Windows-System:

Beispiel: PowerShell Remoting von Linux zu einem Windows-
System, sofern dort SSH. installiert und konfiguriert ist

Enter-PSSession -hostname PC 123 - sshtransport -username hs

Wie in der klassischen PowerShell fragt auch PowerShell 6/7 das
Kennwort interaktiv ab. Die Angabe von -KeyFilePath unter
Angabe der Private-Key-Datei ist nur notwendig, wenn SSH mit
Key Authentication verwendet werden soll.

```
HINWEIS: Bei der Verbindung zu Linux-Systemen ist die
Groß- und Kleinschreibung des Benutzernamens zu
beachten!
```

Bild 13.29 PowerShell Remoting via SSH (Linux zu Windows)


Bild 13.30 PowerShell Remoting via SSH (Windows zu Linux)

Innerhalb einer Fernsitzung kann man keine weitere Sitzung zu
einem anderen System aufbauen (siehe folgende Abbildung).


Bild 13.31 PowerShell Remoting via SSH (Linux zu Linux)

```
HINWEIS: Die in den Abbildungen in der Nachfrage der
PowerShell erwähnte "Known Hosts"-Liste findet man
unter Linux unter /home/benutzer/.ssh/known_ hosts und
unter Windows unter C:/Users/benutzer/.ssh/known_hosts.
SSH liefert einen Fehler, wenn sich der gespeicherte SSH
Host Key nicht mit dem vom entfernten System
gelieferten Host Key übereinstimmt, weil dies der Hinweis
auf einen "Man in the Middle"-Angriff sein kann.
```
###### 13.14 Performance-Vorteile der

###### PowerShell 7


Die PowerShell 7 ist bei einigen Aufgaben erheblich schneller als
die Windows PowerShell 5.1. Das liegt nicht nur an
Optimierungen innerhalb der PowerShell selbst, sondern vor
allem auch an der verbesserten Performance des modernen .NET
7.0 gegenüber dem klassischen .NET Framework.

```
TIPP: Die Leistung der PowerShell hängt o auch von
dem Weg ab, den man beschreitet. Die folgenden
Abbildungen zeigen vier Wege, einen Ordner aufzulisten.
Die Leistungsunterschiede sind riesig!
```
Bild 13.32 Verschiedene Wege, den Inhalt eines Ordners aufzulisten in Windows
PowerShell 5.1


Bild 13.33 Verschiedene Wege, den Inhalt eines Ordners aufzulisten in PowerShell
7.2 - bei jedem der Wege ist sie schneller als die Windows PowerShell

###### 13.15 Dokumentation zur

###### PowerShell 7

Es gibt bislang keine eigenständige Dokumentation zur
PowerShell 6/7. Die Dokumentation zur PowerShell 6/7 ist in die
Dokumentation zur Windows PowerShell integriert:
https://docs.microso.com/en-us/powershell/scripting. Dabei
kann man aktuell die Dokumentation zwischen den PowerShell-
Versionen 3.0, 4.0, 5.0, 5.1, 6 und 7 umschalten. "Core" erscheint
hier nicht bei "6", es ist aber "Core 6" gemeint.

Wenn man eine Hilfeseite anwählt und es erscheint der Text, dass
die Hilfeseite für die gewählte Version nicht verfügbar ist, dann
deutet dies darauf hin, dass es die dort besprochene Funktion in
der gewählten PowerShell-Version nicht gibt.


Bild 13.34 Get-WmiObject gibt es nicht in PowerShell 7

Auch die Parameteranzeige orientiert sich an der eingestellten
Versionsnummer. Beispiel: Für das Commandlet Get-Service
wird zu PowerShell 5.1 der Parameter -computername angezeigt.
Nach dem Umschalten auf PowerShell 7 verschwindet der
Parameter aus der Liste.


Bild 13.35 Parameter von Get-Service in Windows PowerShell 5.1

Bild 13.36 Parameter von Get-Service in PowerShell 7

###### 13.16 Quellcode zur PowerShell 7


PowerShell Core ist Open Source. Daher können Sie den
kompletten Quellcode der aktuellen Version, früherer Versionen
und auch die aktuellen Entwicklungsstränge auf
Github.combetrachten:
https://github.com/PowerShell/PowerShell

Microso entwickelt dort vor den Augen der Öffentlichkeit die
kommenden Versionen. Sie können sich in die Entwicklung selbst
einbringen mit Bugmeldungen, Wünschen nach neuen
Funktionen oder auch, indem Sie selbst neuen Funktionen im
Quellcode entwickeln und das Microso-Entwicklungsteam dann
als sogenannten "Pull Request" auffordern, Ihre Änderungen zu
übernehmen. Microso wird das natürlich vorher begutachten.

Man sieht zum Beispiel auf Github für das Commandlet Get-
Uptime, dass man sich zur Ermittlung der Zeitspanne seit
Systemstart der statischen Methode GetTimestamp() der .NET-
Klasse System. Diagnostics.Stopwatch bedient.

Man stellt leider auch fest, dass der dort genannte Hilfelink
https://go.microso.com/fwlink/?linkid= 834862 nur auf eine
Platzhalterseite führt. Die Dokumentationsqualität ist bei
Microso in den letzten Jahren gesunken.


Bild 13.37 Quellcode für das Commandlet Get-Uptime auf Github
[github.com/PowerShell/PowerShell/blob/master/src/Microso.PowerShell.Commands.
Utility/commands/utility/GetUptime.cs]


# Teil B: PowerShell-Aufbauwissen

Inhalte dieses Buchteils sind die erweiterten Möglichkeiten der PowerShell, insbesondere der Zugriff auf Klassenbibliotheken (.NET, COM und WMI), sowie die Einbindung von Commandlet-Erweiterungen (PowerShell-Module).


# 14 Verwendung von .NET-Klassen

Mit der PowerShell (auch mit den "Core Editionen") kann man
jede .NET-Klasse (also jeden Typ) aus der .NET-Framework-
Klassenbibliothek (alias "Framework Class Library" – kurz: FCL)
bzw. der .NET-Core-Klassenbibliothek sowie aus anderen .NET-
Bibliotheken von Microso oder Drittanbietern verwenden.
Solche .NET-Bibliotheken liegen entweder im Betriebssystem
bereits vor oder können im Dateisystem gespeichert und dann
genutzt werden.

## 14.1.NET versus .NET Core

Während die Windows PowerShell auf dem klassischen .NET
Framework basiert, verwenden die Windows PowerShell Core
und die PowerShell 6/7 das neuere .NET Core als Unterbau.


Bild 14.1 .NET versus .NET Core

Der Einsatz von .NET Core hat Vor- und Nachteile:

```
.NET Core läu nicht nur auf Windows, sondern auch auf
Linux und macOS.
Während das .NET Framework monlithisch aufgebaut ist, ist
.NET Core Modul. Beim .NET Framework werden viele
tausend Klassen mit dem Setup installiert. In .NET Core gibt
es viel weniger Klassen in der Grundausstattung. Viele
Klassen muss man von Nuget.org erst manuell
herunterladen. Zahlreiche Klassen, die es bisher im .NET
Framework gibt, gibt es noch gar nicht für .NET Core.
.NET Core erlaubt sogenannte "Self Contained Apps" (SCA),
bei der eine Anwendung alle notwendigen DLLs für .NET
Core mit sich bringt, d. h. eine SCA ist ausführbar ohne dass
vorher .NET Core auf dem Rechner installiert werden muss.
Die PowerShell Core ist eine solche SCA. Die Windows
PowerShell hingegen setzt immer die Installation des
passenden .NET Frameworks voraus.
Das klassischen .NET Framework wird nur noch in kleinen
Schritten weiterentwickelt, während Microso sehr agil .NET
Core weiterentwickelt.
```

```
Während es auf jedes .NET Framework zehn Jahre Support
von Microso gibt, sind es bei .NET Core nur noch drei Jahre
bzw. sogar nur noch ein Jahr.
```
###### 14.2 Ermitteln der verwendeten

###### .NET-Version

Die Ermittlung, welche .NET-Variante und -Version einer
PowerShell-Installation zugrunde liegt, ist nicht ganz trivial, denn
Microso hat bei der Versionsnummernanzeige in .NET in der
Vergangenheit viel Unfug produziert.

Eigentlich gibt es schon seit .NET Framework 1.0 die
Versionsnummer der Laufzeitumgebung in
[System.Environment]::Version. Allerdings hat Microso nach
.NET Framework Version 4.0 die ersten beiden Stellen nicht mehr
hochgezählt. Die Ausgabe 4.0 steht daher auch für 4.5, 4.6, 4.7
und 4.8.

Noch schlimmer: Unter .NET Core 1.x und 2.x liefert
[System.Environment]::Version immer eine Nummer mit 4.0 und
[System.Runtime.InteropServices.RuntimeInformation]
::FrameworkDescription eine 4.6, die völlig unsinnig war. Erst seit
.NET Core 3.0 kommt die korrekte Information der
Versionsnummer von [System.Environment]::Version und
[System.Runtime.InteropServices.RuntimeInformation]::Framewo
rkDescription.


Bild 14.2 Versionsnummerermittlung der zugrunde liegenden .NET-Variante/-Version
in Windows PowerShell 5.1, PowerShell Core 6.2 und PowerShell 7


###### 14.3.NET-Bibliotheken

.NET-Bibliotheken sind Sammlungen von .NET-Klassen in
Sowarekomponenten. Eine .NET-Bibliothek wird Assembly
genannt und ist eine DLL. Aber nicht jede DLL ist eine .NET-
Bibliothek; DLLs können auch COM-Objekte und klassische
Windows-API-Funktionsbibliotheken sein.

Im klassischen .NET Framework werden zahlreiche .NET-
Bibliotheken mit dem Setup installiert. Einige Windows-
Anwendungen (z. B. SQL Server Management Studio) bringen
weitere .NET-Bibliotheken mit sich auf ein Windows-
Betriebssystem. Zusätzliche .NET-Bibliotheken bekommt man
auf dem von Microso betriebenen Komponentenportal NuGet
(www.nuget.org) oder auch viele Websites von Herstellern und
Privatleuten. .NET Framework und .NET Core können alle
Bibliotheken nutzen, die sich an den sogenannten ".NET
Standard" halten; dies sind laut Microso ca. 70 % der auf
nuget.org verfügbaren Bibliotheken. Das .NET Framework kann
darüberhinaus auch die übrigen 30 % der .NET-Bibliotheken
verwenden.


Bild 14.3 Abbildung: Das Komponentenportal [http://www.nuget.org](http://www.nuget.org) enthält über 100 000
Bibliotheken für .NET


```
PRAXISTIPP: Viele der auf http://www.nuget.org angebotenen
.NET-Bibliotheken machen keinen Sinn für die
PowerShell, da es o bessere Alternativen gibt. Sie sollten
erst immer schauen, ob es eine eingebaute Lösung in der
PowerShell in Form von Commandlets bzw. Zusatz-
Commandlets in der PowerShell Gallery gibt. Erst wenn es
dort keine Lösung gibt, sollten Sie auf http://www.nuget.org
schauen.
```
###### 14.4 Microso Docs

Extrem wichtig bei der Verwendung von .NET-Klassen ist, dass Sie
die Dokumentation der. NET-Klassen in Microso Docs (früher:
Microso Developer Network (MSDN) Library ) nutzen. Die
Dokumentation der .NET-Klassen findet man aktuell unter
folgender URL (wobei sich diese URL in der Vergangenheit leider
schon häufiger geändert hat, aber eine Google-Suche nach ".net
class library" meistens):

https://docs.microso.com/de-de/dotnet/api/

Die Dokumentation richtet sich zwar an Sowareentwickler und
bietet daher nur Beispiele für die Verwendung der .NET-Klassen
in C#, F#, C++ und Visual Basic .NET, aber ist dennoch
unerlässlich für das Verständnis, was Sie als PowerShell-Nutzer
mit einer bestimmten .NET-Klasse machen können und wie sie
diese zu verwenden haben.


Die folgende Abbildung zeigt exemplarisch einen Ausschnitt der
Dokumentation der Klasse System.Environment. Links oben
wählen Sie die .NET-Version (.NET für die moderne Power Shell,
.NET Framework für die klassische Windows PowerShell). Rechts
können Sie die Programmiersprache und die Textsprache
(deutsch oder englisch) wählen.

Innerhalb dieses Kapitels finden Sie immer wieder Abbildungen
aus der Dokumentation, die Ihnen helfen, die im Buch
besprochenen Konstrukte/Fälle in der Dokumentation zu
erkennen.


Bild 14.4 Dokumentation der .NET-Klasse "System.Environment"

###### 14.5 Überblick über die Verwendung

###### von .NET-Klassen

Die folgende Abbildung gibt einen Überblick über die
Verwendung von .NET-Klassen, die in den folgenden Kapiteln
dann näher beschrieben wird. Das Schaubild geht davon aus,
dass die .NET-Bibliothek (Assembly), die eine .NET-Klasse


enthält, bereits installiert wurde. Dann kann man die .NET-
Klassen mit New-Object instanziieren.

Danach hält man ein .NET-Objekt (alias: Instanz) in Händen; hier
kann man Mitglieder (Attribute und Methoden) nutzen.

Bild 14.5 Grafischer Überblick über die Verwendung von .NET-Klassen in PowerShell

Neben der Instanziierung von .NET-Klassen gibt es in der
PowerShell weitere Möglichkeiten, .NET-Objekte zu erhalten, die
in diesem Buch bereits besprochen wurden:

```
Von Commandlets wie Get-Process oder Get-Service
Von eingebauten Variablen wie $host oder $psversiontable
Von Literaten wie "Holger Schwichtenberg" oder 12345
Von statischen .NET-Klassen (wird in diesem Kapitel
besprochen)
```
###### 14.6 Erzeugen von Instanzen


Mit dem Commandlet New-Object kann der PowerShell-Nutzer
jede beliebige .NET-Klasse (oder eine COM-Klasse, siehe nächstes
Kapitel) instanziieren und so eine Instanz der Klasse (also ein
Objekt) erhalten.

Beispiel 1:

```
$w = New-Object System.Net.WebClient
```
Bild 14.6 Die PowerShell-ISE bietet Eingabeunterstützung für .NET-Klassennamen
nach New-Object.

Beispiel 2:

```
$zufallszahlgenerator = New-Object System.Random
```
Beispiel 3 (wobei es hierfür seit PowerShell 5.0 auch das
Commandlet New-Guid gibt).

```
$guid = New-Object System.Guid
```

```
TIPP: Die PowerShell bietet eine besondere Behandlung
für WMI (System.Management), ADSI
(System.DirectoryServices) und ADO.NET (System.Data).
Objekte aus diesen Bibliotheken werden über
Objektadapter dem Nutzer vereinfacht dargestellt. Dies
wird später im Buch besprochen.
```
Konstruktorfunktion new() seit PowerShell

5.0

Seit PowerShell 5.0 gibt es eine alternative Syntaxform für die
Instanziierung von .NET-Klassen unter Angabe des
Klassennamens in eckigen Klammern gefolgt von zwei
Doppelpunkten und Konstruktorfunktion new():

Muster: [KLASSENAME]::new()

Beispiel 1:

$r = [System.Random]::new()

Die Konstruktorfunktion new() ist etwas schneller als das
Commandlet New-Object. Allerdings wirkt sich dieser
Geschwindigkeitsvorteil in der Praxis eher selten aus. Der
folgende Geschwindigkeitstest liefert bei 10 000 Instanziierungen
für New-Object eine Dauer von 1,003 Sekunden und für ::new()
0,258 Sekunden.


```
Listing 14.1 Geschwindigkeitstest: New-Object versus new()
$durchläufe = 10000
"Geschwindigkeitstest: $durchläufe Instanziierungen"
"$durchläufex New-Object`t" + (Measure-Command { 1..$durch
läufe | foreach { New-
Object System.Random } }).TotalMilliseconds + "ms"
"$durchläufe x new()`t`t" + (Measure-Command { 1..$durchlä
ufe | foreach { [System.
Random]::new() } }).TotalMilliseconds + "ms"
```
Bild 14.7 Ausgabe des obigen Geschwindigkeitstests

Praxislösung

Die folgende Praxislösung verwendet die .NET-Klasse
System.Random, um eine PowerShell-Funktion zu realisieren, die
ein beliebig langes Kennwort generiert.


```
Listing 14.2 [New-Password.ps1]
Function New-Password([int] $Anzahl)
{
$kennwort = ""
$zufallszahlgenerator = New-Object System.Random
for($i=0;$i -lt $Anzahl;$i++) { $kennwort = $kennwort +[ch
ar]$zufallszahlgenerator.
next(33,127) }
return $kennwort
}
```
```
New-Password 12
```
Als Ergebnis erhält man z. B.

New-Password 10

6 BLoL!EGLi

New-Password 20

$`cE!"8_dhXWN,<u?`u<

###### 14.7 Parameterbehaete

###### Konstruktoren

Ein Konstruktor ist der Programmcode, der in der Klasse beim
Instanziieren der Klasse aufgerufen wird. .NET-Klassen können in
den Konstruktoren Parameter erwarten. Diese kann man mit
oder ohne runde Klammern nach dem Klassennamen beim
Instanziieren angeben.


Beispiele:

```
$o = New-Object System.Directoryservices.DirectoryEntry("L
DAP://ServerF112")
```
oder

```
$o = New-Object System.Directoryservices.DirectoryEntry "L
DAP://ServerF112"
```
Auch die Konstruktorfunktion kann man einsetzen:

```
$o = [System.Directoryservices.DirectoryEntry]::new("LDA
P://ServerF112")
```
Ganz ausführlich kann man den Befehl auch so schreiben:

```
$o = New-Object -typename System.Directoryservices.Directo
ryEntry -ArgumentList "LDAP://ServerF112"
```
```
ACHTUNG: Einige Klassen erlauben den Aufruf ohne
Konstruktorparameter (z. B. System.Net.WebClient). Man
sagt, dass sie einen "parameterlosen Konstruktor" haben.
Andere Klassen (z. B.
System.Directoryservices.DirectoryEntry) erfordern aber
zwingend die Angaben von einem oder mehreren
Parametern. Es gibt auch Klassen, die sowohl einen
parameterlosen Konstruktor haben als auch einen
Konstruktor mit Parameter, z. B. System. Random oder
System. DateTime.
```

Ein Beispiel anhand der Klasse System. Random:

```
# Ohne Konstruktorparameter
$zufallszahlgenerator = New-Object System.Random
# Mit Konstruktorparameter (Ausgangszahl für die "Berechnu
ng" der Zufallszahl)
$zufallszahlgenerator = New-Object System.Random( 100 )
# Mit Konstruktorfunktion und Konstruktorparameter (Ausgan
gszahl für die "Berechnung"
der Zufallszahl)
$zufallszahlgenerator = [System.Random]::New( 100 )
$zufallszahlgenerator.Next(50,100)
```
Ein weiteres Beispiel anhand der Klasse System. DateTime:

```
# Montag, 1. Januar 0001 00:00:00
$obj = new-Object System.DateTime
# Montag, 13. August 2012 20:10:59
$obj = new-Object System.DateTime(2012,8,13, 20,10,59)
# Montag, 13. August 2016 20:10:59
$obj = [System.DateTime]::new(2016,8,13, 20,10,59)
```
Ein weiteres Beispiel mit der Konstruktorfunktion new() seit
PowerShell 5.0:

```
[KLASSENAME]::new() möglich.
$b = [System.Directoryservices.DirectoryEntry]::new("WinN
T://Server 113 /HS")
$b.FullName
$b.Description = "Autor dieses Buchs"
$b.SetInfo()
```

###### 14.8 Initialisierung von Objekten

Neu seit PowerShell-Version 3.0 ist die Möglichkeit,
Objektinstanzen schon bei der Erzeugung mit Werten aus einer
Hash-Tabelle zu initialisieren

```
@ { Name 1 =Wert; Name 2 =Wert; usw. }
```
auch wenn diese keinen Konstruktor oder keinen geeigneten
Konstruktor besitzen. Dass ein entsprechender Konstruktor fehlt,
kommt bei .NET-Klassen nur selten vor. Mit etwas Suchen findet
man dann doch eine Klasse wie System.
Data.SqlClient.SqlConnection. Diese besitzt im Konstruktor nur
die Übergabemöglichkeit einer Verbindungszeichenfolge. Das
Einschalten der Verbindungsstatistik muss man nachher
erledigen. Das folgende Listing zeigt die zwei bisher möglichen
Varianten (ohne Konstruktorparameter und mit
Konstruktorparameter) sowie die neue Variante mit einer
Initialisierung durch eine Hashtable. Es schont die Fingerkuppen,
ist aber meist weniger übersichtlich.


Listing 14.3 Initialisierungsoptionen für die Klasse SqlClient [dotnet.ps1]

```
# Bisher: ohne Konstruktorparameter
$dbconnection = New-Object System.Data.Sqlclient.SqlConnec
tion
$dbconnection.ConnectionString = "Data Source=.\SQLEXPRES
S;Initial catalog=wwwings6;
Integrated Security=True;"
$dbconnection.StatisticsEnabled = $true
$dbconnection.open()
$dbconnection.State
```
```
# Bisher: mit Konstruktorparameter
$dbconnection = New-Object System.Data.Sqlclient.SqlConnec
tion("Data Source=.\
SQLEXPRESS;Initial catalog=wwwings6;Integrated Security=Tr
ue;")
$dbconnection.StatisticsEnabled = $true
$dbconnection.open()
$dbconnection.State
```
```
# Seit PowerShell-Version 3.0: mit Objektinitialisierung
$dbconnection = [System.Data.Sqlclient.SqlConnection] @{
ConnectionString = "Data Source=.\SQLEXPRESS;Initial catal
og=wwwings6;Integrated
Security=True;";
StatisticsEnabled = $true }
$dbconnection.open()
$dbconnection.State
```

###### 14.9 Nutzung von Attributen und

###### Methoden

Attribute und Methoden eines mit New-Object erzeugten .NET-
Objekts nutzt man genauso wie Attribute und Methoden eines
.NET-Objekts, das von einem Commandlet über die
Punktnotation erzeugt wurde (Trennung von Objekt und Mitglied
durch einen Punkt ".").

Das Beispiel zeigt das Herunterladen einer HTML-Seite von einer
HTTP-Adresse mit Hilfe der Methode DownloadString() und der
Eigenscha ResponseHeaders in der Klasse System. Net.WebClient.

```
Listing 14.4 Herunterladen einer HTML-Seite von einer HTTP-Adresse
```
```
$wc = (new-object System.Net.WebClient)
$wc.DownloadString("http://www.powershell-doktor.de")
"Zusätzliche Header-Informationen:"
$wc.ResponseHeaders.ToString()
```
Ein weiteres Beispiel sei gegeben anhand einer Instanz der Klasse
System. DateTime, wo zu einem Datum eine Eigenscha
ausgegeben wird und dann eine Konvertierungsroutine
aufgerufen wird:

```
$obj = new-Object System.DateTime(2012,1,26)
$obj.Day
$obj.ToLongDateString()
```
Ob der Konstruktor einen Parameter erwartet oder nicht, macht
nur bei New-Object einen Unterschied. Die weitere Verwendung
über die Punktnotation ist gleich.


Bild 14.8 Informationen über die verfügbaren Attribute und Methoden eines Objekts
(inkl. deren Parameter) liefert die .NET API-Dokumentation, hier am Beispiel der
Klasse System.Net.WebClient.

```
Listing 14.5 Informationen von einem Active-Directory-Domänencontroller
```
```
$o = New-Object System.Directoryservices.DirectoryEntry("L
DAP://ServerF112")
"Beschreibungstext: " + $o.description
"Ganzer Name: " + $o.distinguishedName
```
Das obige Skript liefert zum Beispiel folgende Ausgabe:

```
Beschreibungstext: FBI Windows Network
Ganzer Name: DC=FBI,DC=de
```
Eigenschaen kann man auch setzen. Das folgende Beispiel
zeigt, wie man die Bezeichnung eines Laufwerks ändert, indem


man einfach einen neuen Wert in die Eigenscha VolumeLabel
schreibt.

```
$drive = New-Object System.IO.DriveInfo("c:\")
"Bezeichnung des Laufwerks C: vorher: " + $drive.VolumeLab
el
$drive.VolumeLabel = "Systemlaufwerk"
"Bezeichnung des Laufwerks C: nachher: " + $drive.VolumeLa
bel
```
In manchen Fällen reicht das Beschreiben der Eigenscha nicht
und man muss zur Bestätigung noch eine Methode aufrufen. Dies
zeigt das folgende Beispiel, indem man den Beschreibungstext
einer Active-Directory-Domäne setzt. In diesem Fall ist zur
tatsächlichen physikalischen Speicherung der Aufruf
CommitChanges() notwendig. Ob ein Methodenaufruf notwendig
ist oder nicht, sagt die MSDN-Dokumentation typischerweise im
Beschreibungstext der Klasse.

```
$o = New-Object System.Directoryservices.DirectoryEntry("L
DAP:// ServerF112")
$o.description = "Windows Domäne des FBI"
$o.CommitChanges()
```
Bei der Klasse SoundPlayer (nur auf dem klasischen .NET
Framework verfügbar, bisher nicht in .NET Core) muss man zum
Abspielen einer Tonfolge (.wav-Datei) ebenfalls eine Eigenscha
setzen und dann eine Methode aufrufen. Alternativ kann man
den Standort der Audiodatei auch schon im Konstruktor
übergeben.


```
"Sound abspielen:"
$sound = new-Object System.Media.SoundPlayer
$sound.SoundLocation="c:\WINDOWS\Media\notify.wav";
$sound.Play();
```
```
"Sound abspielen:"
$sound = new-Object System.Media.SoundPlayer("c:\WINDOWS\M
edia\notify.wav")
$sound.Play();
```
###### 14.10 Statische Mitglieder in .NET-

###### Klassen und statische .NET-

###### Klassen

.NET-Klassen besitzen das Konzept der statischen Mitglieder
(Klassenmitglieder). Diese Mitglieder gehören zu der Klasse
selbst; man kann und muss sie aufrufen, ohne eine Instanz zu
erzeugen.

Für den Fall der statischen Mitglieder gibt es in der PowerShell
ein anderes Konstrukt, bei dem man den .NET-Klassennamen in
eckige Klammern setzt und dann den Namen des Mitglieds mit
zwei Doppelpunkten abtrennt.

Beispiel:

GetDrives() ist ein statisches Mitglied der Klasse
System.IO.DriveInfo:


```
[System.IO.DriveInfo]::GetDrives()
```
Bild 14.9 Aufruf von Attributen und Methoden: statische Mitglieder versus
Instanzmitglieder


Bild 14.10 Statische Klassemitglieder sind in der .NET API-Dokumentation mit
"static" gekennzeichnet [https://docs.microso.com/en-
us/dotnet/api/system.datetime.now]

Auch die Klasse System.DateTime besitzt ein statisches Mitglied,
das Property Now, das das aktuelle Datum und die aktuelle Zeit
liefert:

```
[System.DateTime]::Now
```
Anstelle der Notation mit eckigen Klammern kann man auch den
eingebauten PowerShell-Typ [Type] verwenden, der auf Basis
einer Zeichenkette ein .NET-Typobjekt erzeugt. Damit kann man
das obige Beispiel auch so schreiben:


```
([Type] "System.IO.DriveInfo")::GetDrives()
([Type] "System.DateTime")::Now
```
Die Klasse System.Math bietet zahlreiche statische Eigenschaen
und Methoden (bei denen die Parameter wie üblich in runden
Klammern übergeben werden), z. B.

```
[System.Math]::PI # Wert von PI 3,14159265358979
[System.Math]::Cos( 90 ) # Kosinus -0,44807361612917
[System.Math]::Log(16,2) # Logarithmus 4
[System.Math]::Truncate(12.34) # Abschneiden der Nachkomma
stellen 12
```
Eine Liste aller statischen Eigenschaen und Methoden einer
Klasse erhält man mit dem Parameter -static bei Get-Member.

Beispiel: [System.Math] | Get-Member -static


Bild 14.11 Ausgabe der statischen Mitglieder der Klasse System.Math

Eine statische Klasse ist eine Klasse, die nur statische Mitglieder
besitzt. Beispiele dafür sind System. Environment. Hier kann man
sich sehr gut merken, dass es keinen Sinn macht, mehrere
"Umgebungen" zu haben. Es gibt genau eine Umgebung. Solche
Klassen besitzen keinen Konstruktor.


Beispiele:

```
[System.Environment]::UserName
[System.Environment]::MachineName
[System.Environment]::OSVersion
```
Der folgende Befehl nutzt die statische Methode Beep() in der
statischen Klasse System. Console zur Ausgabe eines Tons:

```
[System.Console]::Beep(800, 500 )
```
Von statischen Klassen kann man keine Instanzen erzeugen,
sondern nur die statischen Mitglieder nutzen. Folglich kann man
das Commandlet New-Object auf statische Klassen nicht
anwenden.

```
# Das geht nicht:
#(New-Object System.Console).Beep(800,500)
```
Hier kommt es zur Fehlermeldung "A constructor was not found".
Diese Meldung heißt im Umkehrschluss aber nicht zwingend,
dass es sich um eine statische Klasse handelt. Die Meldung heißt
nur, dass es keinen Konstruktor mit der angegebenen Anzahl der
Parameter gibt. So kommt es zur gleichen Fehlermeldung bei der
Ausführung von

```
$d = New-Object System.IO.DriveInfo
```
auch wenn die System. IO.DriveInfo keine statische Klasse ist.
Aber es ist eine Klasse, die verpflichtend einen Parameter im
Konstruktor erwartet, z. B.


```
$d = New-Object System.IO.DriveInfo("C")
```
oder

```
$d = New-Object System.IO.DriveInfo("C:")
```
Auch auf statische Mitglieder einer Klasse kann man über
Variablen zugreifen. Dabei wird der Variablen nicht mit New-
Object eine Instanz der Klasse zugewiesen, sondern die Klasse
selbst über die Schreibweise in eckigen Klammern.

```
PS X:> $e = [System.Environment]
PS X:> $e
IsPublic IsSerial Name BaseType
-------- -------- ---- --------
True False Environment System.Object
```
```
PS X:> $e::MachineName
PC 123
```
###### 14.11 Generische Klassen nutzen

Seit PowerShell 2.0 wird auch die Instanziierung generischer
.NET-Klassen auf einfache Weise unterstützt. Eine generische
Klasse hat einen oder mehrere Typparameter, die den Inhalt oder
Zwecke näher beschreiben. Ein oder mehrere Typparameter
werden in eckigen Klammern nach dem Klassennamen genannt.


WICHTIG: Wenn es mehr als einen Typparameter gibt,
muss der ganze Klassenname inklusive der
Typparameterangaben in Anführungszeichen stehen!


```
Listing 14.6 [2_Aufbauwissen\DOTNET\GenerischeKlassen.ps1]
# Beispiel für eine generische Klasse mit einem Typparamet
er:
$l = New-Object System.Collections.Generic.List[string]
$l.Count
$l.Add( 1 )
$l.Add( 10 )
$l.Add("Holger")
$l.Count
$l
```
```
# Beispiel für eine generische Klasse mit zwei Typparamete
rn
# In diesem Fall muss der ganze Klassenname in einfachen o
der doppelten
Anführungszeichen stehen
$dic = New-Object "System.Collections.Generic.SortedDictio
nary[int,string]"
$dic.Add(45257,"Essen")
$dic.Add(80538,"Schwabing")
$dic.Add(10789,"Berlin")
$dic.Count
"Nur die Schlüssel:"
$dic.Keys
"Nur die Werte:"
$dic.Values
"Schlüssel und Wert"
$dic
```
Vorteil generischer Listenklassen gegenüber den normalen
PowerShell-Arrays ist, dass man den Datentyp für den Inhalt


einschränken kann auf einen bestimmten Datentyp. In der
folgenden Liste dürfen nur Zahlen sein!

```
ACHTUNG: Bei Verwendung von [string] als
Typparameter kann man bei Add() alles anfügen, weil
PowerShell immer ToString() aufru.
```
```
Listing 14.7 [2_Aufbauwissen\DOTNET\GenerischeKlassen.ps1]
```
```
$l = New-Object System.Collections.Generic.List[int]
$l.Count
$l.Add( 1 )
$l.Add( 10 )
$l.Add("Holger") # FEHLER: Cannot convert value "Holger" t
o type "System.Int 32
$l.Count
$l
```

```
HINWEIS: Alternativ ist bei generischen Klassen auch eine
Schreibweise möglich, bei der die Anzahl der
Typparameter nach einem `` vor der öffnenden
geschweien Klammer stehen können. Dies sieht man
immer wieder in Beispielen, ist aber nicht zwingend
notwendig:
```
```
$l = New-Object System.Collections.Generic.List`` 1
[string]
```
bzw.

```
$dic = New-Object "System.Collections.Generic.Sort
edDictionary`` 2 [int,string]"
```
###### 14.12 Zugriff auf bestehende

###### Objekte

Während es bei WMI (siehe Kapitel zu WMI) den Gedanken gibt,
dass Instanzen bereits für Ressourcen im System (z. B. Benutzer)
existieren und man diese bestehenden Instanzen mit
GetWmiObject abrufen kann, geht man bei .NET in der Regel davon
aus, dass man Objekte neu erzeugt, gegebenenfalls für
vorhandene Ressourcen. Eine allgemeine Möglichkeit zum Abruf
bestehender Instanzen gibt es daher nicht.

Einige Klassen bieten aber statische Mitglieder, die Instanzen
liefern, z. B. GetDrives() in der Klasse System. IO.DriveInfo.


Der folgende Befehl listet alle CD/DVD-Laufwerke auf.

```
[System.IO.DriveInfo]::GetDrives() | where { $_.DriveType
```
- eq
[System.IO.DriveType]::CDRom} | fl Name, DriveType, IsRead
y

###### 14.13 Laden von Assemblies

.NET besteht aus vielen DLLs (dort "Assembly" genannt). Nicht
alle diese Assemblies werden automatisch in die PowerShell
geladen. .NET-Klassen können über New- Object oder die
Notation in eckigen Klammern nur genutzt werden, wenn die
Sowarekomponente (Assembly), in der sich die jeweilige .NET-
Klasse befindet, auch in die aktuelle PowerShell-Instanz geladen
ist.

Die PowerShell lädt einige Assemblies des .NET Frameworks
automatisch, aber bei weitem nicht alle. In solchen Fällen muss
man das Laden der Assembly über die Klasse System. Reflection
.Assembly erst anstoßen.

Beispiel 1

Um ein Dialogfenster auszugeben, muss man erst die Assembly
System.Windows.Forms.dll laden. Da sich diese Assembly im
sogenannten Global Assembly Cache (GAC) im Pfad c:\
Windows\Assembly von .NET befindet, muss man keinen Pfad
dahin angeben.


```
[System.Reflection.Assembly]::LoadWithPartialName("System.
Windows.Forms") [System.Windows.Forms.MessageBox]::Show("T
ext","Ueberschrift", [System.Windows.Forms. MessageBoxButt
ons]::OK)
```
Ohne das Laden der Assembly würde der Befehl in der zweiten
Zeile auf einen Fehler laufen: "Der Typ
[System.Windows.Forms.MessageBox] wurde nicht gefunden:
Vergewissern Sie sich, dass die Assembly, die diesen Typ enthält,
geladen ist."

Die Methode LoadWithPartialName() lädt eine Assembly nur aus
dem Global Assembly Cache (GAC). Um eine Assembly aus einem
beliebigen Pfad zu laden, kann man LoadFrom() verwenden:

```
[Reflection.Assembly]::LoadFrom("c:\Windows\Microsoft.NET
\Framework 64 \v4.0.30319\
System.windows.forms.dll")
```
Bild 14.12 Die Nutzung der Klasse MessageBox ist erst erfolgreich, wenn die
zugehörige Assembly geladen wurde.


TIPP: Das Laden einer Assembly gilt nur bis zum Beenden
der Instanz des aktuellen PowerShell-Hosts. Der Befehl ist
daher ein guter Kandidat für die profile.ps 1 - Datei (siehe
Kapitel "Standardeinstellungen ändern mit
Profilskripten").

Die Verwendung von Out-Null in obigem Skript ist
optional. Sie unterdrückt die Ausgabe der Assembly-
Informationen.

TIPP: Eine Vereinfachung ist möglich über das
Commandlet Add-Type mit Parameter -AssemblyName, dass
eine Assembly aus dem Global Assembly Cache (GAC)
lädt:

```
Add-Type -assembly "System.windows.forms"
[System.Windows.Forms.MessageBox]::Show("Text","Ueb
erschrift",
System.Windows.Forms.MessageBoxButtons]::OK)
```
Falls eine Assembly nicht im GAC liegt, kann man sie über
Add-Type mit Parameter -Path von einem beliebigen
Standort laden.

Eine weitere Option zum Laden von Assemblies ist das
Commandlet Resolve-Assembly aus den PSCX:

```
Resolve-Assembly system.windows.forms -import
```

Beispiel 2

Ein weiteres Beispiel ist die Anzeige einer Inputbox, die man in
der Assembly Microso.VisualBasic.dll findet:

```
[System.Reflection.Assembly]::LoadWithPartialName("Microso
ft.VisualBasic")
$eingabe = [Microsoft.VisualBasic.Interaction]::InputBox
("Frage","Titel")
```
Alternativ kann man eine Assembly mit Add-Type laden:

```
Add-Type -AssemblyName Microsoft.VisualBasic
$eingabe = [Microsoft.VisualBasic.Interaction]::InputBox
("Frage","Titel")
```
Laden bereits geladener Assemblies

Es führt nicht zum Fehler, wenn man eine bereits geladene
Assembly erneut lädt. Microso ändert auch den Satz der im
Standard geladenen Assemblies immer mal wieder. So lädt die
PowerShell inzwischen die System. Windows.Forms.dll
automatisch.

```
HINWEIS: Um nicht von dem Standardlageverhalten der
PowerShell abhängig zu sein, sollte man immer in einem
Skript die benötigten Assemblies explizit laden!
```

###### 14.14 Liste der geladen Assemblies

Sie können sich ausgeben lassen, welche Assemblies in einem
PowerShell-Host gerade geladen sind.

```
[System.AppDomain]::CurrentDomain.GetAssemblies()
```
```
HINWEIS: Das Ergebnis ist stark abhängig von dem
PowerShell-Host, in dem sie den Befehl ausführen. Wenn
man den Befehl z. B. in der PowerShell ISE ausführt, sind
dort auch Assemblies für die Windows Presentation
Foundation (WPF) geladen, die die normale
Standardkonsole nicht braucht.
```

Bild 14.13 Liste der im Standard geladenen Assemblies in der Standardkonsole in
PowerShell 7 (Hintergrund) und Windows PowerShell 5.1 (Vordergrund): Das moderne
.NET besteht aus wesentlich mehr einzelnen Assemblies!

In der PowerShell 6/7 ist die Liste zwar viel länger. Das bedeutet
aber nicht, dass hier mehr Funktionen zur Verfügung stehen,
sondern nur, dass .NET Core modularer ist und die Funktionen in
viele einzelne, kleinere Assemblies zerteilt ist.


###### 14.15 Verwenden von NuGet-

###### Assemblies

Microso Sowarekomponentenportal NuGet (www.nuget.org)
ist nicht auf die Verwendung mit der PowerShell ausgerichtet.
Dennoch kann man .NET-Bibliothek, die dort bereitgestellt
werden, in der PowerShell nutzen. Dies soll gezeigt werden am
Beispiel der Bibliothek "AForge.Imaging"
[www.nuget.org/packages/AForge.Imaging] mit der man
Grafiken verändern kann.

Die auf der Website genannten Installationsoptionen für das
NuGet-Paket machen für die PowerShell leider keinen Sinn, auch
wenn es verlockend erscheint, das dort genannte PowerShell-
Commandlet Install-Package zu nutzen; leider funktioniert das
für NuGet-Pakete nur innerhalb von Visual Studio-Projekten.
Wählen Sie daher den "Manual Download".


Bild 14.14 Manueller Download eines NuGet-Pakets
[www.nuget.org/packages/AForge.Imaging]

Sie erhalten eine .nupkg-Datei. Dies ist in Wirklichkeit eine .ZIP-
Datei. Ändern Sie die Dateinamenserweiterung in .ZIP und
entpacken Sie die Datei dann. Verfahren Sie so mit den unter
"Dependencies" genannten weiteren NuGet-Paketen.


Bild 14.15 Ausgepackte NuGet-Pakete

Das folgende Skript zeigt, wie man ein beliebige Grafikdatei in die
gelblich-bräunlichen Farbe Sepia umwandelt.

```
Listing 14.8 [Nuget.ps1]
"Lade benötigte DLLs"
$nugetRoot = "$PSScriptRoot/NugetPakete"
$Dlls = "$nugetRoot\aforge.2.2.5\lib\AForge.dll", "$nugetR
oot\aforge.math.2.2.5\lib\
AForge.Math.dll", "$nugetRoot\aforge.imaging.2.2.5\lib\AFo
rge.Imaging.dll"
$Dlls | ForEach-Object { [Reflection.Assembly]::LoadFrom
($_) }
[Reflection.Assembly]::LoadWithPartialName("System.Window
s.Forms");
$path = "$PSScriptRoot/daten/foto.jpg"
"Lade Bild $path"
$i = new-object System.Drawing.Bitmap($path);
$filter = new-object AForge.Imaging.Filters.Sepia
$filter.ApplyInPlace($i)
"Speichere Bild $path"
$path = "$PSScriptRoot/daten/foto-sepia.jpg"
$i.Save($path)
```

```
HINWEIS: Die Dokumentation dieser .NET-Bibliothek
finden Sie unter
http://www.aforgenet.com/aforge/framework/.
Nicht alle auf http://www.nuget.org gelisteten
Sowarekomponenten sind .NET-Assemblies. Es gibt dort
auch einige JavaScript-Komponenten (z. B. jQuery,
Bootstrap), die man nicht in die PowerShell einbinden
kann.
```
###### 14.16 Objektanalyse

Mit Hilfe des Commandlets Get-Member, das im ersten Teil des
Buchs schon zur Analyse von Pipeline-Inhalten verwendet wurde,
kann man übrigens auch den Inhalt einer Variablen analysieren,
die eine Objektinstanz erhält. Zu beachten ist dabei nur, dass das
Objekt entweder über die Pipeline an Get-Member zu schicken ist
(also $Variable | Get-Member) oder aber der Parametername -
InputObject zu verwenden ist (Get-Member -InputObject
$Variable). Nicht nur Get-Member, sondern den meisten
Commandlets ist es egal, ob sich in der Pipeline eine
Objektmenge oder ein einzelnes Objekt befindet.


```
TIPP: Die statischen Mitglieder einer Klasse kann man
ganz allgemein erforschen mit Get-Member. Dazu sendet
man den Klassennamen in eckigen Klammern an Get-
Member mit dem Zusatz -static: [System.Net.WebClient] |
gm -static
```
Das Innenleben einer .NET-Klassenbibliothek in einer .NET-
Assembly kann man mit dem kostenfreien Open Source-
Werkzeug ILSpy (Download unter
https://github.com/icsharpcode/ILSpy) erforschen, das das
"Innenleben" einer Assembly anzeigt (und damit auch alle in der
Assembly enthaltenen Klassen) und eine Suchfunktion bietet,
über die sich z. B. einzelne Klassen auffinden lassen.

###### 14.17 Aufzählungstypen

###### (Auflistungen/Enumerationen)

Ein Aufzählungstyp (Es gibt zahlreiche in der Fachwelt
verwendete Aliase für diesen Begriff, z. B.: Aufzählungsklasse,
Aufzählung, Auflistung, Auflistungstyp, Auflistungsklasse, Enum,
Enumeration, Enumerationstyp, Enumerationsklasse) ist eine
.NET-Klasse, die eine Menge statischer Werte enthält, die andere
.NET-Klassen als eine abgrenzte Menge von Werten für Attribute
oder als Parameter für Methoden oder als Rückgabewerte für
Methoden oder Commandlets als Parametertypen nutzen.

Eine Besonderheit sind Flag-Aufzählungstypen (alias Bitflags).
Bei diesen können mehrere Werte gleichzeitig zutreffen. Dies ist


möglich, indem jedem Eintrag in dem Aufzählungstyp genau ein
Bit zugeordnet ist. Durch das Setzten mehrerer Bits in der Zahl
können also mehrere Werte angewendet werden.

14.17.1 Einsatz für einen einfachen

Aufzählungstyp

Zum Beispiel hat die Klasse System. IO.DriveInfo ein Attribut mit
Namen DriveType, das den Datentyp System. IO.DriveType
besitzt.

Bild 14.16 Mitglieder der Klasse System.IO.DriveInfo

System. IO.DriveInfo ist eine Aufzählung, die folgende Einträge
als mögliche Werte definiert:

Eintragsname Wert

Unknown 0

NoRootDirectory 1

Removable 2


Fixed 3

Network 4

CDRom 5

Ram 6

Intern sind diesen Aufzählungseintragsnamen Ganzzahlen
zugeordnet, aber im Programmcode und in der PowerShell kann
man diese Werte als sprechenden Namen verwenden.

Bild 14.17 Arbeit mit Enumerationen

Der folgende Befehl filtert alle CD-ROM-Laufwerke:


```
[System.IO.DriveInfo]::GetDrives() | Where-Object { $_.Dri
veType -eq
[System.IO.DriveType]::CDRom} | Format-List Name, DriveTyp
e, IsReady
```
Alternativ kann man auch die Zahl statt dem
Aufzählungseintragsnamen verwenden, also die Zahl 5 statt
[System.IO.DriveType]::CDRom:

```
[System.IO.DriveInfo]::GetDrives() | Where-Object { $_.Dri
veType -eq
5 } | Format-List Name, DriveType, IsReady
```
14.17.2 Liste der möglichen Werte eines

Aufzählungstyps

Die Liste der möglichen Werte eines Aufzählungstyps erhält man
über die statische Methode GetNames() der Klasse System.Enum,
der man den Namen einer Enumerationsklasse übergeben kann,
z. B. [System.Enum]::GetNames([System.IO.DriveType]).

Allerdings sieht man so nur die Namen der Einträge in der
Aufzählung, nicht die zugehörigen Zahlenwerte. Um an einer
Tabelle inklusive der Zahlenwerte zu kommen, kann man eine
Hilfsfunktion Get-Enum verwenden, die Microso unter
[blogs.technet.microso.com/fieldcoding/ 2017 / 05 / 18 /powershell-
tip-getting-enum-values-as-names-int-and-bit] veröffentlicht hat.


Listing 14.9 [Enumerationen.ps1]

```
function Get-Enum {
param (
[type]$Type
)
if ($Type.BaseType.FullName -ne 'System.Enum')
{
Write-Error "Type '$Type' is not an enum"
return
}
if ($Type.CustomAttributes | Where-Object { $_.Attribu
teType -eq [System.
FlagsAttribute] })
{
Write-Host "Type '$Type' is a Flags enum"
Write-Host
$isFlagsEnum = $true
}
```
```
$props = @(
@{ Name = 'Name'; Expression={ [string]$_ } }
@{ Name = 'Value'; Expression={ [uint 32 ](Invoke-Ex
pression "[$($type.
FullName)]'$_'") }}
)
```
```
if ($isFlagsEnum)
{
$props += @{ Name = 'Binary'; Expression={[Conver
t]::ToString([uint 32 ]
(Invoke-Expression "[$($type.FullName)]'$_'"), 2 )}}
```

```
}
```
```
[enum]::GetNames($Type) |
Select-Object -Property $props
}
```
```
# nur die Namen
[System.Enum]::GetNames([System.IO.DriveType])
```
```
# Namen und Werte in einer Tabelle
Get-Enum System.IO.DriveType
```
14.17.3 Verknüpfen von Flag-

Aufzählungswerten (Bitflags)

Bei der Benutzung einiger .NET-Klassen, z. B. FileSystemRights
für Rechte im Dateisystem, muss man verschiedene Flags durch
ein binäres Oder (PowerShell-Operator -bor) miteinander
verknüpfen.

```
$Rights= [System.Security.AccessControl.FileSystemRight
s]::Read `
```
- bor [System.Security.AccessControl.FileSystemRights]::Rea
dExtendedAttributes `
- bor [System.Security.AccessControl.FileSystemRights]::Rea
dAttributes `
- bor [System.Security.AccessControl.FileSystemRights]::Rea
dPermissions


Wenn man bei jedem Flag den Namen der Aufzählung, in der das
Flag definiert ist, wiederholen müsste, würden die Fingerkuppen
enorm strapaziert. Die PowerShell ist in der Lage, aus einer
Zeichenkette mit Kommatrennung die entsprechenden
Flagwerte in der Enumeration zu suchen und miteinander durch
ein binäres ODER zu verknüpfen. Anstelle des obigen Befehls
kann man also verkürzt schreiben:

```
$Rights = [System.Security.AccessControl.FileSystemRights]
"ReadData, ReadExtendedAttributes, ReadAttributes, ReadPer
missions"
```
Ein weiterer Fall von Bitflags sind die Attribute einer Datei im
Dateisystem. Hier wird nicht nur gezeigt, wie man mit binärem
ODER (PowerShell-Operator -bor) mehrere miteinander
verknüpfen kann, sondern, wie man auch einzelne Werte
aktivieren kann (-bor auf bestehenden Werten) oder einen
einzelnen Wert deaktivieren kann (binäres UND mit -band auf der
binären Negation des gewünschten Wertes mit -bnot).


# Attribute einer Datei ausgeben
Get-ItemProperty w:\daten.txt -name attributes
# Setze Archive und ReadOnly
Set-ItemProperty w:\daten.txt -name attributes -value ([Sy
stem.
IO.FileAttributes]::ReadOnly -bor [System.IO.FileAttribute
s]::Archive)
# Setze Readonly, lasse alle anderen Dateiattribute unverä
ndert
$attr = (Get-ItemProperty w:\daten.txt -name attributes).a
ttributes
Set-ItemProperty w:\daten.txt -name attributes -value ($at
tr -bor [System.
IO.FileAttributes]::ReadOnly)
# Entferne Readonly, lasse alle anderen Dateiattribute unv
erändert
$attr = (Get-ItemProperty w:\daten.txt -name attributes).a
ttributes
Set-ItemProperty w:\daten.txt -name attributes -value ($at
tr -band (-bnot [System.
IO.FileAttributes]::ReadOnly))


# 15 Verwendung von COM-

# Klassen

Die klassische Windows PowerShell basiert auf dem Microso
.NET Framework und Power Shell "Core"-Editionen basieren auf
.NET Core. Dennoch kann die PowerShell nicht nur .NET-Klassen,
sondern auch Klassen aus dem Vorgänger von .NET, dem
Component Object Model (COM), verwenden. .NET sollte
eigentlich COM komplett ablösen, aber Microso hat viele
Funktionen in seinem Betriebssystem und die Anwendungen (z.
B. Microso Office) wurden niemals in .NET, sondern nur über
COM bereitgestellt. Seit Windows 8 hat COM sogar eine
Renaissance erfahren, weil das neue Betriebssystem API
"Windows Runtime" auf COM basiert.


```
HINWEIS: Die in diesem Kapitel erläuterten Techniken
sind nicht verfügbar für PowerShell 6/7 unter Linux und
macOS, weil es dort keine COM-Objekte gibt! Unter
Windows Nano Server gibt es zwar COM-Objekte und die
in diesem Kapitel vorgestellten Techniken sind auch in
Windows PowerShell Core 5.1 anwendbar, allerdings gibt
es dort nur sehr wenige COM-Klassen.
```
###### 15.1 Unterschiede zwischen COM

###### und .NET

Die Handhabung von COM-Objekten unterscheidet sich in
folgenden Punkten von der von .NET-Objekten:

```
Es gibt keine Konstruktoren mit Parametern.
Es gibt keine statischen Klassenmitglieder.
Die Meta-Informationen, die Get-Member liefert, sind nicht so
vollständig und so akkurat wie bei .NET. Dies wurde aber in
PowerShell 7 verbessert.
```
###### 15.2 Erzeugen von COM-Instanzen

Bei der Instanziierung von COM-Klassen kommt ebenfalls das
Commandlet NewObject zum Einsatz. Dem Namen der COM-
Klasse ist aber der Parameter -comobject (kurz: - com)


voranzustellen. Als Name ist der Programmatic Identifier (ProgID)
der COM-Klasse anzugeben. Die COM-Klasse muss auf dem
lokalen System in der Registrierungsdatenbank verzeichnet sein.
New-Object entspricht CreateObject() in Visual Basic/VBScript.
Die Konstruktorfunktion new() kann für COM-Klassen nicht
eingesetzt werden!

Beispiel: Instanziierung der COM-Klasse SAPI.SPVoice aus dem
Speech-API von Windows:

```
New-Object -ComObject SAPI.SPVoice
```
###### 15.3 Abruf der Metadaten

Wie bei .NET-Objekten auch, kann man sich die Liste der Methode
und Properties eines COM-Objekts in der Pipeline mit Get-Member
ausgeben lassen. Neu seit PowerShell 7.0 ist, dass man dabei
nicht nur den Datentyp, sondern auch den Namen der Parameter
von Methoden sieht. Dies hil erheblich zum Verständnis, wie
man die Methode aufrufen muss.


Bild 15.1 Instanziierung des COM-Objekts "SAPI.SPVoice" in der PowerShell 5.1 und
Ausgabe von Get-Member


Bild 15.2 Instanziierung des COM-Objekts "SAPI.SPVoice" in der PowerShell 7 und
Ausgabe von Get-Member

###### 15.4 Nutzung von Attributen und

###### Methoden

Die Nutzung von Attributen und Methoden erfolgt wie bei .NET-
Klassen über die Punktnotation (.). Fälle, in denen zwei
Doppelpunkte ("::") zu verwenden wären, gibt es hier bei COM-
Objekten aber nicht.

Das erste Beispiel ermöglicht eine Sprachausgabe mit der COM-
Klasse SAPI.SPVoice. Da die Methode Speak() eine Zahl (Stream-
ID, in PowerShell in der Regel nicht relevant) zurückliefert, wird
hier out-null verwendet, um die Ausgabe zu unterdrücken.


```
Listing 15.1 [COM CreateObject.ps1]
$SAPI = New-Object -ComObject SAPI.SPVoice
$SAPI.speak("Guten Tag, es ist " + (Get-Date)) | out-null
```
Mit dem zweiten auf einer COM-Komponente basierenden Skript
öffnet man den Internet Explorer mit einer bestimmten Seite mit
Hilfe der COM-Klasse InternetExplorer.Application.

```
Listing 15.2 [COM CreateObject.ps1]
$ie = New-Object -com "InternetExplorer.Application"
$ie.Navigate("http://www.powershell-doktor.de")
$ie.visible = $true
```
Das dritte Skript verwendet die COM-Klasse "Shell.Application",
um den Papierkorb des angemeldeten Benutzers zu leeren.

```
Listing 15.3 [COM Papierkorb leeren.ps1]
# COM-Objekt für Shell erzeugen
$objShell = New-Object -ComObject "Shell.Application"
```
```
# Zugriff auf Papierkorb
$ssfBITBUCKET = 0 x 0 a # Konstante für den Papierkorb
$objFolder = $objShell.Namespace($ssfBITBUCKET)
```
```
# Liste der Elemente in dem Ordner, rekursiv löschen
$objFolder.items() | %{ remove-item $_.path -Recurse -Conf
irm:$false -verbose }
```
Das vierte Beispiel zeigt den Aufruf der Methode GetTempName()
aus der COM-Klasse Scripting.FileSystemObject. Diese Methode
liefert einen Namen für eine temporäre Datei.


```
Listing 15.4 [COM CreateObject.ps1]
$fso = New-Object -com "Scripting.Filesystemobject"
$fso.GetTempName()
```
###### 15.5 Liste aller COM-Klassen

Die verfügbaren COM-Klassen sind in der
Registrierungsdatenbank von Windows verzeichnet und können
dort aus dem Schlüssel HKEY_CLASSES_ROOT\CLSID ausgelesen
werden.

```
dir -Path REGISTRY::HKEY_CLASSES_ROOT\CLSID -Include ProgI
D -Recurse | foreach { $_.GetValue("") } | Sort-Object | F
ormat-Wide -Property @{Expression={$_}} - column 3 - Force
```
Bild 15.3 Liste aller unter Windows Nano Server 2016 verfügbaren COM-Klassen. In
größeren Windows-Varianten würde diese Liste über viele Bildschirmseiten gehen.


###### 15.6 Holen bestehender COM-

###### Instanzen

In der COM-Welt gibt es darüber hinaus eine globale Liste, in der
sich laufende Instanzen bzw. im Dateisystem existierende
Objekte verzeichnen können. Diese Running Objects Table
spricht man in vielen Programmiersprachen über GetObject() an.
Ein direktes Äquivalent für das GetObject() gibt es in der
PowerShell nicht. Hier gibt es nur die Möglichkeit, die Assembly
für Visual Basic .NET zu laden und die dortige Methode
GetObject() zu nutzen.

Das folgende Beispiel zeigt ein Word-Dokument (.docx) in
Microso Word auf dem Bildschirm an und schreibt einen Text in
das Dokument.

```
Listing 15.5 [COM GetObject.ps1]
Add-Type -assemblyname microsoft.visualbasic
$doc = [microsoft.visualbasic.interaction]::GetObject
("w:\daten\text.docx")
$doc.application.visible = $true
$doc.application.selection.typetext("Erfolgreicher Start v
on Word!")
```
###### 15.7 Distributed COM (DCOM)

Auch Fernaufrufe von COM-Objekten sind möglich mit der
PowerShell über das alte Distributed Component Object Model


(DCOM)-Protokoll. Dazu verwendet man am einfachsten die
statische Methode CreateObject(), die die Klasse Microsoft.
VisualBasic.Interaction in der Microso. VisualBasic.dll
bereitstellt.

Das folgende Skript nutzt via DCOM das COM-Objekt Microsoft.
Update.Session, mit dem man eine Liste der anstehenden
Windows-Updates bekommt, wenn man zunächst
CreateUpdateSearcher() und dann darauf Search() aufru.

```
HINWEIS: [void] sorgt dafür, die das Rückgabeobjekt der
Methode LoadWithPartialName() nicht auszugeben!
```
```
Listing 15.6 [\2_Aufbauwissen\COM\DCOM_WindowsUpdate.ps1]
function Get-Updates([string]$computer=$env:computername){
```
```
[void][Reflection.Assembly]::LoadWithPartialName("Microsof
t.VisualBasic")
$session=[Microsoft.VisualBasic.Interaction]::CreateObjec
t("Microsoft.Update.
Session",$computer)
$searcher=$session.CreateUpdateSearcher()
$searcher.Search("IsInstalled= 0 and Type='Software' and Is
Hidden=0")
}
```
```
$updateinfo = Get-Updates SERVER 123
$updateinfo.updates | ft title, LastDeploymentChangeTime
```

Bild 15.4 Liste der ausstehenden Updates auf einem System


##### 16 Zugriff auf die Windows

##### Management Instrumentation

##### (WMI)

Mehrere Commandlets (z. B. Get-WmiObject, Get-CimInstance, Get-CimClass)
sowie die eingebauten PowerShell-Typen [WMI], [WMIClass] und
[WMISEARCHER] eröffnen die Welt der Windows Management Instrumentation
(WMI), die in den modernen Windows-Betriebssystemen mit mehreren
tausend Klassen fast jeden Baustein des Betriebssystems objektorientiert
anbietet. Auch einige Anwendungen können über WMI verwaltet werden.

```
HINWEIS: Die in diesem Kapitel vorgestellten Techniken und
Commandlets sind komplett nur unter Windows PowerShell 5.1
verfügbar. Windows PowerShell Core 5.1 und die moderne
PowerShell ("Core") ab Version 6.0 unter Windows beinhalten nur
einen Teil davon. Die moderne PowerShell unter Linux und macOS
kann WMI bzw. eine plattformneutrale Version davon wie die Open
Management Infrastructure (OMI) (alias "NanoWbem") noch gar nicht
nutzen!
```
16.1 Einführung in WMI


Dieses Unterkapitel bietet eine Einführung in WMI für Leser, die bisher nicht
mit WMI vertraut sind. Wenn Sie WMI schon aus dem Windows Script Host
(WSH) oder anderen Programmierumgebungen kennen, können Sie dieses
Unterkapitel übergehen.

Was ist WMI?

Die Windows Management Instrumentation (WMI) ist ein Windows-
Systembaustein zum Zugriff auf System- und Netzwerkinformationen. Mit
WMI kann man:

```
Systeminformationen über einzelne Systembausteine oder ganze
Mengen von Systembausteinen auslesen,
Systeminformationen verändern,
Aktionen ausführen,
sich über Veränderungen im System informieren lassen.
```
WMI ist die Microso-Implementierung des Web Based Enterprise
Management (WBEM). WBEM ist ein Standard der Desktop Management Task
Force (DMTF) für das Netz- und Systemmanagement, also zur Verwaltung
von Netzwerk- und Systemressourcen (z. B. Hardware, Soware, Benutzer).
WBEM wurde ursprünglich von BMC Soware, Cisco Systems, Compaq, Intel
und Microso entwickelt und später an die DMTF übergeben. Aus
historischen Gründen findet man in WMI-Werkzeugen häufig noch die
Bezeichnung WBEM.

Kern von WBEM ist das Common Information Model (CIM), das die durch
WBEM zu verwaltenden Ressourcen durch objektorientierte Methoden
modelliert. CIM ist ein Framework zur Beschreibung sowohl physischer als
auch logischer Objekte (alias Managed Objects). Die DMTF versteht CIM als
eine Vereinigung bestehender Managementarchitekturen wie dem OSI
Management Framework X.700 (Common Management Information Protocol

- CMIP) und dem Simple Network Management Protocol.

Ein Managed Object (MO) ist eine von WMI/WBEM verwaltete und im CIM
beschriebene Ressource in einem System oder einem Netzwerk.


```
ACHTUNG: Der Name Web Based Enterprise Management ist
irreführend, weil er nahelegt, dass es sich bei WBEM um eine
grafische Benutzerschnittstelle auf Webbasis für das Management
von Systeminformationen handelt. WBEM ist jedoch lediglich eine
Architektur mit Programmierschnittstelle, also weder Werkzeug noch
Anwendung.
```
Versionszählung

WMI ist fester Bestandteil von Windows schon seit Windows ME. Bisher
orientierte sich die Versionszählung an der internen
Betriebssystemversionsnummer. In Windows Vista trägt WMI die
Versionsnummer 6.0, in Windows 7 WMI 6.1 und in Windows 8.x ist WMI 6.2
enthalten. Zwischen Windows 2000 und Windows XP hatte Microso einen
Versionssprung von 1.5 auf 5.1 gemacht.

Im Zuge von Windows 8/Windows Server 2012 entwickelte Microso auch
eine neue Implementierung von WMI. Microso nennt diese Version "WMI 2".
Damit bezieht Microso sich aber auf die grundlegende WMI-Infrastruktur,
während die Versionszählung 6.x sich an den Inhalten im WMI-Repository
orientiert. Microso knüp für die WMI-Infrastruktur an die alte
Versionszählung (1.5) bei Windows 2000 an.

WMI 2 ist für alle Betriebssysteme verfügbar, auf denen auch PowerShell ab
Version 3.0 verfügbar ist (also ab Windows 7 und Windows Server 2008), und
wird zusammen mit Power-Shell als Teil des "Windows Management
Framework" installiert.

Seit Windows 10 und Windows Server 2016 hat WMI die Versionsnummer
10.0. Der Versionssprung ist aber nur als Angleichung an die
Betriebssystemnummer zu verstehen. Funktionale Unterschiede zu WMI 6.2
gibt es nicht, außer, dass es noch einige WMI-Klassen mehr gibt.

WMI-Funktionsumfang


Die Informationsfülle, die WMI auf modernen Betriebssystemen liefert, ist
riesig. Windows 11 bietet in der Grundausstattung ohne Zusatzmodule
bereits 12 875 WMI-Klassen!

Bild 16.1 Zählen der WMI-Klassen (hier in Windows 11)

```
ACHTUNG: Ältere Windows-Versionen besitzen deutlich weniger WMI-
Klassen. Ein Nachrüsten von mit dem Betriebssystem mitgelieferten
WMI-Klassen auf älteren Betriebssystemen ist grundsätzlich von
Microso nicht vorgesehen.
```
Beispiele für Bereiche, aus denen WMI Informationen liefert, zeigt die
folgende Tabelle.


Tabelle 16.1 Überblick über WMI-Informationen

```
Grundkonfiguration BIOS
```
```
Boot-Konfiguration
```
```
Installiertes Betriebssystem (z. B.
Betriebssystemname, Build-Version,
Installationsdatum, Datum und Uhrzeit des
letzten Boot-Vorgangs)
```
```
Umgebungsvariablen
```
```
Performance-Monitor-Daten
```
```
SNMP-Daten
```
```
Eingerichtete Zeitzonen
```
```
Drucker und Druckerwarteschlangen
```
```
Auslagerungsdateien
```
```
Datum und Uhrzeit
```
```
Clustering
```
```
Hard- und Soware Installierte Soware
```
```
Installierte Updates und Hotfixes
```
```
Installierte Hardware (z. B. Netzwerkkarten,
Grafikkarten) einschließlich Treiber und
deren Zuordnung zu LoadOrderGroups,
belegter Ressourcen (IRQ, Port, DMA),
Konfiguration (z. B. Druckereinstellungen)
```

```
Installierte COM-Komponenten einschließlich
Zuordnung zu Komponentenkategorien und
DCOM-Einstellungen
```
```
Laufende Prozesse
```
```
Geplante Vorgänge (Zeitplandienst)
```
```
Programmgruppen im Startmenü
```
```
Windows-Systemdienste
```
Sicherheit Benutzerkonten (inklusive deren
Gruppenzuordnung, Desktop-Einstellungen
und Ereignisprotokolleinträge)

```
Security Configuration Editor (SCE)
```
Dateisystem und
Datenspeicher

```
Ordner und Dateien des Dateisystems
```
```
Netzlaufwerksverbindungen
```
```
Dateisicherheit, Freigabesicherheit
```
```
Registrierungsdatenbank
```
```
Ereignisprotokoll
```
```
ODBC-Einstellungen
```
```
Disk Quotas
```
```
Ausführung von CHKDSK
```
```
Distributed File System (DFS)
```
Netzwerk IP-Routing

```
Ausführung eines Ping
```

```
Netzwerkverbindungen und Sitzungen
```
```
Terminal Services
```
```
Active Directory
```
```
DNS-Server
```
```
Network Load Balancing (NLB)
```
```
Microso Exchange Server
```
```
Internet Information Server (IIS)
```
```
ASP.NET
```
```
Windows Communication Foundation (WCF)
```
```
ACHTUNG: Einige Schwierigkeiten mit WMI resultieren daraus, dass
WMI mit jeder Windows-Version (stark) erweitert wurde, die
erweiterten WMI-Klassen und -Funktionen aber nicht als Add-on für
ältere Windows-Versionen bereitgestellt werden. Viele Skripte laufen
daher nur auf den jeweils neuesten Windows-Versionen, auf älteren
Plattformen erhält man nichtssagende Fehlermeldungen wie
"Automatisierungsfehler".
```
WMI-Klassen und WMI-Objekte

WMI ist ein objektorientiertes Konzept, bei dem alle Informationen in Form
von strukturierten Objekten bereitgestellt werden, die Instanzen von Klassen
sind. Eine Klasse beschreibt eine Informationsart (z. B. Datei), ein Objekt
enthält die Informationen eines konkreten Vorkommens dieser
Informationsart (z. B. w:\daten\Computerliste.txt).


WMI-Klassen besitzen Informationen in Attributen und erlauben die
Ausführung von Aktionen durch Methoden. Klassen können von anderen
Klassen erben.

Die WMI-Klassen sind – aus Gründen der Übersichtlichkeit – in sogenannte
Namensräume gegliedert.

Durch die Installation von Zusatzdiensten (z. B. Internet Information
Services) und von Zusatzprodukten (z. B. Microso Off ice) kommen
Dutzende weiterer Klassen hinzu, da heute viele Produkte einen WMI-
Provider mitliefern.

Arten von WMI-Klassen

WMI-Klassen beginnen meistens mit der Vorsilbe "Win32" oder "CIM".
Spezielle Systemklassen beginnen mit einem doppelten Unterstrich "__".

CIM-Klassen sind eine sehr allgemeine, betriebssystemunabhängige
Beschreibung von Ressourcen. Win 32 - Klassen sind eine konkrete, in der
Windows-Umgebung implementierte Repräsentation von Ressourcen. Die
meisten Win32-Klassen sind von CIM-Klassen abgeleitet und erweitern den
Standard. Einige Ressourcen in einem Windows-System können auch direkt
durch CIM-Klassen abgebildet werden.

Es gibt drei Arten von Klassen in WMI:

```
Abstrakte Klassen, von denen es keine Instanzen geben kann und die nur
der Vererbung dienen
Statische Klassen: Instanzen dieser Klassen werden im WMI-Repository
gespeichert.
Dynamische Klassen: Instanzen dieser Klassen werden dynamisch von
einem WMI-Provider geliefert.
```

Tabelle 16.2 Beispiele für WMI-Klassen

```
WMI-Klassennamen Bedeutung
Win32_OperatingSystem Klasse für das installierte Betriebssystem
```
```
Win32_CDRomDrive CD-ROM-Laufwerk
```
```
Win32_Networkadapter Netzwerkadapter
```
```
Win32_LogicalDisk Laufwerk
```
```
Win32_VideoController Grafikkarte
```
```
CIM_DataFile Datei
```
```
CIM_Directory und
Win32_Directory
```
```
Verzeichnis/Ordner
```
```
Win32_Product Installierte Soware
```
```
Win32_Process Laufender Prozess
```
```
Win32_WordDocument Ein Dokument für Microso Word
```
```
Win32_NTLogEvent Ereignisprotokolleintrag
```
```
Win32_UserAccount Benutzerkonto (lokales Konto oder
Domänenkonto)
Win32_Share Verzeichnisfreigabe im Netzwerk
```
```
Win32_PingStatus Klasse zur Ausführung eines Pings
```
WMI definiert eine Reihe von Systemklassen, die der Verwaltung von WMI
selbst und insbesondere dem Ereignissystem dienen. Die Systemklassen sind
in jedem Provider implementiert; sie sind daran erkennbar, dass der Name
mit einem doppelten Unterstrich beginnt. Beispiele für Systemklassen zeigt
die nachstehende Tabelle.


Tabelle 16.3 Beispiele für WMI-Systemklassen

```
WMI-Klassennamen Bedeutung
```
```
__Namespace WMI-Namensraum
```
```
__Event Basisklasse für WMI-Ereignisse
```
```
__InstanceDeletionEvent Konkretes Ereignis, das ausgelöst wird, wenn
ein WMI-Objekt gelöscht wurde
```
```
__EventConsumer Konsument eines WMI-Ereignisses
```
Besondere Klassenformen

Es gibt in WMI auch Singleton-Klassen. Eine Singleton-Klasse ist in der
objektorientierten Programmierung eine Klasse, von der es nur eine Instanz
geben kann. In WMI wird eine Singleton-Klasse mit dem Qualifier Singleton =
True gekennzeichnet.

Es gibt auch abstrakte Klassen in WMI, von denen keine Instanzen erzeugt
werden können. Hierfür heißt der Qualifier abstract.

Klassenmitglieder

Wie in anderen objektorientierten Konzepten auch, bestehen WMI-Klassen
aus Attributen (Eigenschaen, Daten) und Methoden (Operationen, Aktionen,
Programmcode). WMI-Klassen besitzen jedoch keine Ereignisse. Ereignisse
sind in WMI selbst wieder Klassen.

WMI-Klassen können sogenannte statische Methoden implementieren, die
direkt auf einer Klasse ausgeführt werden können, ohne dass eine Instanz
der Klasse benötigt würde. Statische Methoden sind z. B.
Konstruktormethoden wie die Methode Create() auf der Klasse
Win32_Process.


Schlüsselattribute

Schlüsselattribute (Keys) sind besondere Attribute, die der eindeutigen
Identifizierung einer Instanz innerhalb einer Klasse dienen. Ein Key
entspricht dem Primärschlüssel einer Tabelle in einer relationalen
Datenbank. Ebenso wie ein Primärschlüssel aus mehreren Spalten einer
Datenbanktabelle bestehen kann, kann sich auch ein Key in WMI aus
mehreren Attributen zusammensetzen. Einen Schlüsselwert darf es
innerhalb aller Instanzen einer Klasse nur einmal geben. Wenn der Key aus
mehreren Attributen besteht, müssen nur alle Attributwerte zusammen
eindeutig sein. Welche Attribute Schlüsselattribute sind, wird in der
Klassendefinition festgelegt, damit alle Instanzen einer Klasse die gleichen
Schlüsselattribute besitzen.

Singleton-Klassen besitzen keine Schlüsselattribute (z. B.
/root/default:__cimomidentification und /root/cimv2:NetDiagnostics).

An Stelle eines Paars aus Schlüsselattributname und Schlüsselwert wird zur
Identifizierung des einen Objekts das Zeichen @ verwendet.

Systemattribute

Alle WMI-Klassen und damit auch alle Instanzen dieser Klassen besitzen eine
Reihe von Systemattributen. Die Namen dieser Systemattribute beginnen mit
einem doppelten Unterstrich "__".


Tabelle 16.4 WMI-Systemeigenschaen

```
Attribut Erläuterung
__Class Name der Klasse, zu der das WMI-Objekt gehört
```
```
__Derivation Eine Zeichenkettenliste, welche die
Vererbungshierarchie wiedergibt. Der erste Eintrag ist
die direkte Oberklasse.
__Dynasty Name der obersten Klasse der Vererbungshierarchie.
Bei der obersten Klasse steht hier keine leere
Zeichenkette, sondern der gleiche String wie bei
__Class.
__Genus 1 = Eintrag ist eine Klasse. 2 = Eintrag ist ein WMI-
Objekt, d. h. die Instanz einer WMI-Klasse.
__Namespace WMI-Namensraum, in dem die Klasse registriert ist
```
```
__Path Vollständiger WMI-Pfad einschließlich Server und
WMI-Namensraum
__Property_Count Anzahl der Attribute der Klasse. Dabei werden diese
Systemattribute nicht mitgezählt.
__Relpath WMI-Pfad ohne Server und WMI-Namensraum
```
```
__Server Name des Servers
```
```
__Superclass Name der direkten Oberklasse
```
Datentypen

WMI definiert sechzehn Standarddatentypen für Zahlen, Zeichenketten,
Datumsangaben, Ja/Nein und Verweise auf Objekte (siehe Tabelle).


Tabelle 16.5 CIM-Standarddatentypen

```
Datentyp Bedeutung
```
wbemCimtypeSint (^8) Ganzzahl mit Vorzeichen, 8 Bit
wbemCimtypeUint (^8) Ganzzahl ohne Vorzeichen, 8 Bit
wbemCimtypeSint (^16) Ganzzahl mit Vorzeichen, 16 Bit
wbemCimtypeUint (^16) Ganzzahl ohne Vorzeichen, 16 Bit
wbemCimtypeSint (^32) Ganzzahl mit Vorzeichen, 32 Bit
wbemCimtypeUint (^32) Ganzzahl ohne Vorzeichen, 32 Bit
wbemCimtypeSint (^64) Ganzzahl mit Vorzeichen, 64 Bit
wbemCimtypeUint (^64) Ganzzahl ohne Vorzeichen, 64 Bit
wbemCimtypeReal (^32) Zahl mit Nachkommastellen, 32 Bit
wbemCimtypeReal (^64) Zahl mit Nachkommastellen, 64 Bit
wbemCimtypeBoolean Ja/Nein
wbemCimtypeString Zeichenkette
wbemCimtypeDatetime Zeitpunkt
wbemCimtypeReference Verweis auf Objekt
wbemCimtypeChar (^16) Einzelnes Zeichen
wbemCimtypeObject Unterobjekt
Datum und Uhrzeit werden als Zeichenkette der Form yyyy
mmddHHMMSS.mmmmmmsUUU gespeichert, wobei neben dem selbst erklärenden
Kürzel anzumerken ist, dass mmmmmm die Anzahl der Millisekunden ist und UUU


die Anzahl der Minuten, um welche die lokale Zeit von der Universal
Coordinated Time (UTC) abweicht. Das s ist das Vorzeichen. In Deutschland
steht daher für UUU der Wert + 060.

WMI kennt auch ein eigenes Format für Zeitintervalle: dddddddd
HHMMSS.mmmmmm:000. Auch ein Zeitintervall wird als Zeichenkette abgelegt.
Dabei repräsentiert dddddddd die Anzahl der Tage. Die Zeichenkette endet
immer auf :000.

Metadaten mit Qualifizierer (Qualifier)

Qualifizierer (engl. Qualifier) sind Zusatzinformationen, die in WMI eine
Klasse, ein Objekt, ein Attribut, eine Methode oder einen Parameter näher
beschreiben. Qualifier dienen im derzeitigen WMI nur der
Informationsversorgung des Nutzers. Sie ermöglichen keine verbindlichen
Einstellungen für die WMI-Provider. (Beispiel: Ein Attribut, das einen Qualifier
read-only besitzt, muss nicht notwendigerweise wirklich schreibgeschützt
sein.) Durch den Qualifier Key wird festgelegt, ob ein Attribut ein
Schlüsselattribut ist.

An einem Qualifier erkennt man auch die Art einer Klasse: Die Existenz der
Qualifier abstract und dynamic weist auf die entsprechenden Typen hin. Ist
keiner dieser Qualifier vorhanden, ist die Klasse statisch. Eine
Assoziationsklasse hat einen association-Qualifier.

Weitere interessante Qualifier sind:

```
Provider zeigt für eine Klasse den Namen des WMI-Providers an, der die
Klasse bereitstellt.
EnumPrivileges legt eine Liste von Privilegien fest, die gesetzt sein
müssen, um diese Klasse zu nutzen.
Singleton kennzeichnet eine WMI-Klasse, von der es nur eine Instanz
geben kann.
```
Objektassoziationen


WMI-Objekte können durch Assoziationen miteinander verbunden sein (z. B.
ein Verzeichnis enthält eine Datei). Eine Objektassoziation ist selbst eine
Instanz einer WMI-Klasse. Ein Beispiel für eine Assoziation ist
CIM_DirectoryContainsFile. Diese Klasse stellt eine Assoziation zwischen
CIM_Directory und CIM_DataFile dar.

Bild 16.2 Assoziationshierarchie (Objektbaum) für die Instanz "C:" der Klasse Win32_LogicalDisk

Durch die Assoziationen entsteht eine Assoziationshierarchie (Objektbaum),
die man mit geeigneten WMI-Werkzeugen auch visualisieren kann.

WMI-Namensräume (Namespaces)

Ein WMI-Namensraum ist ein Instrument zur Gruppierung von WMI-Klassen
und deren Instanzen in logische Einheiten. Ein Namensraum ist der
Startpunkt sowohl für eine Vererbungshierarchie von WMI-Klassen als auch
für eine Assoziationshierarchie von WMI-Objekten. Jeder Namensraum hat
also sein eigenes Schema. Klassennamen in zwei Namensräumen dürfen
theoretisch gleich sein, sollten es aber nicht, da in zukünigen WMI-
Versionen geplant ist, namensraumübergreifende Operationen zu
ermöglichen. Es sind keine Objektassoziationen zwischen verschiedenen
Namensräumen möglich. Um gleiche Klassennamen zu vermeiden, gibt es
die Konvention, dass dem Klassennamen stets der Namensraumname


vorangestellt werden soll. Ein Namensraum ist selbst eine Klasse, die direkt
oder indirekt von der Systemklasse __Namespace geerbt hat.

Namensräume können hierarchisch angeordnet werden, so dass eine
Namensraumhierarchie entsteht. Diese Hierarchie dient aber nur der
Übersichtlichkeit; sie impliziert keine Vererbung von Klassen. Ein bestimmter
Namensraum wird über einen hierarchischen Pfad der Form
Wurzelnamensraum\Namensraum 1 \Namensraum 2 \... usw. angesprochen.

Bild 16.3 WMI-Namensräume in Windows 8 Enterprise mit Office-2016-Installation

```
HINWEIS: Namensräume sind nicht gleichzusetzen mit Providern. Ein
Provider kann mehrere Namensräume realisieren, ebenso wie ein
Namensraum Klassen aus mehreren Providern enthalten kann.
```

Lokalisierung

WMI erlaubt die Lokalisierung (d. h. landesspezifische Anpassung) von
Schemainformationen und die Speicherung mehrerer lokalisierter Versionen
eines Namensraums innerhalb des WMI-Repository. WMI speichert dazu die
sprachneutralen Teile der Klassendefinition getrennt von den
landesspezifischen Teilen. Landesspezifische Informationen sind
insbesondere die Hilfeinformationen zu den Klassen und Eigenschaen.

Die landesspezifischen Informationen werden in Unter-Namensräumen
gespeichert. Jedes Land hat eine LocaleID.

```
ms_ 407 steht für Deutsch.
ms_ 409 steht für amerikanisches Englisch.
```
Der Namensraum \root\CIMV 2 \ms_ 407 ist also der \root\CIMV 2 - Namensraum
mit deutschen Hilfeinformationen, root\CIMV 2 \ms_ 409 der gleiche mit
englischen Texten.

Beim Zugriff auf den übergeordneten Namensraum root\CIMV 2 \ ist die
Sprache abhängig von Ihren Computereinstellungen.

In einigen Werkzeugen werden diese Unter-Namensräume durch eine
Weltkugel angezeigt, in anderen Werkzeugen gibt es keinen Unterschied zu
den normalen Namensräumen.

WMI-Pfade

Sowohl einzelne WMI-Objekte als auch WMI-Klassen werden durch WMI-
Pfade adressiert. Ein WMI-Pfad ist folgendermaßen aufgebaut:

```
Aufbau eines WMI-Pfads für eine WMI-Klasse
\\Computer\Namensraum:Klasse
```
```
Aufbau eines WMI-Pfads für ein WMI-Objekt
\\Computer\Namensraum:Klasse.Schluessel='wert'
```

Dabei bedeuten die Elemente Folgendes:

```
Computer steht für den Namen des anzusprechenden Computers. Ein
Punkt in Anführungszeichen (".") steht dabei für den lokalen Computer,
auf dem das Skript läu.
Namensraum ist der Namensraum, in dem die anzusprechende Klasse
registriert wurde. Diese Angabe ist optional, wenn der
Standardnamensraum angesprochen werden soll.
Klasse ist der Name der Klasse, die angesprochen werden soll.
Mit Schluessel='wert' wird optional festgelegt, welche Instanz der
Klasse angesprochen werden soll. Dabei ist Schluessel der Name des
Schlüsselattributs der Klasse und Wert der Wert dieses
Schlüsselattributs in der gesuchten Instanz.
```
```
HINWEIS: Es gibt WMI-Klassen, die einen Schlüssel besitzen, der aus
mehreren Attributen besteht. In diesem Fall sind die
Schlüsselattribute durch ein Komma zu trennen, z. B.:
\\F 111 \root\cimv2:Win32_UserAccount.Domain="FBI",Name="hs"
```
Die folgende Tabelle zeigt Beispiele für den Zugriff auf WMI-Objekte am
Beispiel der Klassen Win32_LogicalDisk, die ein Laufwerk repräsentiert, und
Win32_UserAccount, die ein Benutzerkonto repräsentiert. Beide Klassen liegen
im Namensraum \root\cimv 2.

Wie Sie der Tabelle entnehmen können, sind viele Bestandteile der
Pfadangabe optional.


Tabelle 16.6 Beispiele für WMI-Zugriffe

```
WMI-Pfad Beschreibung
\\.\root\cimv2:Win32_LogicalDisk.DeviceID='D:' Die Instanz der Klasse
Win32_LogicalDisk aus
dem Namensraum
\root\cimv2: mit dem
Namen "D:" auf dem
lokalen Computer
\\ServerF 112 \root\cimv2: Win32_LogicalDisk.
DeviceID='D:'
Die Instanz der Klasse
Win32_LogicalDisk aus
dem Namensraum
\root\cimv2: mit dem
Namen "D:" auf dem
Computer ServerF 112
Win32_LogicalDisk. DeviceID='D:' Die Instanz der Klasse
Win32_LogicalDisk aus
dem
Standardnamensraum
mit dem Namen "D:"
auf dem lokalen
Computer
\\ServerF 112 \root\cimv2: Win32_LogicalDisk Alle Instanzen der
Klasse
Win32_LogicalDisk auf
dem Computer
ServerF 112
\\ServerF 112 \root\cimv2: Win32_UserAccount.
Domain="FBI",Name="hs"
Das Benutzerkonto
"FBI\hs" auf dem
Rechner ServerF 112
```

```
TIPP: Der sogenannte Standardnamensraum, wo die Klasse gesucht
wird, wenn kein Namensraum explizit genannt wurde, ist in der
Registrierungsdatenbank festgelegt (HKEY_LOCAL_MACH INE
\Soware\Microso\WBEM\Scripting\ Default Namespace). Die
Standardeinstellung ist \root\cimv 2 und kann über die MMC-Konsole
"WMI-Steuerung" geändert werden. Man sollte diese Einstellung aber
nicht ändern.
```
WMI-Schema

Das WMI-Schema (alias CIM-Schema) definiert die Klassen mit ihren
Attributen und Methoden, die Vererbungshierarchie und die
Objektassoziationen. Zur Laufzeit existieren von diesen Klassen Instanzen
(WMI-Objekte). Managed Objects können durch Assoziationen miteinander
verbunden sein, so dass eine Assoziationshierarchie entsteht. WMI-Klassen
erlauben Vererbung (Einfachvererbung), so dass die Klassen auch in einer
Vererbungshierarchie zueinander stehen können.

Genau genommen besitzt WMI mehrere Schemata, da jeder WMI-
Namensraum ein eigenes Schema hat. Ein WMI-Schema ist o sehr
umfangreich und enthält auch Hilfeinformationen, wahlweise in
verschiedenen Sprachen. Das Schema für Windows heißt "Win 32 Schema
Version 2" und ist eine Microso-Erweiterung des CIM-Schemas Version 2.

```
HINWEIS: Auch der Aufbau des Schemas ist Teil des Schemas. Dieser
Teil des Schemas wird als Metamodell bezeichnet.
```
WMI-Repository

Das WMI-Repository (alias CIM-Repository) ist der Datenspeicher/die
Datenbank von WMI. Im Repository werden das Schema und auch Daten


über die Instanzen gespeichert. WMI erzeugt einige Instanzen ad hoc, wenn
diese angefragt werden, weil es keinen Sinn machen würde, diese
zwischenzuspeichern (z. B. Daten über die laufenden Prozesse). Andere
Daten werden im Repository abgelegt, weil diese sich selten oder nie ändern
(z. B. Hardwaredaten).

Das WMI-Repository liegt in einem gleichnamigen Verzeichnis unterhalb von
%SystemRoot%\ System 32 \WBEM\Repository. Mit der MMC-Konsole "WMI-
Steuerung" kann man diese Datenbank sichern und wiederherstellen.

Bild 16.4 Sichern und Wiederherstellen des WMI-Repository in der Computerverwaltung von
Windows

WMI-Systemdienst

Das WMI-Repository wird durch die ausführbare Datei WinMgmt.exe
betrieben. WinMgmt.exe läu unter allen NT-basierten Windows-Systemen
als Systemdienst unter dem Namen "Win-Mgmt (Windows-
Verwaltungsinstrumentation)". Auf Windows 9 x/Windows ME wird Win-
Mgmt.exe beim ersten WMI-Aufruf als normaler Prozess gestartet, wenn ein
Aufruf erfolgt.


WMI-Netzwerkprotokoll

WMI kann Fernzugriffe auf andere Computer realisieren, wenn auf dem
anderen Computer auch WMI installiert ist, der WMI-Dienst dort läu und der
Zugang zu dem anderen Computer über DCOM-Protokoll möglich ist. Seit
Windows Server 2003 Release 2 ist alternativ auch eine Kommunikation über
HTTP/SOAP möglich. Das Protokoll nennt sich im Standard WS-Management
(WS-Man). Windows Remote Management (WinRM) ist die Microso-
Implementierung von WS-Man als Aufsatz auf WMI.

WMI 2 ist nicht mehr von dem Distributed Component Objekt Model (DCOM)
abhängig, sondern erlaubt den Fernzugriff direkt über das Webservice-
basierte Windows Remote Management (WinRM) ohne den Aufsatz WinRM.

WMI-Provider

WinMgmt.exe stellt nur das Repository bereit, nicht aber die WMI-Klassen
und WMI-Objekte. Diese sind in getrennten DLLs realisiert. WMI ist nicht in
einer einzigen DLL realisiert. Für unterschiedliche Systembausteine gibt es
unterschiedliche sogenannte WMI-Provider. Für jeden WMI-Provider existiert
eine DLL.


Tabelle 16.7 Ausgewählte WMI-Provider

```
WMI-Provider Erläuterung
```
```
Directory Services Provider Zugriff auf die ADSI-
Informationen aus
Verzeichnisdiensten
```
```
Event Log Provider Zugriff auf die Windows-
Ereignisprotokolle (nur NT-
Produktfamilie)
```
```
Exchange Queue Provider, Exchange
Routing TableProvider,
ExchangeClusterProvider
```
```
Zugriff auf Microso Exchange
Server ab Version 2000
```
```
Microso Windows Installer Provider Zugriff auf Soware, die durch
den Windows Installer (MSI)
installiert wurde
```
```
Performance Counters Provider Zugriff auf rohe
Leistungsindikatordaten
```
```
Performance Monitor Provider Zugriff auf Leistungsdaten, wie
sie der Windows-
Leistungsmonitor sieht
```
```
Power Management Event Provider Ereignisse aus dem Bereich
Power Management
```
```
Registry Event Provider Ereignisse bei Änderungen in der
Registrierungsdatenbank
```
```
Registry Provider Zugriff auf die
Registrierungsdatenbank
```
```
Security Provider Zugriff auf
Sicherheitsinformationen im
NTFS-Dateisystem
```

```
SMS Provider Zugriff auf Microso System
Management Server
```
```
SNA Provider Zugriff auf Microso SNA Server
```
```
SNMP Provider Zugriff auf SNMP-Daten
```
```
View Provider Dient der Erzeugung neuer
Klassen
```
```
Windows Installer Provider Sowareinstallation/-
deinstallation
```
```
WDM Provider Zugriff auf Gerätetreiber via
Windows Driver Model (WDM)
```
```
Win 32 Provider Zugriff auf das Win32-Subsystem
```
```
HINWEIS: Nicht alle WMI-Provider werden automatisch registriert
und im CIM Repository eingetragen. In der MSDN-
Entwicklerbibliothek finden Sie die Informationen darüber, wie die
einzelnen Provider registriert werden.
```
Managed Object Format (MOF)

Das Managed Object Format (MOF) ist eine Sprache zur Definition von
Managed Objects für WMI. MOF basiert auf der Interface Definition Language
(IDL) und ist ein Textformat. MOF-Dateien können mit Hilfe des MOF-
Compilers (mofcomp.exe) in das CIM-Repository übernommen werden.

Das nachfolgende Listing zeigt Ausschnitte aus der Datei msioff9.mof, welche
die MOF-Beschreibung für Informationen über Microso Office liefert. Die
dort definierten Klassen entsprechen den im "MSInfo" anzeigbaren Daten.
Das MOF-File definiert zunächst einen neuen Namensraum MSAPPS und


dann über eine CLSID den Provider, der die Funktionalität der im Folgenden
definierten Klassen implementiert.


Listing 16.1 Ein kleiner Ausschnitt aus dem MOF-File MSIOff9.mof

```
//**************************************************************
//* File: MSIOff9.mof – Office Extension MOF File for MSInfo 5.0
//**************************************************************
//***Creates namespace for MSAPPS
#pragma namespace ("\\\\.\\Root")
instance of __Namespace
{
Name = "MSAPPS";
};
//* Declare an instance of the __Win 32 Provider so as to "register" t
he
//* Office provider.
instance of __Win 32 Provider as $P
{
Name = "OffProv";
ClsId = "{D 2 BD7935-05FC-11D2-9059-00C 04 FD 7 A 1 BD}";
};
```
```
//* Class: Win32_WordDocument
//* Derived from:
[dynamic: ToInstance, provider("OffProv")]
class Win32_WordDocument
{
[key, read: ToInstance ToSubClass] string Name;
[read: ToInstance ToSubClass] string Path;
[read: ToInstance ToSubClass] real 32 Size;
[read: ToInstance ToSubClass] datetime CreateDate;
};
//* Class: Win32_AccessDatabase
//* Derived from:
[dynamic: ToInstance, provider("OffProv"), Singleton: DisableOverrid
e ToInstance
ToSubClass]
```

```
class Win32_AccessDatabase
{
[read: ToInstance ToSubClass] string Name;
[read: ToInstance ToSubClass] string Path;
[read: ToInstance ToSubClass] real 32 Size;
[read: ToInstance ToSubClass] datetime CreateDate;
[read: ToInstance ToSubClass] string User;
[read: ToInstance ToSubClass] string JetVersion;
};
```
```
TIPP: Einige Provider werden nicht automatisch in das WMI-
Repository eingebunden. In diesen Fällen muss man die zugehörige
MOF-Datei erst "kompilieren" mit dem Befehl:
```
```
mofcomp.exe Dateiname.mof
```
Auch Instanzen können in MOF beschrieben werden, dabei werden die
Attribute mit ihren Werten angeführt. Nachstehend sieht man die MOF-
Repräsentation einer Instanz der Klasse Win32_ComputerSystem.


instance of Win32_ComputerSystem
{
AdminPasswordStatus = 3;
AutomaticResetBootOption = TRUE;
AutomaticResetCapability = TRUE;
BootROMSupported = TRUE;
BootupState = "Normal boot";
Caption = "F108";
ChassisBootupState = 3;
CreationClassName = "Win32_ComputerSystem";
CurrentTimeZone = 120;
DaylightInEffect = TRUE;
Description = "AT/AT COMPATIBLE";
Domain = "FBI.net";
DomainRole = 1;
EnableDaylightSavingsTime = TRUE;
FrontPanelResetStatus = 3;
InfraredSupported = FALSE;
KeyboardPasswordStatus = 3;
Manufacturer = "System Manufacturer";
Model = "System Name";
Name = "BYFANG";
NetworkServerModeEnabled = TRUE;
NumberOfProcessors = 1;
OEMStringArray = {"0", "0"};
PartOfDomain = TRUE;
PauseAfterReset = "-1";
PowerOnPasswordStatus = 3;
PowerState = 0;
PowerSupplyState = 3;
PrimaryOwnerName = "www.IT-Visions.de";
ResetCapability = 1;
ResetCount = -1;
ResetLimit = -1;
Roles = {"LM_Workstation", "LM_Server", "Print", "NT", "Potentia
l_Browser"};
Status = "OK";


```
SystemStartupDelay = 30;
SystemStartupOptions = {"\"Microsoft Windows XP Professional\" /
fastdetect"};
SystemStartupSetting = 0;
SystemType = "X86-based PC";
ThermalState = 3;
TotalPhysicalMemory = "536309760";
UserName = "FBI\\hs";
WakeUpType = 6;
};
```
WMI-Sicherheit

WMI basiert auf COM und verwendet die COM-Sicherheitsfunktionen und die
entsprechend verfügbaren Security Provider. Sicherheitseinstellungen
können auf der Ebene eines jeden WMI-Namensraums festgelegt werden.
Diese Einstellung erfolgt im WMI-Snap-In in der MMC. Ein COM-Client, der auf
ein WMI-Objekt zugreifen will, wird zunächst gegen die
Sicherheitseinstellung des Namensraums geprü, zu dem das Objekt gehört.
Die Vergabe von Zugriffsrechten auf Objekt- oder Klassenebene unterstützt
WMI bislang nicht.


Bild 16.5 Einstellen der Zugriffsberechtigungen in der MMC "WMI-Steuerung"

WMI unterstützt Impersonifizierung für den Zugriff auf entfernte Rechner. Es
ist also möglich, beim Aufruf von WMI-Objekten auf einem entfernten
Rechnersystem den Benutzerkontext zu wechseln und als ein anderer
Benutzer aufzutreten als der, unter dem der COM-Client läu. Dies ist
allerdings beim Zugriff auf das lokale WMI nicht möglich. Ein Versuch, den
Benutzerkontext vor dem Zugriff auf lokale WMI-Objekte zu wechseln, wird
von WMI mit dem Fehler 80041064 quittiert:
"Benutzeranmeldeinformationen können für lokale Verbindungen nicht
verwendet werden."

Im Gegensatz zu anderen Komponenten erlaubt WMI Vorgaben für die COM-
Sicherheit durch den Client. Sowohl Impersonifizierungs- als auch
Authentifizierungsmodus können beim Verbindungsaufbau eingestellt
werden. Der Client kann ab Windows 2000 auch den Security Service
Provider (SSPI) zwischen der NT-4.0-LAN-Manager-(NTLM-) und der
Kerberos-Authentifizierung wählen. Wird kein SSPI explizit angegeben,
verhandelt WMI den SSPI beim Verbindungsaufbau. Es wird zunächst


versucht, Kerberos zu verwenden. Kerberos kann allerdings nie für lokale
Aufrufe verwendet werden.

Privilegien sind Zusatzrechte, die bei Nutzung einiger WMI-Klassen benötigt
werden und bei der Instanziierung gesetzt werden müssen. Ohne diese
Zusatzangaben ist die Klasse nicht nutzbar. Die Zusatzangaben werden
entweder im WMI-Pfad gesetzt oder über das Objektmodell, mit dem man
auf WMI zugrei.

WMI-Ereignissystem

WMI bietet ein komplexes System für Ereignisse, durch die sich ein WMI-
Nutzer über Veränderungen in einem beliebigen Managed Object informieren
lassen kann.

Es gibt zwei Gruppen von Ereignissen:

```
Intrinsic Events sind Ereignisse, die direkt Klassen oder Objekte im WMI-
Repository verändern oder betreffen, z. B. das Löschen einer Instanz
(__InstanceDeletionEvent), das Verändern einer Instanz
(__InstanceModificationEvent) oder der Aufruf einer Methode
(__MethodInvocationEvent). Zu den Intrinsic Events gehören auch
Zeitgeberereignisse (Timer Events), z. B. __AbsoluteTimerInstruction
und __IntervallTimerInstruction. Der Name dieser Ereignisse beginnt
mit einem doppelten Unterstrich. Alle Klassen sind direkt oder indirekt
abgeleitet von __Event.
Extrinsic Events sind speziellere Ereignisse, die von irgendeinem Teil
des Systems ausgelöst werden, aber nicht direkt auf das CIM-Repository
wirken müssen, z. B. Ändern eines Schlüssels in der
Registrierungsdatenbank (RegistryValueChangeEvent), Ändern der
Systemkonfiguration (Win32_SystemConfigurationChangeEvent) und
Herunterfahren des Computers (Win32_ComputerShutdownEvent). Alle
diese Klassen sind abgeleitet von __ ExtrinsicEvent.
```
WMI-Ereignisse werden ausgelöst von Ereignisprovidern (Event Provider), die
im WMI-Repository einmalig registriert werden müssen.


WMI-Ereigniskonsumenten

WMI-Ereignisse werden behandelt von Ereigniskonsumenten (Event
Consumers). Ereigniskonsumenten registrieren sich bei WMI für bestimmte
Ereignisse. Der Ereigniskonsument führt beim Eintritt eines Ereignisses eine
bestimmte Aktion aus.

WMI unterscheidet zwei Arten von Ereigniskonsumenten: temporäre Event
Consumer und permanente Event Consumer. Der Unterschied zwischen den
beiden Typen ist, dass ein temporärer Event Consumer nur
Ereignisbenachrichtigungen erhält, wenn er aktiv ist. Ein temporärer Event
Consumer wird durch ein Skript oder ein Programm implementiert. Nach
Beendigung des Skripts/Programms ist der Konsument nicht mehr
vorhanden. Dagegen ist ein permanenter Konsument in Form eines Managed
Objects im Repository gespeichert und kann zu jedem Zeitpunkt
Ereignisbenachrichtigungen empfangen, da WMI den Consumer bei Bedarf
selbst startet und dann das Ereignis übermittelt.


Bild 16.6 Überblick über die Ereigniskonsumenten

Permanente Ereigniskonsumenten sind z. B.:

```
Der EventViewerConsumer (im Namensraum /root/cimv 2 ), der die
aufgetretenen Ereignisse in einem Bildschirmfenster, dem WMI Event
Viewer, darstellt. Der Event Viewer wird im Abschnitt "WMI-Werkzeuge "
vorgestellt.
Der ActiveScriptEventConsumer (im Namensraum /root/default), der bei
Aureten eines Ereignisses ein Active Script ausführt
Mit Hilfe des SMTPEventConsumer können bei Ereignissen E-Mails über den
Microso SMTP-Server (der Bestandteil des Internet Information Server
ab Version 4.0 ist) versendet werden. Der SMTPEventConsumer ist
standardmäßig nicht registriert. Um ihn benutzen zu können, muss die
```

```
Datei smtpcons.mof, die sich im Verzeichnis %System-
Root%\Winnt\wbem befindet, mit Hilfe des MOF-Compilers
(mofcomp.exe) kompiliert und ins WMI-Repository aufgenommen
werden. Der Provider wird im Namensraum root\default registriert.
```
Seit Windows XP gibt es drei weitere permanente Ereigniskonsumenten:

```
Command Line Event Consumer: Start einer Anwendung
NT Event Log Event Consumer: Eintrag in das NT-Ereignisprotokoll
Log File Event Consumer: Eintrag in eine Protokolldatei
```
Der Ereigniskonsument definiert sein Interesse gegenüber WMI in Form eines
WMI-Filters. Ein WMI-Filter ist im Wesentlichen eine WQL Event Query (vgl.
Unterkapitel zu WQL-Abfragen).

Ein Ereigniskonsument ist eine Instanz einer von der Systemklasse
__EventConsumer erbenden Klasse. Ein WMI-Filter ist eine Instanz der
Systemklasse __EventFilter. Die Bindung zwischen einem Consumer und
einem Filter ist als Instanz von __FilterToConsumerBinding gespeichert.

Es gibt zwei Möglichkeiten, Ereigniskonsument und Filter zu definieren und
aneinander zu binden:

```
Über das Werkzeug WMI Event Registration aus den WMI Administrative
Tools (früher unter http://www.microso.com/en-us/download/details.aspx?
id= 24045 , hat Microso diese mittlerweile nicht mehr im Angebot. Sie
finden das Setup der Werkzeuge in den Downloads zu diesem Buch)
Über Programmcode. Dadurch, dass Consumer, Filter und Bindungen
selbst wieder als WMI-Objekte gespeichert werden, können diese leicht
auch per WMI automatisiert verwaltet werden.
```
Kern des Ereignissystems ist der Event Provider. Er informiert WMI über
Veränderungen in der Managementumgebung oder im Repository. WMI leitet
die Ereignisse an die für dieses Ereignis registrierten Konsumenten weiter.

WMI Query Language (WQL)

WMI erlaubt Suchanfragen in einer Syntax, die auf der ANSI Standard
Structured Query Language (SQL) basiert. Der SQL-Dialekt ist bei der DMTF


als "CIM Query Language" (CQL) standardisiert. Die etwas abgewandelte
Implementierung von Microso heißt WMI Query Language kurz: WQL.

Bei CQL/WQL wird nur Lesezugriff mit dem SQL-Befehl SELECT unterstützt.
Weder DDL (Data Definition Language) noch DML (Data Manipulation
Language) werden unterstützt.

Das WQL-SELECT unterstützt neben den Standardschlüsselwörtern FROM,
WHERE, GROUP BY, HAVING und WITHIN auch die nicht in ADSI-SQL definierten
Schlüsselwörter ASSOCIATORS OF und REFERENCES OF.

Unterstützte Operatoren sind =, <, >, <=, >=, != (alternativ: <>) sowie IS NULL,
IS NOT NULL und ISA. Der ISA-Operator ermöglicht die Abfrage nach
Unterklassen einer bestimmten Klasse. Wenn Großstadt eine Unterklasse von
Stadt ist, dann erfüllt ein Objekt München vom Typ Großstadt auch die
Bedingung ISA Stadt. Der like-Operator für den Zeichenketten-
Mustervergleich wird erst ab Windows XP unterstützt.

Typen von WQL-Anfragen

WMI unterstützt drei Typen von WQL-Anfragen:

```
Anfragen nach Instanzen (Data Queries)
Anfragen nach Schemainformationen (Schema Queries)
Definitionen von Ereignisfiltern (Event Queries), die nach Änderungen
von Klassen und Instanzen fragen
```
Datenabfragen (Data Queries)

Eine Datenabfrage hat die allgemeine Form:

```
SELECT attributliste FROM class WHERE bedingung
```
Dabei ist Class ein beliebiger WMI-Klassenname. Die Ergebnismenge lässt
sich durch die Angabe von Attributnamen und die Verwendung einer FROM-


Klausel hinsichtlich der Breite und Länge einschränken. Andere
Schlüsselwörter werden nicht unterstützt.

Beispiele für Datenabfragen zeigt die folgende Tabelle.

Tabelle 16.8 Beispiele für WQL-Datenabfragen

```
WQL Erläuterung
SELECT * FROM Win32_Service WHERE
state='running' and
startmode='manual'
```
```
Alle Windows-Dienste, die laufen,
aber manuell gestartet wurden
```
```
SELECT Name, CategoryId FROM
Win32_ComponentCategory Name und CATID allerKomponentenkategorien
```
```
SELECT IPAddress FROM
Win32_NetworkAdapterConfiguration
WHERE IPEnabled=TRUE
```
```
Das mehrwertige Attribut IPAddress
einer Netzwerkkarte, die für das IP-
Protokoll zugelassen ist
SELECT RecordNumber, Message FROM
Win32_NTLogEvent WHERE
Logfile='Application'
```
```
Eintragsnummer und Nachricht
aller Einträge in das
Ereignisprotokoll "Anwendung"
```
Schemaabfragen (Schema Queries)

Anfragen zum Schema haben die Form:

```
SELECT attributliste FROM META_CLASS WHERE bedingung
```
wobei META_CLASS hier ein feststehender Ausdruck ist. Andere
Schlüsselwörter werden nicht unterstützt. Mit der WHERE-Klausel werden das
zu beobachtende Managed Object (MO) und die in ihm zu beobachtenden
Attribute definiert. Schemaabfragen können mit WMI_ PrintQuery(WQL)
ausgegeben werden.


Tabelle 16.9 Beispiele für Schemaabfragen

```
WQL Erläuterung
SELECT * FROM meta_class WHERE
__Class = "Win32_LogicalDisk"
Zugriff auf die WMI-Klasse Win32_
LogicalDisk
SELECT * FROM meta_class WHERE
__this ISA "Win32_LogicalDisk" ZugriWin32_ff auf alle vonLogicalDisk abgeleiteten
Klassen
```
Ereignisabfragen (Event Queries)

Eine Ereignisabfrage bezieht sich immer auf eine Ereignisklasse.

Mit der WHERE-Klausel werden die zu suchenden Klassen entweder direkt über
ihren Namen (__Class =) oder über den Namen einer Oberklasse (__this
ISA) festgelegt.

```
SELECT * FROM eventklasse WHERE bedingung
```
Alle Ereignisklassen sind Unterklassen eines Ereignistyps. Die Ereignistypen
wiederum sind Unterklassen der Klasse __Event. Sie sind in der Regel an dem
führenden doppelten Unterstrich und der Endung auf Event erkennbar. WMI
unterscheidet vier Typen von Ereignissen (siehe Tabelle).


Tabelle 16.10 WMI-Ereignisklassen. Die Ereignistypen sind die Oberklassen zu den rechts genannten
Ereignisklassen.

```
Ereignistyp (Oberklasse) Ereignisklasse
__ClassOperationEvent __ClassCreationEvent
__ClassDeletionEvent
__ClassModificationEvent
__ExtrinsicEvent __SystemEvent
RegistryValueChangeEvent
Win32_ComputerShutdownEvent
Win32_ProcessStartTrace
Win32_SystemConfigurationChangeEvent
Win32_PowerManagementEvent
u. a.
__InstanceOperationEvent __InstanceCreationEvent
__InstanceDeletionEvent
__InstanceModificationEvent
__NamespaceOperationEvent __NamespaceCreationEvent
__NamespaceDeletionEvent
__NamespaceModificationEvent
```
```
HINWEIS: Bitte beachten Sie, dass das Ereignis
__InstanceModificationEvent wirklich nur ausgeführt wird, wenn sich
ein Attributwert ändert. Wenn Sie beispielsweise die Prozessorlast
auf die Überschreitung der 80 %-Grenze prüfen, dann bekommen Sie
ein Ereignis beim Überschreiten der Grenze. Wenn danach der Wert
konstant bei 100 % liegt, bekommen Sie keine weiteren Ereignisse.
Sie erhalten erst wieder ein Ereignis, wenn der Wert sich nochmals
ändert (z. B. von 100 % auf 99 %).
```
Ereignisabfragen unterstützen als zusätzliche SQL-Schlüsselwörter WITHIN,
GROUP BY und HAVING:

```
Dabei gibt WITHIN 10 das Abfrageintervall in Sekunden an (wird immer
gebraucht, wenn es keinen speziellen Ereignissender gibt!).
```

```
GROUP BY bündelt eine Anzahl von Einzelereignissen zu einem
Gesamtereignis.
HAVING dient der Definition einer Bedingung innerhalb der Gruppierung.
```
Tabelle 16.11 Beispiele für Ereignisabfragen

```
WQL Erläuterung
SELECT * FROM __
InstanceModificationEvent WITHIN 5 WHERE
TargetInstance ISA "Win32_Service" AND
Target Instance. State="Stopped"
```
```
Alle fünf Sekunden wird
geprü, ob ein Dienst den
Status Stopped
bekommen hat.
SELECT * FROM EmailEvent GROUP WITHIN 600
HAVING NumberOfEvents > 5
Wenn innerhalb von zehn
Minuten mehr als fünf
EMail-Ereignisse aureten,
wird dieses Ereignis
ausgelöst.
SELECT * FROM __InstanceCreationEvent
WHERE TargetInstance ISA "Win32_
NTLogEvent" AND TargetInstance.
Logfile="Application" OR TargetInstance.
Logfile="System"
```
```
Jeder neue Eintrag in den
Ereignisprotokollen
System und Application
löst ein Ereignis aus.
```
WMI-Werkzeuge

WMI kann man z. B. mit folgenden Werkzeugen verwenden:

```
MMC-Konsole für WMI
WMIC-Kommandozeilenwerkzeug (wmic.exe)
Die kostenlosen Werkzeuge im Rahmen der WMI Administrative Tools
(früher unter [www.microso.com/en-us/download/details.aspx?
id=24045], hat Microso diese mittlerweile nicht mehr im Download-
Angebot. Sie finden das Setup der Werkzeuge daher in den Downloads
zu diesem Buch)
```

```
PowerShell über Commandlets wie Get-CimInstance und Get-WmiObject
und die eingebauten PowerShell-Typen [WMI], [WMIClass] und
[WMISEARCHER]. In PowerShell Core ist ein Teil dieser Funktionen
verfügbar.
Systemmanagementwerkzeuge wie Microso System Center, Tivoli oder
HP OpenView
```
Die MMC-Konsole für WMI (z. B. enthalten in der "Computerverwaltung")
dient nicht dem Zugang zu WMI-Informationen, sondern nur der
Sicherheitskonfiguration (wer hat Zugang zu den Informationen?) sowie der
Sicherung und Wiederherstellung des WMI-Repository.

```
HINWEIS: Daran, dass es in Windows kein mitgeliefertes grafisches
Werkzeug für den Zugang zu den eigentlichen Daten in WMI gibt, sieht
man schon, dass WMI als Plattform für Scripting und nicht für die GUI-
basierte Administration betrachtet wird.
```

Bild 16.7 WMI-Steuerung in der MMC "Computerverwaltung"

WMI Object Browser

Der WMI Object Browser ist eines der Werkzeuge in den WMI Administrative
Tools. Er ermöglicht es, die auf dem lokalen oder einem entfernten System
vorhandenen WMI-Objekte zu betrachten und entlang der Hierarchie der
Objekte das System zu erforschen, mit dem Ziel, Objekte und Attribute zu
finden, welche die gewünschten Systeminformationen enthalten. An vielen
Stellen können WMI-Objekte auch verändert werden (z. B. Name eines
Laufwerks ändern) oder es ist möglich, Aktionen auf den Objekten zu
initiieren (z. B. Festplatte prüfen).


```
ACHTUNG: Das Werkzeug WMI Object Browser läu als ActiveX-
Komponente innerhalb des Internet Explorers. Sie müssen ActiveX
zulassen, um das Werkzeug nutzen zu können. Eine deutsche Version
ist nicht verfügbar. Da die Hilfetexte zu den WMI-Klassen aber im WMI-
Repository stehen, sind zumindest davon viele in Deutsch verfügbar.
```
Bild 16.8 Der WMI Object Browser zeigt an, dass der Computer drei Laufwerke besitzt. Die Details zu
Laufwerk "C" werden hier dargestellt.

Weitere Werkzeuge

Weitere Werkzeuge in den WMI Administrative Tools sind:


```
Das WMI CIM Studio setzt im Gegensatz zum WMI Object Browser auf der
Klassenebene an und stellt die Vererbungshierarchie der CIM-Klassen
dar. Diese wird in der linken Fensterhäle, dem Class Explorer, gezeigt.
Die rechte Fensterhäle (genannt Class Viewer) ähnelt der Ansicht des
WMI Object Browsers: Hier werden die Attribute, Methoden und
Beziehungen angezeigt.
Das WMI Event Registration Tool ist ein GUI zur Konfiguration von
Ereigniskonsumenten.
Der WMI Event Viewer ist das einzige unter den WMI Administrative Tools,
das keine HTML-Anwendung, sondern eine ausführbare Datei
(wbemeventviewer.exe) ist. Der Event Viewer ist ein permanenter WMI-
Ereigniskonsument, der durch eine __EventFilter-Instanz definierte
Ereignisse auf dem Bildschirm darstellt. Der Event Viewer wird über die
WMI-Klasse Event ViewerConsumer konfiguriert. Diese Konfiguration
können Sie über das WMI Event Registration Tool oder über den Event
Viewer selbst durchführen.
```
WMI-Programmierschnittstellen

Microso stellt für WMI vier Programmierschnittstellen bereit:

```
Die COM-basierte Sowarekomponente SWbemDisp.dll mit dem WMI-
COM-Objektmodell, in dessen Zentrum die Klasse
WbemScripting.SWbemObject steht. Fernzugriff ist über DCOM möglich.
Die COM-basierte Sowarekomponente WsmAuto.dll, die einen
Fernzugriff über WS-Management (HTTP und SOAP) ermöglicht
Die ältere .NET-basierte Sowarekomponente System.Management.dll
(alias "WMI API") mit einem Objektmodell, in dessen Zentrum die
Klassen System.Management.ManagementObject und
System.Management.ManagementClass stehen.
Die neuere .NET-basierte Sowarekomponente
System.Management.Infrastructure.dll (alias "Management
Infrastructure API") mit einem Objektmodell, in dessen Zentrum die
```

```
Klassen System.Management.CimInstance und
System.Management.CimClass stehen.
```
```
HINWEIS: Alle oben genannten Komponenten sind
Metaobjektmodelle, d. h., es gibt dort nicht für jede der unzähligen
WMI-Klassen eine Entsprechung, sondern es gibt einige wenige
Klassen, deren Instanzen durch Angabe von WMI-Pfaden auf die
eigentlichen WMI-Objekte abgebildet werden.
```
WMI API in der System.Management.dll

Dieses API ist die erste Generation des WMI API, die es seit der ersten WMI-
Version in Windows 98 gibt. Diese alte WMI API wird heute in Windows immer
noch unterstützt. Während es in der Windows PowerShell auch
Commandlets für dieses alte WMI API gibt, wird es in PowerShell 6/7 nicht
mehr unterstützt.

Zentrale Klassen des Objektmodells (siehe folgende Grafik) von
System.Management sind:

```
ManagementObject
Diese Klasse repräsentiert ein WMI-Objekt.
ManagementClass
Diese Klasse repräsentiert eine WMI-Klasse. ManagementClass ist von
ManagementObject abgeleitet.
ManagementBaseObject
Beide Klassen sind von ManagementBaseObject abgeleitet. Diese Klasse ist
nicht abstrakt, sondern wird an verschiedenen Stellen im Objektmodell
auch verwendet.
```

Bild 16.9 Objektmodell von System.Management

Bei System.Management.dll dient die Klasse ManagementObject als Metaklasse
für alle WMI-Klassen, d. h., eine Instanz von ManagementObject wird bei seiner
Erzeugung durch Verwendung eines WMI-Pfads an ein WMI-Objekt gebunden
und bildet dieses ab. Leider ist die Abbildung nicht so leicht zu verwenden,
wie man es sich wünschen würde, denn man muss alle Attribute über die
PropertyDataCollection ansteuern (siehe obige Abbildung des
Objektmodells) und die Methodenaufrufe umständlich durch InvokeMethod()
ausführen.

```
HINWEIS: Im Folgenden werden Sie sehen, dass die PowerShell den
Zugriff auf dieses komplexe Objektmodell stark vereinfacht.
```
Management Infrastructure API in der

System.Management.Infrastructure.dll


Dieses API ist die zweite Generation des WMI API. Sie wurde zusammen mit
WMI 2 in Windows 7 bzw. Windows Server 2008 eingeführt. Dieses API kann
man in Windows PowerShell und PowerShell 6/7 (auf Windows) verwenden.

Zentrale Klassen des Objektmodells von System.Management.Infrastructure
sind:

```
CimInstance
Diese Klasse repräsentiert ein WMI-Objekt.
CimClass
Diese Klasse repräsentiert eine WMI-Klasse.
```
Weitere Neuerungen in WMI Version 2

Neben dem Verzicht auf DCOM scha Microso in WMI 2 die Möglichkeit, aus
den vielen Tausend WMI-Klassen direkt PowerShell-Commandlets zu
generieren. So erklärt sich auch die plötzliche Flut von administrativen
Commandlets seit Windows Client Version 8 und Windows Server Version
2012.

Microso geht mit WMI 2 und PowerShell so weit, dass einige Bereiche des
Betriebssystems, z. B. das Server Message Block (SMB)-Protokoll 2.2, das
Microso seit Windows 8 ausliefert, zukünig nur noch über WMI und die
PowerShell verwaltbar sind (siehe Bild). Das bisherige Network Share
Management API [http://msdn.microso.com/en-
us/library/bb 525393 (VS.85).aspx] für Entwickler und das Werkzeug net.exe für
Administratoren werden nicht verschwinden, aber auf dem bisherigen Stand
verharren. WMI-2-Provider kann man künig auch mit der PowerShell
schreiben.


Bild 16.10 Verwaltung von Windows File Servern über WMI, WinRM und PowerShell (Quelle früher,
mittlerweile aus dem Netz gelöscht:
[http://www.snia.org/sites/default/files2/SDC2011/presentations/wednesday/JoseBarreto_WindowsServer_](http://www.snia.org/sites/default/files2/SDC2011/presentations/wednesday/JoseBarreto_WindowsServer_)
8_SMB2_Management_v3.pdf)

16.2 WMI in der PowerShell

Die PowerShell bietet die Möglichkeit zum Zugriff auf das lokale WMI-
Repository und auch WMI-Repositories auf entfernten Systemen.

Dafür bietet die PowerShell folgende Konzepte:

```
Die Commandlets Get-WmiObject (seit PowerShell 1.0), Remove-WmiObject,
Set-Wmi Instance und Invoke-WmiMethod (seit PowerShell 2.0). Die als die
"WMI-Commandlets der ersten Generation" bezeichneten Commandlets
gibt es aber nicht in den Core-Versionen der PowerShell!
Seit PowerShell-Version 3.0 gibt es eine neue Generation von WMI-
Befehlen, die nun alle das Wort "Cim" im Namen tragen, u. a. Get-
CimAssociatedInstance, Get-CimClass, Get-CimInstance, Invoke-
CimMethod, New-CimInstance, Register-CimIndicationEvent, Set-
CimInstance und Remove-CimInstance. Diese Commandlets gibt es auch
in Windows PowerShell Core 5.1 und PowerShell Core 6/7 unter
Windows, aber nicht unter macOS und Linux.
```

```
Die eingebauten PowerShell-Typen [WMI], [WMIClass] und [WMISEARCHER].
Diese gibt es nicht in den Core-Versionen der PowerShell!
Den PowerShell-WMI-Objektadapter, der den Zugriff auf WMI-Objekte
vereinfacht.
```
Diese Konzepte werden in den folgenden Abschnitten aufgabenorientiert
erläutert.

Den Unterschied zwischen den alten und neuen WMI-Commandlets zeigt die
folgende Tabelle.

Tabelle 16.12 Alte versus neue WMI-Commandlets



```
TIPP: Der wesentliche Vorteil der neueren Commandlets gegenüber
den älteren (z. B. Get-CimInstance im Vergleich zu Get-WmiObject) ist,
dass die PowerShell-Konsole und die ISE Eingabeunterstützung für
die WMI-Klassennamen gewähren. Allerdings bezieht sich die
Vorschlagsliste immer auf die auf dem lokalen System vorhandenen
WMI-Klassen. Auf einem eventuell angesprochenen entfernten
System zusätzliche Klassen sieht man nicht. Zudem kann es sein,
dass die vorgeschlagene WMI-Klasse auf dem entfernten System nicht
existiert.
```
```
Bild 16.11 Vorschlagsliste bei Get-CimInstance
```
16.3 Open Management Infrastructure

(OMI)

Um Windows für andere Betriebssysteme weiter zu öffnen, entwickelt
Microso unter dem Namen Open Management Infrastructure (OMI), alias
"NanoWBEM", auch eine WBEM-Implementierung für andere
Betriebssysteme, die laut Aussage von PowerShell-Chefarchitekt Jeffrey
Snoover [http://channel9.msdn.com/Events/BUILD/BUILD2011/SAC-644T?
format=auto] um den Faktor 76 schneller sein soll als die DMTF-
Referenzimplementierung "OpenPegasus" [www.openpegasus.org/]. Zudem
soll NanoWBEM auch auf Smartphones laufen, um diese Geräte ebenfalls
überwachbar zu machen.


Die Website des Projekts ist https://collaboration.opengroup.org/omi/?
gpid= 680.

16.4 Abruf von WMI-Objektmengen

Die Verwendung von Get-CimInstance oder Get-WmiObject in Verbindung mit
einem WMI-Klassennamen in der Form

```
Get-CimInstance WMIKlassenname
```
liefert alle Instanzen der angegebenen WMI-Klasse (sofern es die
angesprochene WMI-Klasse auf dem lokalen System gibt).

Beispiel:

```
# Name und Treiberdatei für alle Grafikkarten in diesem Computer
Get-CimInstance Win32_VideoController
```
liefert alle installierten Grafikkarten.

Dies ist eine Kurzform für

```
Get-CimInstance -ClassName Win32_VideoController
```
Sofern die Klasse nicht im Standardnamensraum "root\cimv2" liegt, muss
man den Namensraum mit dem Parameter –Namespace explizit benennen:

```
Get-CimInstance -Namespace root/WebAdministration -ClassName Site
```
```
TIPP: Mit folgendem Befehl fragen Sie die Versionsnummer des WMI-
Repository ab:
Get-CimInstance __cimomidentification -Namespace root/default
```

16.5 Fernzugriffe

Man kann sowohl bei Get-CimInstance als auch Get-WmiObject mit dem
Parameter -Computer auf entfernte Systeme zugreifen:

```
Get-CimInstance -class Win32_VideoController -Computer ServerF 112
```
Allerdings ist zu beachten, dass Get-CimInstance dafür im Standard immer
per SOAP-Webservice (WS-Management-Protokoll) redet. Wenn das entfernte
System ein älteres System ohne WS-Management ist, dann muss man über
eine explizite CIM-Sitzung die Kommunikation auf DCOM umschalten. Dafür
verwendet man die Commandlets New-CimSessionOption und New-CimSession.

```
Listing 16.2 [WP3_CIMSession.ps1]
$so = New-CimSessionOption -Protocol DCOM
$s = New-CimSession -ComputerName ServerF 112 - SessionOption $so
Get-CimClass -cimsession $s -class Win32_VideoController
```
```
HINWEIS: Get-WmiObject verwendet immer DCOM, so dass dieses
Commandlet in Szenarien mit älteren Betriebssystemen einfacher in
der Verwendung ist.
```
16.6 Filtern und Abfragen

Wenn man nicht alle Instanzen, sondern nur ausgewählte Instanzen
ermitteln möchte, die bestimmten Kriterien entsprechen, kann man eine der
folgenden alternativen Möglichkeiten nutzen:

```
Verwendung des Commandlets Get-CimInstance oder Get-Wmiobject mit
einem Filter
Verwendung von WQL-Abfragen mit dem Parameter -Query in den
Commandlets Get-CimInstance oder Get-WmiObject
```

```
Auf einzelne, per WMI-Pfad identifizierte WMI-Objekte oder WMI-Klassen
kann man zudem durch Verwendung der eingebauten PowerShell-
Typen [WMI] und [WMIClass] zugreifen.
Direkte Instanziierung der Klassen System. Management.ManagementObject
bzw. System. Management.ManagementClass jeweils unter Angabe eines
WMI-Pfads im Konstruktor
Verwendung von WQL-Abfragen mit dem Typ [WMISEARCHER]
Verwendung von WQL-Abfragen mit der .NET-Klasse
System.Management.Management ObjectSearcher
```
Filtern mit Get-WmiObject

Die Commandlets Get-CimInstance und Get-Wmiobject bieten die Möglichkeit,
schon beim Abruf die Objekte zu filtern. Der Filter ist nach dem Parameter
Filter in einer Zeichenkette anzugeben.

Beispiele:

```
Alle Benutzerkonten aus der Domäne "FBI":
Get-CimInstance Win32_account -filter "domain='FBI'"
```
```
Alle Benutzerkonten aus der Domäne "FBI", deren Benutzerkontenname
mit "H" beginnt:
Get-CimInstance Win32_account -filter "domain='FBI' and name like
'h%'"
```
HINWEIS: Wichtig ist, dass bei WMI-Filtern die Operatoren wie bei SQL (z. B.
=, <>, <, >, like, and, or) anzugeben sind und nicht wie bei PowerShell-
Ausdrücken (z. B. - eq, - ne, - lt, - gt, - like, - and, - or).

Zugriff auf einzelne WMI-Objekte


Um auf ein bestimmtes WMI-Objekt gezielt zuzugreifen, zeigt die
nachstehende Tabelle verschiedene Möglichkeiten.

Tabelle 16.13 Beispiele für den Zugriff auf einzelne WMI-Objekte


```
TIPP: Klassen, von denen es sowieso nur immer eine Instanz geben
kann, lassen sich ohne Filter aufrufen:
```
```
Get-CimInstance Win32_ComputerSystem
Get-CimInstance Win32_OperatingSystem
Get-CimInstance __cimomidentification -Namespace root/default
```
```
Bild 16.12 Win32_Computersystem und Win32_OperatingSystem gibt es sowieso immer
nur einmal im WMI-Repository.
```
WQL-Abfragen

Abfragen in der Windows Management Instrumentation Query Language
(WQL) kann man in der PowerShell mit dem Parameter -Query in den
Commands Get-CimInstance und Get-WmiObject oder mit dem eingebauten
Typ [WMISEARCHER] ausführen.

Der folgende Befehl selektiert alle Netzwerkkarten, in denen die Zahl "802"
im Netzwerkkartentyp vorkommt.


```
Get-CimInstance -query "Select * from Win32_Networkadapter where ada
ptertype like
'% 802 %'" | select adaptertype,description
```
Alternativ kann man auch diese Abfrage mit dem eingebauten PowerShell-
Typ [WMISEAR-CHER] ausführen:

```
([WMISEARCHER] "Select * from Win32_Networkadapter where adaptertype
like '% 802 %'").
get()| select adaptertype,description
```
Bild 16.13 Ausführung einer WQL-Abfrage

```
HINWEIS: Get-CimInstance erlaubt es, mit dem Parameter -
QueryDialect alternativ zu WQL auch Abfragen in CQL zu senden.
Allerdings macht das nur Sinn bei der Abfrage von Nicht-Windows-
Systemen. Auch aktuelle Windows-Systeme wie Windows 10/11 und
Windows Server 2019/2022 antworten mit "not implemented" auf das
Senden einer CQL-Abfrage.
```

Bild 16.14 Objektmodell für Suchfunktionen über [WMISearcher] bzw. System.Management.
ManagementObjectSearcher

16.7 Liste aller WMI-Klassen

Eine Liste aller verfügbaren WMI-Klassen auf einem System erhält man mit
Get-CimClass. Dabei sind Platzhalter möglich, z. B.

```
Get-CimClass *disk*
```
Alternativ bekommt man eine Liste von Get-WmiObject mit dem Parameter -
List. Ein Filter darf dabei nicht angegeben werden.


```
Get-Wmiobject -list
```
Wenn nichts angegeben wird, wird immer der Namensraum "root\cimv2"
verwendet. Ein Namensraum lässt sich auch explizit angeben:

```
Get-CimClass *ftp* - Namespace root/WebAdministration
```
Man kann ebenso auf das WMI-Repository eines bestimmten entfernten
Computers zugreifen, da die Menge der Klassen vom Betriebssystem und von
den installierten Anwendungen abhängig ist.

```
Get-Wmiobject -list -Computer F 171
```
bzw.

```
Get-CimClass *ftp* - Namespace root/WebAdministration -ComputerName F
171
```
16.8 Hintergrundwissen: WMI-

```
Klassenprojektion mit dem
PowerShell-WMI-Objektadapter
```
Auf den ersten Blick erscheinen die von den WMI-Commandlets gelieferten
Objekte ganz normale .NET-Objekte zu sein. Aber "unter der Haube" tut sich
hier einiges, denn es gibt gar nicht eine .NET-Klasse für jede WMI-Klasse.
Vielmehr werden die vielen WMI-Klassen in sehr wenige .NET-Metaklassen
mit Hilfe eines sogenannten PowerShell-Objektadapters projiziert.


```
HINWEIS: Auf die Frage, wozu man als fortgeschrittener PowerShell-
Nutzer diesen Mechanismus überhaupt kennen muss und wissen
muss, was im Hintergrund passiert, gibt es drei Antworten:
Damit Sie in der Lage sind, Codebeispiele, die mit dem WSH oder
.NET arbeiten, auf die PowerShell zu übertragen
Damit Sie verstehen, in welcher Dokumentation Sie suchen
müssen
Damit Sie auch verstehen, woran es liegen könnte, wenn etwas
nicht funktioniert
WMI ist nicht die einzige Komponente, für welche die PowerShell
einen solchen PowerShell-Objektadapter bereitstellt. Der Zugriff auf
Verzeichnisdienste, Datenbanken und XML-Dokumente funktioniert
ähnlich.
```
Die wenigen .NET-Metaklassen sind insbesondere in der "alten" WMI-Welt
(WMI API):

```
System.Management.ManagementObjectCollection
System. Management.ManagementObject
System.Management.ManagementClass
System.Management.PropertyDataCollection
```
Das folgende, vom Autor dieses Buchs erstellte Schaubild veranschaulicht
diese Projektion (Abbildung) beim WMI-API und den alten PowerShell-WMI-
Commandlets. Die Projektion würde aber eigentlich dazu führen, dass der
Zugriff auf WMI-Objekte über .NET nicht gerade "geschmeidig" wäre, weil
immer umständlich die PropertyDataCollection anzusprechen wäre. Hier
bietet die PowerShell auf Basis des Adapted Type System (ATS) eine
Vereinfachung, denn die PowerShell erstellt durch den eingebauten WMI-
Objektadapter dynamisch wieder Objekte, die den WMI-Klassen
entsprechen. Diesen komplexen Zusammenhang veranschaulicht
nachstehende Grafik ebenfalls.


Bild 16.15 Abbildung von WMI API-Objekten in der PowerShell

In der neueren WMI-Welt ab PowerShell-Version 3.0 (Management
Infrastructure API) kommen folgende Klassen zum Einsatz:

```
Microsoft.Management.Infrastructure.CimInstance
Microsoft.Management.Infrastructure.CimClass
Microsoft.Management.Infrastructure.CimInstanceProperties
Microsoft.Management.Infrastructure.CimClassProperties
Microsoft.Management.Infrastructure.CimProperty
```

Das folgende, vom Autor dieses Buchs erstellte Schaubild veranschaulicht
diese Projektion beim neuen MI-API und den neuen PowerShell-WMI-
Commandlets.

Bild 16.16 Abbildung von MI API-Objekten in der PowerShell

Die Menge der verfügbaren Attribute und Methoden ermittelt man wie bei
normalen .NET-Objekten mit Get-Member. Obwohl die Mitglieder einer WMI-
Klasse (z. B. Win32_LogicalDisk) nicht auch gleichzeitig Mitglieder der die
WMI-Klasse verpackenden .NET-Metaklasse
(System.Management.ManagementObject bzw.


Microsoft.Management.Infrastructure.CimInstance) sind, listet Get-Member
dennoch die Mitglieder aus beiden Abstraktionsebenen auf.

```
ACHTUNG: Wenn Sie Hilfeinformationen zu den Objekten in der
Pipeline suchen, müssen Sie also in die Dokumentation des WMI-
Schemas [https://docs.microso.com/de-
de/windows/win 32 /wmisdk/wmi-classes?redirectedfrom=MSDN]
schauen, nicht in die Dokumentation von System.Management
[https://docs.microso.com/en-us/dotnet/api/system.management?
redirectedfrom=MSDN&vie w=dotnet-plat-ext-6.0].
```
Die PowerShell hat ihre eigene Art und Weise, die durch den WMI-
Objektadapter erzeugten Klassen zu benennen. Sie verwendet den Namen
der .NET-Metaklasse (System.Management. ManagementObject) und den Pfad
der WMI-Klasse getrennt durch das Zeichen "#":

```
System.Management.ManagementObject#root\cimv 2 \Win32_LogicalDisk
```
bzw. in der neuen WMI-Welt:

```
Microsoft.Management.Infrastructure.CimInstance#root/cimv 2 /Win32_Log
icalDisk
```

Bild 16.17 Auflisten des Pipeline-Inhalts mit Get-Member, wenn sich WMI-Objekte in der Pipeline
befinden

16.9 Beschränkung der Ausgabeliste bei

WMI-Objekten

Beim Zugriff auf einzelne Objekte sowie Objektmengen erhält man eine
lange Ausgabeliste. Im Standard werden mit Format-List die zahlreichen


Eigenschaen der ermittelten WMI-Objekte ausgegeben (siehe folgende
Abbildung am Beispiel Win32_VideoController).

Bild 16.18 Eigenschaen der Klasse Win32_VideoController

Auch eine Ausgabe mit dem Commandlet Format-Table hil nicht. Dies
macht die Ausgabe zwar kürzer, aber viel breiter. Gut wäre es, das
resultierende Objekt mit Select-Object auf die interessanten Eigenschaen
zu "beschneiden":

```
Get-CimInstance Win32_VideoController |
Select-Object name,installeddisplaydrive
```

Auch für einige WMI-Klassen ist in der types.ps 1 xml-Datei festgelegt, welche
Attribute ausgegeben werden. Für Win32_VideoController gibt es eine solche
Festlegung nicht; daher werden alle Attribute ausgegeben. Die folgenden
Abbildungen zeigen aber die Wirkung der Deklarationen für
Win32_CDRomDrive.

Bild 16.19 Standardausgabe des Befehls Get-CimInstance Win32_CDRomDrive

Bild 16.20 Festlegung der auszugebenden Attribute für die WMI-Klasse Win32_CDRomDrive

Das folgende Listing zeigt Beispiele zum Einsatz des neueren WMI-
Commandlets Get-CimInstance in Zusammenarbeit mit Commandlets zur


Pipeline-Steuerung:

```
# Name und freie Bytes auf allen Laufwerken
Get-CimInstance Win32_logicaldisk | Select-Object deviceid,freespace
```
```
# Name und Domain der Benutzerkonten, deren Kennwort niemals verfäll
t
Get-CimInstance Win32_account | Where-Object {$_.Kennwortexpires -eq
0 } |
Select-Object Name,Domain
```
16.10 Zugriff auf einzelne Mitglieder von

WMI-Klassen

Auf die Attribute und auch auf die Methoden von WMI-Klassen kann man
zugreifen wie auf die Mitglieder von .NET-Klassen. Die PowerShell abstrahiert
von der Metaobjektmodellimplementierung durch den Objektadapter, so
dass man die einzelnen Eigenschaen der WMI-Klasse über die
Punktnotation ($Objektvariable.PropertyName) ansprechen kann.

```
Listing 16.3 Zugriff auf ein Instanzmitglied: Ausgabe der Laufwerksbezeichnung (VolumeLabel)
mit der WMI-Klasse Win32_LogicalDisk
# Instanzmitglied abrufen aus Instanz
$laufwerk = [WMI] "\\F 171 \root\cimv2:Win32_LogicalDisk.DeviceID
='C:'"
"Die aktuelle Bezeichnung von Laufwerk C ist: " + ($laufwerk.Volumen
ame)
```
Anders als bei .NET-Objekten macht die PowerShell bei WMI keine
syntaktischen Unterschiede zwischen statischen Mitgliedern
(Klassenmitglied) und Instanzmitgliedern, d. h., es ist immer nur der einfache
Punktoperator zu verwenden (in .NET-Objekten ist der doppelte
Doppelpunkt für statische Methoden zu verwenden). Bei WMI ist nur zu


beachten, dass mit dem PowerShell-Typ [WMIClass] auf den WMI-Pfad der
WMI-Klasse, nicht einer konkreten Instanz verwiesen wird.

Beispiel: Abruf des Namens des aktuellen Computers

```
Listing 16.4 Zugriff auf ein Klassenmitglied: Ausgabe des Computernamens
(PSComputerName) mit der WMI-Klasse Win32_OperatingSystem
# statisches Mitglied abrufen aus Klasse
$os = ([WMIClass] "Win32_OperatingSystem")
$os.PSComputerName
```
16.11 Werte setzen in WMI-Objekten

Um Werte in Objekten zu setzen, kann man schreibend auf eine Eigenscha
zugreifen. Die Werte werden aber erst gespeichert, wenn man die Methode
Put() in der Metaklasse aufru.

Beispiel:

```
Listing 16.5 Werte setzen in WMI-Objekten mit Put()
# Instanzmitglied abrufen aus Instanz
$laufwerk = [wmi] "\\.\root\cimv2:Win32_LogicalDisk.DeviceID='C: '"
# Zugriff auf aktuellen Wert
"Die aktuelle Bezeichnung von Laufwerk C ist: " + ($laufwerk.Volumen
ame)
# Änderung des Wertes
"Laufwerksname wird geändert"
$laufwerk.Volumename = "Sys"
$laufwerk.Put()
"Die aktuelle Bezeichnung von Laufwerk C ist nun: " + ($laufwerk.Vol
umename)
```

ACHTUNG: Put() liefert leider keine sprechenden Fehlermeldungen.
Man sieht als Fehlermeldung immer nur "Ausnahme beim Aufrufen
von ‚Put' mit 0 Argument(en)".

Bild 16.21 Nichtssagende Fehlermeldung bei Put()

Dies suggeriert, dass man Put() einen Parameter übergeben müsste.
Aber das ist nicht so! Die Fehlermeldung kann so ziemlich alles
heißen, z. B., ungültige Werte wurden gesetzt oder es gibt nicht
ausreichend Rechte für die Änderung. Im konkreten Fall der Änderung
der Laufwerksbezeichnung braucht man volle Administratorrechte.
Dann geht es (siehe folgende Abbildung).


```
Bild 16.22 Erfolgreiche Ausführung von Put() mit vollen Administratorrechten
```
Alternativ kann man Werte in WMI-Objekten mit den WMI-Commandlets
setzen.

Mit dem Commandlet Set-WmiInstance lassen sich seit PowerShell 2.0 Werte
in WMI-Objekten setzen.

Beispiel: Ändern des Namens des Laufwerks C auf dem Computer "F171":

```
Set-WmiInstance -path "\\F 171 \root\cimv2:Win32_LogicalDisk.DeviceID
='c:'" - Arguments @{ VolumeName="System" }
```
Alternativ kann man seit PowerShell-Version 3.0 auch Set-CimInstance
verwenden:

```
Get-CimInstance -namespace "root\cimv2" - class "Win32_LogicalDisk" -
Filter
"DeviceID='c:'" | Set-CimInstance -property @{ VolumeName="System2"
}
```
Vorteil von Set-CimInstance ist, dass es dort sprechende Fehlermeldungen
gibt (siehe folgende Abbildung).


Bild 16.23 Nur Set-CimInstance liefert "Zugriff verweigert"

16.12 Umgang mit WMI-Datumsangaben

Die neuen WMI-Commandlets verarbeiten die Datumsangaben als normale
.NET-Objekte (siehe folgende Abbildung). Get-WMiObject liefert die
Datumsangaben aber als Zeichenkette der Form yyyymmddHHMMSS.mmmmmmsUUU
gespeichert, wobei neben dem selbst erklärenden Kürzel anzumerken ist,
dass mmmmmm die Anzahl der Millisekunden ist und UUU die Anzahl der Minuten,
welche die lokale Zeit von der Universal Coordinated Time (UTC) abweicht.
Das s ist das Vorzeichen. In Deutschland steht daher für UUU der Wert + 060.

Bild 16.24 Datumsangabe mit Get-CIMInstance und Get-WMiObject

Konvertierung des WMI-Formats in normale

Datumsobjekte


Zur Konvertierung eines WMI-Datumsformats in das normale Datumsformat
der PowerShell (Klasse System.DateTime) steht die statische Methode
ToDateTime() in der Klasse System. Management.ManagementDateTimeConverter
zur Verfügung.

```
Listing 16.6 Umwandlung von WMI-Datumsformaten in System.DateTime
[WMI_Date.PS1]
$cs = Get-WMIObject -Class Win32_OperatingSystem
"Startzeit des Systems in WMI-Format: " + $cs.LastBootUpTime
[System.DateTime] $startzeit = [System.Management.ManagementDateTime
Converter]::ToDat
eTime
($cs.LastBootUpTime)
"Startzeit des Systems in normalem Format: " + $startzeit
```
Wenn die PowerShell Community Extensions installiert sind, verfügt die
Klasse Management Object über eine zusätzliche Methode
ConvertToDateTime(), welche die Konvertierung erledigen kann:

```
$cs = Get-CimInstance -Class Win32_OperatingSystem -property LastBoo
tUpTime
$cs.ConvertToDateTime($cs.LastBootUpTime)
```
16.13 Methodenaufrufe

Auch Methodenaufrufe sind in WMI-Klassen möglich über die Punktnotation,
sowohl für Instanzmethoden als auch statische Klassenmethoden.

```
Listing 16.7 WMI-Methodenaufrufe
# Instanzmethode aufrufen
([WMI] "\\F 171 \root\cimv2:Win32_LogicalDisk.DeviceID='c:'").Chkdsk
($false,$false,
$false,$false,$false,$false)
# Statische Klassemethode aufrufen
([WMIClass] "Win32_Product").Install("x:\install\meinSetup.msi")
```

Invoke-WmiMethod

Seit PowerShell 2.0 gibt es das Commandlet Invoke-WmiMethod, mit dem man
WMI-Methoden direkt aufrufen kann.

Beispiel: Aufruf der Methode Chkdsk() in der WMI-Klasse Win32_LogicalDisk
mit sechs Parametern (auf Computer F171):

```
Invoke-WmiMethod -Path "\\F 171 \root\cimv2:Win32_LogicalDisk.DeviceID
='c:'" - Name "Chkdsk" - ArgumentList $false,$false,$false,$false,$fal
se
```
Weitere Beispiele

Umbenennen eines Computers mit der Methode Rename(NeuerName) aus der
Klasse Win32_ Computersystem:

```
Invoke-WmiMethod -Path "\\F 171 \root\cimv2:Win32_Computersystem.Name=
F171" - Name "Rename" - ArgumentList "F172"
```
Neustart eines Computers mit der Methode Reboot() aus der Klasse
Win32_Operating System:

```
Invoke-WmiMethod -Path "\\F 171 \root\cimv2:Win32_OperatingSystem=@" -
Name "Reboot"
```
Invoke-CimMethod

Seit PowerShell-Version 3.0 kann man alternativ Invoke-CimMethod
verwenden. Hier ist zu beachten, dass die Instanz, auf der der Befehl
ausgeführt werden soll, zunächst mit Get-CimInstance geholt wird und die
Parameter als Hash-Tabellen mit Name-Wert-Paaren anzugeben sind.


```
Get-CimInstance -computername F 171 - namespace "root\cimv2" - class "W
in32_ LogicalDisk" - Filter "DeviceID='t:'" | Invoke-CimMethod -Metho
dName "Chkdsk" - Arguments @{ FixErrors=$false; VigorousIndexCheck=$f
alse; SkipFolderCycle=$false; ForceDismount=$false; RecoverBadSector
s=$false; OKToRunAtBootUp=$false }
```
16.14 Neue WMI-Instanzen erzeugen

Viele WMI-Klassen sind so gestaltet, dass zum Anlegen neuer
Systemelemente (Managed Objects) eine Instanz der WMI-Klasse erzeugt
werden muss. Dafür werden auf Klassenebene statische Methoden
angeboten mit Namen Create(), siehe folgende Abbildung. Alternativ kann
man seit PowerShell-Version 3.0 das Commandlet New-CimInstance
verwenden.


Bild 16.25 Methoden der Klasse Win32_Share

Das folgende Beispiel zeigt das Anlegen einer Freigabe mit Standardrechten.
Die Vergabe von Rechten ist ein komplexeres Thema, das später noch
behandelt wird.


```
Listing 16.8 [New-Share-WithoutPermissions(WMI).ps1]
# Create Win32_Share
$pfad = "w:\Temp"
$Sharename = "TempDateien"
$Comment = "Freigabe von w:\Temp"
$class = [WMIClass] "ROOT\CIMV2:Win32_Share"
$Access = $Null
```
```
$R = $class.Create($pfad, $Sharename, 0, 10, $Comment, "", $Access)
if ( $R.ReturnValue -ne 0 ) { Write-Error ("Fehler beim Anlegen: " +
$R.ReturnValue);}
else {"Freigabe wurde angelegt!" }
```
16.15 Instanzen entfernen

Mit Remove-WmiObject (seit PowerShell 2.0) kann man ein WMI-Objekt
löschen, z. B. einen Dateisystemordner auf einem entfernten System:

```
Remove-WmiObject -path "\\F 171 \root\cimv2:Win32_Directory.Name
='c:\\temp'"
```
Mit dem neuen (seit PowerShell-Version 3.0) Remove-CimInstance sieht es so
aus:

```
Get-CimInstance -computername F 171 - class "Win32_Directory" - Filter
"Name='W:\\temp'" | Remove-CimInstance
```

```
HINWEIS: Diese Aktion könnte man ohne Einsatz von WMI alternativ
ausdrücken:
```
```
Invoke-Command -ComputerName F 171 { Remove-Item "w:\temp" }
```
```
Der Unterschied ist: Der erste Befehl verwendet nur WMI-Klassen, die
es auf jedem Windows-System gibt. Der zweite Befehl erfordert auf
dem Zielsystem die PowerShell ab Version 2.0 und dort aktiviertes
PowerShell-Remoting.
```
16.16 Commandlet Definition XML-Datei

(CDXML)

Die PowerShell ist schon 2006 erschienen und bot in der ersten Version zwar
eine Menge Grundinfrastruktur zur Datenverarbeitung mit Import, Export,
Filtern, Sortieren, Gruppieren und Zählen, aber wenig administrative
Commandlets für den Zugriff auf Systembausteine. Erst mit Windows 7 und
Windows Server 2008 R 2 führte Microso mehr administrative Commandlets
ein, aber weiterhin nur für einige ausgewählte Bereiche wie das Active
Directory. Dann mit Windows 8 und Windows Server 2012 stieg die Anzahl
der Commandlets fast explosionsartig. Während Microso bisher alle
Commandlets explizit implementiert hatte, steckt ein Trick hinter der neuen
Produktivität der Entwickler in Redmond: Die meisten der vielen neuen
Commandlets sind als WMI-Klassen automatisch generiert worden.

Mit Windows 8 und Windows Server 2012 führte Microso eine neue WMI-
Version (WMI 2.0) ein, die viele WMI-Klassen einfacher realisiert als bisher
und es zudem erlaubt, aus den WMI-Metadaten ein PowerShell-Commandlet
zu generieren. Dabei wird kein Programmcode erzeugt, sondern lediglich
eine "Commandlet Definition XML"-Datei (CDXML), die die PowerShell
verwendet, um ad hoc passende Commandlets bereitzustellen, wenn man
solche CDXML-Dateien mit Import-Modulen einliest.


Listing 16.9 Ausschnitte aus der Datei SmbShare.cdxml


<?xml version="1.0" encoding="utf-8"?>
<PowerShellMetadata xmlns="http://schemas.microsoft.com/cmdlets-over

- objects/ 2009 /11">

<Class ClassName="ROOT/Microsoft/Windows/SMB/MSFT_SMBShare">
<Version>1.0</Version>

<DefaultNoun>SmbShare</DefaultNoun>
<InstanceCmdlets>

<!--
// Get-SmbShare
-->
<GetCmdletParameters>
<QueryableProperties>
<Property PropertyName="Name">
<Type PSType="string" />
<RegularQuery AllowGlobbing="true">
<CmdletParameterMetadata IsMandatory="false" Position="1" V
alueFromPipe
lineByPropertyName="true" />
</RegularQuery>
</Property>
<Property PropertyName="ScopeName">
<Type PSType="string" />
<RegularQuery AllowGlobbing="false">
<CmdletParameterMetadata IsMandatory="false" Position="2" V
alueFromPipe
lineByPropertyName="true" />
</RegularQuery>
</Property>
...
</Cmdlet>

</InstanceCmdlets>
<StaticCmdlets>


```
<!--
// New-SmbShare
-->
<Cmdlet>
<CmdletMetadata Verb="New" ConfirmImpact="Medium" HelpUri="ht
tp://go.microsoft.com/fwlink/?LinkID=241957" Aliases="nsmbs"/>
<Method MethodName="CreateShare">
<ReturnValue>
<Type PSType="uint32" />
<CmdletOutputMetadata>
<ErrorCode />
</CmdletOutputMetadata>
</ReturnValue>
<Parameters>
<Parameter ParameterName="Description">
<Type PSType="string" />
<CmdletParameterMetadata>
<AllowEmptyString />
<ValidateNotNull />
</CmdletParameterMetadata>
</Parameter>
<Parameter ParameterName="ConcurrentUserLimit">
<Type PSType="Uint32" />
<CmdletParameterMetadata>
<AllowEmptyString />
<ValidateNotNull />
</CmdletParameterMetadata>
...
```
Praxislösung: WMI-Klassenstatistik

Das folgende Skript ermittelt die Anzahl der WMI-Klassen auf Ihrem System
und exportiert eine CSV-Liste der Anzahl der Klassen pro Namensraum. Da
der Vorgang einige Sekunden dauert, kommt Write-Progress zum Einsatz für
eine Fortschrittsanzeige.


```
Listing 16.10 [2_Aufbauwissen\WMI\WMI_Klassenstatistik.ps1]
# Zählt die Anzahl der verfügbaren WMI-Klassen auf dem Rechner
# (C) Dr. Holger Schwichtenberg 2016
```
```
function Get-WMINamespaces([string] $namespace)
{
$e = Get-CimInstance __Namespace -Namespace $namespace
foreach($n in $e)
{
$subnamespace = $namespace + "\" + $n.name
$subnamespace
Get-WMINamespaces $subnamespace
}
}
```
```
$count = 0
$anzKlassen = 0
$namespaces = Get-WMINamespaces "root"
foreach($n in $namespaces)
{
$count++
$klassen = Get-CimClass -Namespace $n
$n + ";" + $klassen.count | Add-Content x:\WMIKlassen.csv
$anzKlassen+=$klassen.count
Write-Progress -Activity "Klassenstatistik" - Status $n -PercentCompl
ete (($count /
$namespaces.Count)* 100 )
}
"Namensräume $($namespaces.count)"
"Klassen $anzKlassen"
```
Bild 16.26 Ergebnis unter Windows 10 mit einigen installierten Programmen z. B. Microso Office
und Visual Studio


Bild 16.27 Ergebnis unter Windows 11 in der Basisinstallation


# 17 Dynamische Objekte

In den meisten Programmiersprachen ist der Aufbau von
Objekten durch Klassendefinitionen zur Entwicklungszeit
festgelegt. Die Klasse definiert die Mitglieder (Attribute,
Methoden und Ereignisse) und die Instanzen dieser Klasse
erhalten genau die in der Klasse definierten Mitglieder. Einige
Programmiersprachen erlauben die Erweiterungen von Objekten
zur Laufzeit um neue Mitglieder. Die PowerShell gehört zu diesen
Programmierumgebungen, die diese Möglichkeit besitzen.

Zentrales Instrument ist dafür das Commandlet Add-Member, mit
dem man ein bestehendes Objekt um Mitglieder erweitern kann.
Ein zusätzliches Attribut sind ein NoteProperty, eine zusätzliche
Methode eine ScriptMethod (weil man sie in der PowerShell-
Skriptsprache implementiert).

Add-Member erwartet folgende Angaben:

```
InputObject: das zu erweiternde Objekt
MemberType: NoteProperty oder ScriptMethode
Name: Bezeichner des neuen Mitglieds
Value: bei einem NoteProperty der Wert, bei einer
ScriptMethod der Skriptblock
```

###### 17.1 Erweitern bestehender Objekte

Eine Schwäche in der .NET-Klassenbibliothek ist sicherlich, dass
die Klasse System. IO. DirectoryInfo, die Ordner im Dateisystem
repräsentiert, kein Attribut besitzt, das die Größe aller Dateien in
diesem Ordner wiedergibt. Es gibt lediglich für einzelne Dateien
(System. IO. FileInfo) das Attribut Length. Die nachstehend
dokumentierte Funktion Get-DirSize ermittelt ausgehend von
einem beliebigen Ordner die Größe der Unterordner, indem
rekursiv die Größe aller Dateien ermittelt wird. Die ermittelte
Größe könnte man in einer separaten Datenstruktur halten. Es ist
aber viel eleganter, diese Größe an die bestehenden Directory-
Info-Objekte für die Ordner anzuheen.


Listing 17.1 Ermitteln der Ordnergrößen und Anheen der Informationen an die
Klasse DirectoryInfo

```
# DirSize.ps 1
# Erweitern der Klasse DirectoryInfo um Attribut Size
```
```
function Get-DirSize($Path)
{
# Zugriff auf Unterverzeichnisse des Wurzelverzeichnises
$WurzelVerzeichnisse = Get-ChildItem $Path -Force | where
{ $_.GetType().Name -eq
"DirectoryInfo" }
```
```
# Iteration über die Unterordner
foreach ($AktuellesVerzeichnis in $WurzelVerzeichnisse)
{
# Ermitteln der Größe aller Dateien in dem Ordner und sein
en Unterordnern
$groesse = ($AktuellesVerzeichnis | Get-ChildItem -Recurse
```
- ea silentlycontinue |
- where { $_.GetType().Name -ne "DirectoryInfo" } | Measure
- Object length -Sum)
# Anfügen des Mitglieds "Size" an das DirectoryInfo-Objekt
Add-Member -InputObject $AktuellesVerzeichnis -Value $groe
sse.Sum -Name "Size"
- MemberType "NoteProperty"
}
# Sortierte Ausgabe der Größen
$WurzelVerzeichnisse | Sort-Object Size -desc
}


Diese Funktion kann man beispielsweise benutzen, um die Größe
der Benutzerprofile auf einem System zu ermitteln.

```
Get-DirSize c:\users | ft Name, Size
```
Bild 17.1 Ausgabe der Ordnergrößen von c:\users

```
ACHTUNG: Bitte beachten Sie, dass der Standort der
Profilordner vom Betriebssystem abhängig ist.
```

Bild 17.2 Der Einsatz von Get-Member beweist, dass System.IO.DirectoryInfo
tatsächlich erweitert wurde.

###### 17.2 Komplett dynamische Objekte

Man kann auch eigene Objekte komplett neu aufbauen. Immer
notwendige Basis ist dabei lediglich die Klasse PSCustomObject.
Die Klasse erbt direkt von System.Object. Von System. Object
erhält PSCustomObject die vier öffentlichen Mitglieder, die jedes
.NET-Objekt besitzt.


Bild 17.3 Die vier Standardmitglieder eines jeden .NET-Objekts

Beispiel

Das Beispiel zeigt die Erstellung eines Person-Objekts, das die
Attribute Geschlecht, Titel, Vorname und Name besitzt, sowie eine
ScriptMethod GetAnrede(), die diese beiden Zeichenketten
korrekt zu einer Anrede zusammenfügt.


Listing 17.2 [ \2_Aufbauwissen\DynamischeObjekte\DynamischeObjekte.ps1]

```
[PSCustomObject] $person = new-object PSCustomObject
```
```
Add-Member -InputObject $person -MemberType NoteProperty -
Name Geschlecht "M"
Add-Member -InputObject $person -MemberType NoteProperty -
Name Name "Schwichtenberg"
Add-Member -InputObject $person -MemberType NoteProperty -
Name Vorname "Holger"
Add-Member -InputObject $person -MemberType NoteProperty -
Name Titel "Dr."
Add-Member -InputObject $person -MemberType ScriptMethod -
Name GetAnrede -Value {
```
```
if ($Geschlecht -eq "W") { $Anrede = "Frau"}
else { $Anrede = "Herr" }
if ($Titel -ne "") { $Anrede = $Anrede + " " + $this.Tite
l}
return $Anrede + " " + $this.Vorname + " " + $this.Name
```
```
}
```
```
$person.GetAnrede() # liefert: "Herr Dr. Holger Schwichten
berg"
```

```
HINWEIS: Innerhalb einer ScriptMethod nimmt man mit
$this Bezug auf die übrigen Mitglieder des aktuellen
Objekts. Dies ist wohl zu unterscheiden von $_ (alias
$PSItem), mit dem man das aktuelle Objekt in der Pipeline
adressiert.
Natürlich kann man innerhalb einer ScriptMethod auch
Pipeline-Befehle verwenden.
```
Es ist eine verkürzte Schreibweise möglich, indem man die
Eigenschaen des selbst definierten Objekts in einer Hashtable
speichert und diese dann in ein PSCustomObject überführt:

```
$person 2 = new-object psobject @{ Geschlecht="M"; Name="Sc
hwichtenberg";
Vorname="Holger"; Titel="Dr." }
```
oder

```
$person 3 = [PSCustomObject] @{ Geschlecht="M"; Name="Schwi
chtenberg";
Vorname="Holger"; Titel="Dr." }
```
Es ist dabei aber nicht möglich, eine ScriptMethod auf diese
Weise festzulegen. Hierzu braucht man weiterhin Add-Member.


Listing 17.3 DynamischeObjekte.ps 1

```
$person 3 = [PSCustomObject] @{ Geschlecht="M"; Name="Schwi
chtenberg";
Vorname="Holger"; Titel="Dr." }
Add-Member -InputObject $person 3 - MemberType ScriptMethod
```
- Name GetAnrede -Value {

```
if ($this.Geschlecht -eq "W") { $Anrede = "Frau"}
else { $Anrede = "Herr" }
if ($this.Titel -ne "") { $Anrede = $Anrede + " " + $this.
Titel}
return $Anrede + " " + $this.Vorname + " " + $this.Name
}
```

# 18 Einbinden von C# und

# Visual Basic .NET

Das seit PowerShell 2.0 neu eingeführte Commandlet Add-Type
erlaubt die dynamische Kompilierung einer .NET-Klasse. Dabei
kann der Quelltext in einer externen Datei liegen oder in ein
PowerShell-Skript eingebettet sein. Erlaubte
Programmiersprachen sind C# ("cs"), Visual Basic .NET
("VisualBasic") und JScript .NET ("js").

In der alten PowerShell 1.0 konnte man Programmcode aus einer
der drei vorgenannten Sprachen nur verwenden, indem man den
Programmcode statisch kompiliert und dann die entstandene
Assembly in die PowerShell geladen hat. Mit Add-Type kann man
nun mit den .NET-Sprachen umgehen wie mit Skriptsprachen.

Das folgende Listing zeigt am Beispiel einer "HelloWorld"-
Anwendung verschiedene Möglichkeiten, C#-Programmcode in
einem PowerShell-Skript aufzurufen.


Listing 18.1 Hello World in C#, eingebettet in ein PowerShell-Skript
[WPS2_CSClass.ps1]

```
# CSharp-Code eingebettet in PowerShell-Skripte
$CSKlasseCode = @"
// Statische Methode mit Parameter
public static string Hallo 1 (string name)
{
return "Hallo " + name + "!";
}
```
```
// Instanz-Methode mit Parameter
public string Hallo 2 (string name)
{
return "Hallo " + name + "!";
}
```
```
public string Name;
```
```
// Instanz-Methode ohne Parameter
public string Hallo 3 ()
{
return "Hallo " + this.Name + "!";
}
```
```
"@
# Dynamisches Kompilieren
$CSKlasse = Add-Type -MemberDefinition $CSKlasseCode -Name
"Welt" - language csharp
```
- UsingNamespace "System.Reflection","System.Diagnostics" -
PassThru


# Testen
$CSKlasse::Hallo 1 ("Holger")
$o = New-Object $CSKlasse
$o.Hallo 2 ("Holger")
$o.Name = "Holger"
$o.Hallo 3 ()


Listing 18.2 Hello World in Visual Basic .NET, eingebettet in ein PowerShell-Skript
[WPS2_VBClass.ps1]

```
$MeineKlasse= @"
```
```
' Statische Methode mit Parameter
Public Shared Function Hallo 1 (ByVal name As String) As Str
ing
Return "Hallo " & name & "!"
End Function
```
```
' Instanz-Methode mit Parameter
Public Function Hallo 2 (ByVal name As String) As String
Return "Hallo " & name & "!"
End Function
```
```
Public _Name As String
```
```
' Instanz-Methode ohne Parameter
Public Function Hallo 3 () As String
Return "Hallo " & Me._Name & "!"
End Function
"@
```
```
$myclass = Add-Type -MemberDefinition $MeineKlasse-Name "M
eineKlasse" - language
VisualBasic -UsingNamespace "System.Reflection","System.Di
agnostics" - PassThru
```
```
$myclass::Hallo 1 ("Holger")
```
```
o = New-Object $myclass
```

$o.Hallo 2 ("Holger")

$o.Name = "Holger"
$o.Hallo 3 ()


# 19 Win32-API-Aufrufe

Man kann aus der PowerShell heraus direkt auf .NET-Klassen,
COM-Klassen und WMI-Klassen zugreifen. Es gibt aber keine
unmittelbare Zugriffsmöglichkeit auf die Win32-API-Funktionen.
Auch schon zu Zeiten von PowerShell 1.0 gab es einen Trick mit
der FCL, um Win32-API-Aufrufe über den in das .NET Framework
eingebauten Mechanismus "Plattform Invoke" (kurz: PInvoke)
aufzurufen. Seit PowerShell 2.0 ist dies stark vereinfacht durch
die Möglichkeit, C#- oder Visual Basic.NET-Code direkt in
PowerShell-Skriptcode einzubetten. So kann man dort PInvoke in
die Win32-API-Aufrufe kapseln.

Das Beispiel zeigt eine in ein PowerShell-Skript eingebettete C#-
Klasse, die Zugriff auf die Bildschirmschonereinstellungen über
die Win32-API-Methode SystemParametersInfo bietet.


Listing 19.1 Die in das PowerShell-Skript eingebettete Klasse "ScreenSaver"
kapselt den Zugriff auf eine Win32-API-Funktion. [WPS2_Win 32 API._ Screensaver.ps1]

```
$CSharpKlassenDefinition = @"
```
```
[DllImport("user32.dll", CharSet = CharSet.Auto)]
private static extern bool SystemParametersInfo(
int uAction, int uParam, ref bool lpvParam,
int flags);
```
```
private const int SPI_GETSCREENSAVERACTIVE = 16;
private const int SPI_SETSCREENSAVERACTIVE = 17;
private const int SPIF_SENDWININICHANGE = 2;
private const int SPI_GETSCREENSAVERTIMEOUT = 14;
private const int SPI_SETSCREENSAVERTIMEOUT = 15;
```
```
public static bool GetStatus()
{
bool isActive = false;
```
```
SystemParametersInfo(SPI_GETSCREENSAVERACTIVE,
0,
ref isActive, 0 );
```
```
return isActive;
}
```
```
public static void TurnOn()
{
int nullVar = 0;
```
```
bool result = SystemParametersInfo(SPI_SETSCREE
```

NSAVERACTIVE,
1, ref nullVar, SPIF_SENDWININICHANGE);

if (!result)
{
throw new System.ComponentModel.Win 32 Except
ion(Marshal.
GetLastWin 32 Error());
}
}

public static void TurnOff()
{
int nullVar = 0;

bool result = SystemParametersInfo(SPI_SETSCRE
ENSAVERACTIVE,
0, ref nullVar, SPIF_SENDWININICHANGE);

if (!result)
{
throw new System.ComponentModel.Win 32 Excep
tion(Marshal.
GetLastWin 32 Error());
}
}
public static Int 32 GetTimeout()
{
Int 32 value = 0;

bool res = SystemParametersInfo(SPI_GETSCREENS
AVERTIMEOUT, 0,


ref value, 0 );
if (!res)
{
throw new System.ComponentModel.Win 32 Except
ion(Marshal.
GetLastWin 32 Error());
}
return value;
}

public static void SetTimeout(Int 32 Value)
{
int nullVar = 0;

bool res = SystemParametersInfo(SPI_SETSCREEN
SAVERTIMEOUT,
Value, ref nullVar, SPIF_SENDWI
NINICHANGE);
if (!res)
{
throw new System.ComponentModel.Win 32 Excep
tion(Marshal.
GetLastWin 32 Error());
}
}
"@

$Klasse = Add-Type -MemberDefinition $CSharpKlassenDefinit
ion -Name "ScreenSaver"

- UsingNamespace "System.Reflection","System.Diagnostics" -
PassThru
$Klasse::GetStatus()


$Klasse::GetTimeout()
$Klasse::TurnOff()
$Klasse::GetStatus()
$Klasse::GetStatus()
$Klasse::SetTimeout( 800 )
$Klasse::GetStatus()


# 20 Benutzereingaben

Dieses Kapitel behandelt Eingabefunktionen, mit denen während
des Skriptablaufs Eingaben des Benutzers entgegengenommen
werden. In einigen Fällen ist ein Rückgriff auf .NET-Klassen
notwendig. Die Hintergründe dazu sind im Kapitel "Verwendung
von .NET-Klassen" erläutert. Auch das Befüllen und Auslesen der
Zwischenablage wird in diesem Kapitel behandelt.

Tabelle 20.1 Wichtige Eingabe-Commandlets

```
Read-Host Eingaben von Konsole
einlesen
```
```
Import-CSV/Export-CSV CSV-Datei
importieren/exportieren
```
```
Import-ClixmlClixml/Export-
ClixmlClixml
```
```
XML-Datei
importieren/exportieren
```
## 20.1 Read-Host


Texteingaben vom Benutzer kann die PowerShell während des
Skriptablaufs durch Read-Host entgegennehmen.

```
PS X:\> $name = read-host "Bitte Benutzernamen eingeben"
Bitte Benutzernamen eingeben: HS
PS X:\> $kennwort_verschluesselt = read-host -assecurestri
ng "Bitte Kennwort
eingeben"
Bitte Kennwort eingeben: ****
```
```
TIPP: Bei der Verwendung des Parameters -
assecurestring sieht man auf dem Bildschirm nur
Sternchen. Aber auch intern gibt es Unterschiede:
Während man normalerweise ein Objekt vom Typ
System.String bekommt, gibt es dann eine Instanz von
System.Security.SecureString, in der die Zeichenkette im
Hauptspeicher verschlüsselt vorliegt. Einen solchen
SecureString muss man dann etwas umständlich
zurückkonvertieren:
```
```
[String]$kennwort_unverschluesselt = [Runtime.Inter
opServices.Marshal]::
PtrToStringAuto([Runtime.InteropServices.Marshal]::
SecureStringToBSTR ($kennwort_verschluesselt))
"Kennwort: " + $kennwort_unverschluesselt
```
Das folgende Skript führt eine interaktive Altersberechnung
durch und erfragt dazu Name und Geburtsdatum vom Benutzer.


```
Listing 20.1 Abfrage von Namen und Geburtstag zur Altersberechnung
[2_Aufbauwissen/Eingabe/NameUndAlter.ps1].
#Interaktive Altersberechnung
```
```
$name = read-host "Bitte geben Sie Ihren Namen ein"
[DateTime] $geb = read-host "Bitte geben Sie Ihren Geburts
tag ein"
$alter = ([DateTime]::Now – $geb).days
```
```
Write-Host ("Hallo " + $name) - foregroundcolor Yellow
Write-Host ("Sie sind " + $Alter + " Tage alt!") - foregrou
ndcolor Green
```
###### 20.2 Benutzerauswahl

Die PowerShell fragt an vielen Stellen beim Benutzer nach, ob er
eine Aktion wirklich ausführen will. Für diese Nachfrage gibt es
zwar kein Commandlet, aber eine Methode PromptForChoice() in
der .NET-Klasse System.Management.Automation.Internal.Host.
InternalHostUserInterface. Hier wird ein Beispiel für eine
Auswahl zwischen drei Optionen gezeigt. Jede der übergebenen
Optionen erhält mit dem vorangestellten kaufmännischen Und
(&) eine Taste zugewiesen. Intern vergibt die Methode
PromptForChoice() den Optionen dann Zahlen (bei 0 beginnend),
die im Ergebnis verwendet werden. Die Zahl 2 als letzter
Parameter bei PromptForChoice() bedeutet, dass die dritte Option
(nicht die zweite, die Zählung beginnt ja bei 0!) die
Standardauswahl ist, die die PowerShell hervorhebt.


```
Listing 20.2 [2_Aufbauwissen\Eingabe\Nachfrage.ps1]
$optionen = [System.Management.Automation.Host.ChoiceDescr
iption[]]
("&Ja","&Nein","&Wenn es sein muss")
$ergebnis = $Host.UI.PromptForChoice("Reboot-Nachfrage","K
ann das System jetzt neu
gestartet werden?",$optionen,2)
```
```
"Sie haben gewählt: $ergebnis"
if ($ergebnis -eq 0 ) { "System wird jetzt neu gestartet ..."
}
if ($ergebnis -eq 1 ) { "System wird NICHT neu gestartet!"
}
if ($ergebnis -eq 2 ) { "System wird nur neu gestartet, wen
n es sein muss" }
```
Bild 20.1 Anwendung des Skripts an der PowerShell-Standardkonsole


Bild 20.2 Anwendung des Skripts an der ISE, die hier ein Dialogfenster anzeigt

###### 20.3 Grafischer Eingabedialog

Ein einfaches Texteingabefeld stellt die bereits aus Visual
Basic/VBScript bekannte Funktion InputBox() dar. Diese Funktion
existiert auch noch im .NET Framework in der Klasse
Microsoft.VisualBasic.Interaction. Zur Nutzung der Funktion
muss erst die Assembly Microso.VisualBasic.dll geladen werden.
Weitere Möglichkeiten zu Eingabedialogen stellt das Kapitel
"Einsatzgebiete/Grafische Benutzerschnittstellen" vor.

```
Listing 20.3 Einfache grafische Dateneingabe in der PowerShell
[2_Aufbauwissen/DOTNET/InputBox1.ps1]
```
```
Add-Type -assembly Microsoft.VisualBasic
$eingabe = [Microsoft.VisualBasic.Interaction]::InputBox
("Bitte geben Sie Ihren Namen
ein!", "Namenseingabe")
"Hallo $Eingabe!"
```

Bild 20.3 Start des PowerShell-Skripts aus der PowerShell ISE heraus

###### 20.4 Dialogfenster

Für Dialogfenster kann man auf .NET-Klassen zurückgreifen. Das
folgende Skript bittet den Anwender über ein Dialogfenster um
eine Entscheidung (Ja/Nein). Weitere Möglichkeiten zu
Dialogfenstern stellt das Kapitel "Einsatzgebiete/Grafische
Benutzerschnittstellen" vor.


```
Listing 20.4 Nutzung der Klasse MessageBox in der PowerShell
[2_Aufbauwissen/DOTNET/MessageBox.ps1]
Add-Type -assemblyname system.windows.forms
[System.Console]::Beep(15440, 30 )
[System.Windows.Forms.MessageBox]::Show("Gleich kommt eine
Frage","Vorwarnung",
[System.Windows.Forms.MessageBoxButtons]::OK)
```
```
$antwort = [System.Windows.Forms.MessageBox]::Show("Nachri
cht","Ueberschrift",
[System.Windows.Forms.MessageBoxButtons]::YesNo)
if ($antwort -eq "Yes")
{ "Sie haben zugestimmt!" }
else
{ "Sie haben abgelehnt!" }
```
###### 20.5 Authentifizierungsdialog

Es gibt zahlreiche Commandlets, die die Angabe eines
Benutzerskontos in Form eines Objekts des Typs
System.Management.Automation.PSCredential erwarten. Ein
solches Objekt erhält man von dem Commandlet Get-Credential
oder durch manuelle Konstruktion der Klasse.

Get-Credential öffnet im Standard einen GUI-basierten
Authentifizierungsdialog (siehe folgende Abbildung). Das
Ergebnis ist eine Instanz von System.Management.Automation.
PSCredential mit dem Benutzernamen im Klartext in UserName
und dem Kennwort verschlüsselt in Password. Ein solches Objekt


kann in einigen PowerShell-Commandlets als Parameter
verwendet werden für die Authentifizierung oder
Impersonifizierung.

Man kann bei Get-Credential den Benutzernamen auch
vorgeben, sodass das Feld "Benutzername" im Dialog bereits
ausgefüllt ist:

```
Get-Credential FBI\FoxMulder
```
```
ACHTUNG: Sie bekommen auch dann ein PSCredential-
Objekt, wenn die Eingabe falsch war. Zur konkreten
Nutzung der Daten zur Authentifizierung sind andere
Verfahren notwendig. Insbesondere werden
Commandlets und Klassen benötigt, welche die
verschlüsselten Kennwörter verarbeiten können.
```
Bild 20.4 Einsatz von Get-Credential


Will man die Abfrage stattdessen textbasiert in der Konsole
durchführen, muss man vorher einen Registrierungseintrag
ändern:

```
Set-ItemProperty "HKLM:\SOFTWARE\Microsoft\PowerShell\ 1 \Sh
ellIds" - Name
ConsolePrompting -Value $true
$c 2 = Get-Credential -Username PC 123 \hs -Message "Anmelded
aten für F181:"
# GUI Prompting reaktivieren
Set-ItemProperty "HKLM:\SOFTWARE\Microsoft\PowerShell\ 1 \Sh
ellIds" - Name
ConsolePrompting -Value $false
```
Bild 20.5 Textbasierte Kennworteingabe für ein Benutzerkonto

Wenn man das Kennwort selbst auch im Skriptcode hinterlegen
will, dann geht das so:


```
$benutzer = "PC 123 \hs"
$kennwort = "geheim123"
$kennwortSecure = ConvertTo-SecureString –String $kennwort
```
- AsPlainText -Force
$c 3 = New-Object –TypeName System.Management.Automation.PS
Credential –ArgumentList
$benutzer, $kennwortSecure

```
HINWEIS: Die Möglichkeit, Kennwörter im Skriptcode zu
hinterlegen, sollte man nur in Ausnahmefällen mit großer
Vorsicht nutzen. Auf keinen Fall darf man dies in einem
Skript machen, dessen Quellcode ein anderer Nutzer
einsehen kann. Auch im eigenen Skript besteht die Gefahr,
dass eine andere Person den Skriptcode sieht!
```
Man kann einen Authentifizierungsdialog auch selbst realisieren.
Wie dies textbasiert geht, zeigt das nachstehende Listing. Eine
Umsetzung als GUI zeigt das Kapitel 64 "Grafische
Benutzeroberflächen".

```
$benutzer = Read-Host "Bitte Benutzernamen eingeben"
$kennwort = Read-Host -assecurestring "Bitte Kennwort eing
eben"
$kennwortSecure = ConvertTo-SecureString –String $kennwort
```
- AsPlainText -Force
$c 4 = New-Object –TypeName System.Management.Automation.PS
Credential –ArgumentList
$benutzer, $kennwortSecure


###### 20.6 Zwischenablage (Clipboard)

Zum Befüllen und Auslesen der Zwischenablage gibt es seit
PowerShell 5.0 die Commandlets:

```
Set-Clipboard
Get-Clipboard
```
Unterstützt werden die Formate Text, Audio, Image und
FileDropList (Ausgabe von Get-ChildItem). Diese Commandlets
gibt es für ältere PowerShell-Versionen im Rahmen der PSCX.

```
Listing 20.5 [2_Aufbauwissen\Benutzereingaben\Zwischenablage.ps1]
"Text in Zwischenablage"
Set-Clipboard "www.IT-Visions.de"
$Url = Get-Clipboard
$url
```
```
"Dateiliste in Zwischenablage"
Dir c:\Windows | Set-Clipboard
$dateien = Get-Clipboard -Format FileDropList
$dateien | gm
```
```
"Das liefert nur die Namen der Dienste, leider nicht die D
ienstobjekte"
Get-Service | Set-Clipboard
$dienste = Get-Clipboard -Format Text
$dienste
```

Bild 20.6 Einsatz von Get-Clipboard und Set-Clipboard

Ältere PowerShell-Versionen können die Commandlets aus den
PSCX nutzen:

```
Write-Clipboard
Set-Clipboard
Get-Clipboard
```

# 21 Fehlersuche

Dieses Kapitel zeigt verschiedene Optionen zur Fehlersuche bei
Commandlets und in Skripten auf.

## 21.1 Detailinformationen

Detailinformationen über die Arbeit eines einzelnen
Commandlets erhält man durch den Standardparameter –
verbose. Das Gleiche für ganze Skripte erreicht man durch Set-
PsDebug -trace 1 oder Set-PsDebug -trace 2. Die folgende
Abbildung zeigt die Ausgaben bei -trace 1. Bei -trace 2 wäre die
Ausgabe noch detaillierter.


Bild 21.1 Protokollieren eines Skriptablaufs

###### 21.2 Einzelschrittmodus


Mit dem Commandlet Set-PsDebug -step kann man Skripte
schrittweise durchlaufen, d. h., die PowerShell gibt die Schritte
nicht nur aus, sondern fragt auch noch nach jedem Schritt, ob die
Ausführung fortgesetzt werden soll.

Bild 21.2 Durchlaufen eines Skripts in Einzelschritten

###### 21.3 Zeitmessung


Das Commandlet Measure-Command liefert die Angabe, wie lange
ein Befehl zur Ausführung braucht – in Form eines TimeSpan-
Objekts.

Beispiel:

```
Measure-Command { Dir c:\Windows a* | ft name }
```
Das Commandlet Measure-Command hat den Nachteil, dass man die
Ausgaben nicht mehr sieht, die der auszuführende Befehl liefert.
Wenn die Ausgabe noch gebraucht wird: Einsatz der Klasse
System.Diagnostics.Stopwatch! Allerdings verlangsamt die
Ausgabe natürlich die Ausführung!

```
$sw = [System.Diagnostics.Stopwatch]::StartNew()
Dir c:\Windows a* | ft name
$sw.Stop()
"Duration: $($sw.ElapsedMilliseconds) ms"
```
Weitere Option: in Measure-Command eine Variable befüllen und die
später ausgeben, wenn das dann noch passt.

```
Measure-Command { $x = Dir c:\Windows a* | ft name }
$x
```
###### 21.4 Ablaufverfolgung (Tracing)

Das PowerShell-Tracing liefert detaillierte Informationen über die
Verarbeitung von Befehlen durch die PowerShell und kann zur
Diagnose eingesetzt werden, wenn nicht der erwartete Befehl


aufgerufen wird oder die Parameterübergabe nicht wie erwartet
funktioniert.

21.4.1 Tracesources

Eine Tracesource ist eine Informationsquelle für die Diagnose.
Get-TraceSource listet alle überwachbaren Protokollquellen auf.
Da es zahlreiche Quellen gibt, ist hier nicht der Raum, alle zu
erläutern.

Bild 21.3 Ausgabe von Get-TraceSource

21.4.2 Verfolgung eines Einzelbefehls


Um die interne Verarbeitung eines PowerShell-Befehls zu
betrachten, gibt es das Commandlet Trace-Command. Die folgende
Abbildung zeigt die Ausgabe für den Befehl Trace-Command -Name
metadata,parameterbinding,cmdlet -Expression {Get-Process
explorer -computername e 29 } - PSHost Man sieht, dass das
Commandlet Trace-Command genaue Informationen über die
Verarbeitung der Parameter liefert.

Bild 21.4 Ausgabe von Trace-Command

Ein weiteres Tracing-Beispiel ist die Verfolgung, wo die
PowerShell nach einem Befehl sucht, in diesem Fall nach dem
nicht existierenden Befehl abc: Trace-Command -Name
commanddiscovery -Expression { abc } - PSHost

21.4.3 Generelle Ablaufverfolgung


Mit dem Commandlet Set-TraceSource kann man eine
Ablaufverfolgung aktivieren, die detaillierte Informationen über
jeden folgenden Verarbeitungsschritt der PowerShell liefert.

```
ACHTUNG: Beim Experimentieren mit Set-TraceSource
können Sie schnell zu einem Punkt kommen, wo Sie vor
lauter Protokollausgaben die eigentlichen Aktionen nicht
mehr sehen. Um die Protokollierung wieder zu
deaktivieren, verwendet man Set-TraceSource mit dem
Parameter -RemoveListener.
```
###### 21.5 Erweiterte Protokollierung

###### aktivieren

Die Windows PowerShell protokolliert in dem Windows-
Ereignisprotokoll (Anwendungs- und
Dienstprotokolle/Microso/Windows/PowerShell/Operational) z.
B. den Start von Skripten und die Ausführung von Befehlen auf
anderen Systemen wie PowerShell Remoting.


TIPP: Durch Änderungen der lokalen Computerrichtlinie
oder der Active Directory-Gruppenrichtlinie kann man für
einen Windows-PC die Protokollierung noch deutlich
detaillierter gestalten. Unter "Computer
Configuration\Administrative Templates\Windows
Components\Windows PowerShell\Turn on Module
Logging" kann man PowerShell-Module angeben, die
detailliert protokolliert werden sollen. Dabei steht \* für
alle Module. Die Protokollierung kann man mit der
Einstellung "Turn on PowerShell Script Block Logging" bis
auf einzelne Skriptblöcke herunterbrechen. Dann wird
das Ereignisprotokoll aber sehr schnell unübersichtlich
voll!


Bild 21.5 PowerShell-Einträge im Ereignisprotokoll

###### 21.6 Script-Debugging in der ISE

Das Debugging innerhalb der ISE wurde bereits im Kapitel 11
"PowerShell-Werkzeuge" behandelt.


###### 21.7 Kommandozeilenbasiertes

###### Script-Debugging

Neben dem Script-Debugger innerhalb der ISE gibt es für
Puristen und Situationen, wo die ISE nicht zur Verfügung steht,
auch ein kommandozeilenbasiertes Script-Debugging. Dieses
initiiert man an der Kommandozeile mit Set-PSBreakpoint unter
Angabe eines Skriptnamens und zusätzlich einer Zeilennummer
(-line), bei der gehalten werden soll, oder eines Namens einer
Variablen (-variable), bei deren Vorkommen gehalten werden
soll. Auch die Angabe eines Befehls, bei dem abgebrochen
werden soll, ist mit -command möglich.

Nach dem tatsächlichen Start dieses Skripts ist die PowerShell-
Konsole dann im Debug-Modus (angezeigt durch den Zusatz
[DBG] vor der Eingabeaufforderung). Hier stehen neben allen
PowerShell-Befehlsmöglichkeiten auch zusätzliche spezielle
Befehle zur Verfügung (siehe folgende Tabelle). Die
Groß-/Kleinschreibweise ist dabei irrelevant.

Neu seit PowerShell-Version 4.0 ist, dass man das
kommandozeilenbasierte Script-Debugging auch für
fernausgeführte Skripte nutzen kann, indem man Set-
PSBreakpoint im Rahmen einer mit Enter-PSSession erstellten
Sitzung oder im Rahmen von Invoke-Command nutzt.


Tabelle 21.1 Spezielle Befehle im Rahmen des kommandozeilenbasierten Script-
Debuggings

Befehl Abkürzung Bedeutung

```
stepOver V Nächster Befehl auf dieser
Befehlsebene. Unterroutinen
werden komplett ausgeführt.
```
```
stepInto S Nächster Befehl. Debugger
springt dazu ggf. in
Unterroutinen.
```
```
stepOut O Debugger kehrt zum nächsten
Befehl auf der übergeordneten
Ebene im Call Stack zurück.
```
```
continue C Skript läu weiter bis zum
nächsten Haltepunkt, ggf. bis zum
Ende.
```
```
List L Zeigt das Listing des aktuellen
Teils des Skripts
```
```
Get-
PSCallStack
```
K Zeigt den Call Stack

```
H Hilfe für die speziellen Debugger-
Befehle
```
```
Quit Q Beenden des Debuggers. Die
Skriptausführung wird dadurch
abgebrochen.
```

TIPP: Die Eingabetaste wiederholt den letzten Befehl.

Bild 21.6 Kommandozeilenbasiertes Script-Debugging

Abbildung 21.6 zeigt ein Beispiel für den Einsatz des
kommandozeilenbasierten Script-Debuggings mit dem Skript
LocalUser_Create.ps 1. Set-PSBreakpoint wird eingestellt, sodass
das Skript bei Verwendung der Variablen $container hält. Nach
Start des Skripts hält dieses dann auch wirklich im Debugger. Es
wird der Inhalt der Variablen abgefragt und das Listing des
aktuellen Programmcodebereichs ausgegeben (Eingabe l). Die


aktuelle Zeile ist mit einem Stern (*) gekennzeichnet. Mit der
StepOver-Funktion (Eingabe v) werden dann zwei Schritte
übersprungen. Anschließend wird der Inhalt von $objuser
ausgegeben. Zum Schluss wird das Skript fortgesetzt, es läu
aber leider auf einen Fehler.

```
HINWEIS: Haltepunkte bleiben aktiv, solange die
PowerShell-Sitzung läu. Alle aktiven Haltepunkte kann
man mit Get-PSBreakpoint auflisten. Mit Remove-
PSBreakpoint kann man einzelne Haltepunkte unter
Angabe der ID löschen. Get-PSBreakpoint | Remove-
PSBreakpoint löscht alle Haltepunkte.
```

# 22 Transaktionen

Die PowerShell seit Version 2.0 unterstützt Transaktionen. Dies
bedeutet, dass von einer Reihe von Befehlen entweder alle oder
keiner ausgeführt werden. Ein Aufruf von Get-PSProvider zeigt in
der Spalte Capabilities, welche PowerShell-Provider
Transaktionen unterstützen. In der Basisausstattung der
PowerShell ist dies aber leider nur der Registry Provider.

Bild 22.1 In PowerShell unterstützt bisher nur der Registrierungsdatenbankprovider
die PowerShell-Transaktionen.


###### 22.1 Commandlets für

###### Transaktionen

Zur Transaktionssteuerung gibt es vier Commandlets:

```
Start-Transaction: Beginn einer neuen Transaktion
Get-Transaction: zeigt den Status der laufenden Transaktion
Complete-Transaction: Erfolgreiches Ende der Transaktion, d.
h., alle Änderungen werden wirksam.
Undo-Transaction: Rücksetzen auf den Zustand vor der
Transaktion
```
###### 22.2 Start und Ende einer

###### Transaktion

Eine Transaktion wird eingeleitet mit Start-Transaction und
erfolgreich beendet mit Complete-Transaction. Parameter sind
dabei keine notwendig.

Eine Transaktion darf beliebig viele Schritte enthalten. Alle
Befehle, die Teil der Transaktion sein sollen, benötigen den
Zusatzparameter useTransaction. Man sieht nur ein
Zwischenergebnis bei Lesebefehlen, die auch -useTransaction
verwenden; alle Befehle ohne diesen Zusatz arbeiten auf dem
Stand vor der Transaktion.

In dem folgenden Beispiel wird ein
Registrierungsdatenbankschlüssel mit zwei Werten in einer


Transaktion erzeugt.


Listing 22.1 Transaktionsbeispiel
[2_Aufbauwissen/Transaktionen/WPS2_Transaktion__ Registry.ps1]

```
$parent = "HKCU:\Software\"
$keyname = "www.IT-Visions.de"
$key = "HKCU:\Software\" + $keyname
$ErrorActionPreference = "continue"
```
```
if (Test-Path $key )
{ remove-Item $key -Force }
```
```
"Transaktion starten..."
Start-Transaction
```
```
"Transaktionsstatus: " + (Get-Transaction).Status
Test-Path $key -usetransaction
```
```
New-Item -Path $parent -Name $keyname -UseTransaction -Ite
mType key
```
```
New-ItemProperty -path $key -name Name -value "www.IT-Visi
ons.de -
Softwareentwicklung, Technologieberatung, Schulung" - useTr
ansaction
New-ItemProperty -path $key -name Inhaber -value "Dr. Holg
er Schwichtenberg"
–-useTransaction
```
```
# So sieht man den Schlüssel nicht
Test-Path $key
Get-Item $key #führt zu Fehler, der aber Transaktion nicht
abbricht!
```

```
Get-ItemProperty $key "Inhaber" #führt zu Fehler, der aber
die Transaktion nicht
abbricht!
```
```
Unsinn #führt zu Fehler, der aber Transaktion nicht abbric
ht!
```
```
#Get-Item "HCCU:/Unsinn" - UseTransaction #würde zu Abbruch
der Transaktion führen!
```
```
# So sieht man den Schlüssel!
Test-Path $key -UseTransaction
Get-Item $key -UseTransaction
Get-ItemProperty $key "Website" - UseTransaction
```
```
"Transaktion abschließen..."
Complete-Transaction
```
```
# So sieht man den Schlüssel jetzt auch!
Test-Path $key
Get-Item $key
Get-ItemProperty $key "Inhaber"
```
```
"Transaktionsstatus: " + (Get-Transaction).Status
```
###### 22.3 Zurücksetzen der Transaktion

Ein Zurücksetzen auf den Ursprungszustand (Rollback, Abort,
Undo) findet statt, wenn Undo-Transaction aufgerufen wird, die


bei Start-Transaction im Parameter -TimeOut angegebene Zeit
abgelaufen ist oder eines der an der Transaktion beteiligten
Commandlets einen Fehler verursacht. Mit dem Parameter -
Rollbackpreference in Start-Transaction kann man das
Verhalten im Fehlerfall aber ändern. Mögliche Zustände sind:

```
Error: Rücksetzen der Transaktion bei jeder Art von Fehler in
einem der Commandlets, die - usetransaction verwenden
(Standardeinstellung),
Terminating: Rücksetzen der Transaktion nur bei Fehlern, die
zum Abbruch des Befehls führen ("Terminating Errors"),
Never: Die Transaktion wird niemals automatisch
zurückgesetzt.
```
Wichtig: Bei der Frage, ob ein Fehler aufgetreten ist, geht es hier
immer nur um die Commandlets, die -ustransaction verwenden.
In dem folgenden Beispiel wird die Transaktion erfolgreich
beendet, obwohl "unsinn" einen Fehler lieferte.


```
Listing 22.2 Beispiel für Fehler in Transaktionen
[2_Aufbauwissen/Transaktionen/WPS2_Transaktion_Fehler.ps1]
$key = "HKCU:\Software\ix"
```
```
$parent = "HKCU:\Software\"
$keyname = "iX"
$key = "HKCU:\Software\" + $keyname
```
```
"Transaktion starten..."
Start-Transaction
if (Test-Path $key) { remove-Item $key -UseTransaction }
New-Item -Path $parent -Name $keyname -UseTransaction -Ite
mType key
```
```
New-ItemProperty -path $key -name Name -value "iX - Magazi
n für professionelle
```
- Informationstechnik" - useTransaction
New-ItemProperty -path $key -name Website -value "www.ix.d
e" - useTransaction

```
Unsinn #führt zu fehler
```
```
"Transaktion abschließen..."
Complete-Transaction
```
###### 22.4 Mehrere Transaktionen

Man kann Start-Transaction mehrfach aufrufen, dies führt aber
nicht zu unabhängigen Transaktionen. Vor Ende einer


Transaktion gestartete Transaktionen sind Untertransaktionen
(Teiltransaktionen, eingebettete Transaktionen) der
übergeordneten Transaktion.

Die Anzahl der Ebenen sieht man bei Get-Transaction in der
Anzahl "SubscriberCount".

Ein Aufruf von Complete-Transaction in einer Situation mit
Untertransaktion führt zum erfolgreichen Ende der
Untertransaktion. Ein Aufruf von Undo-Transaction in einer
Situation mit Untertransaktion führt zum Abbruch der
Gesamttransaktion (siehe folgende Ab bildung).

Bild 22.2 Beispiel mit mehreren Aufrufen von Start-Transaction


# 23 Standardeinstellungen

# ändern mit Profilskripten

Beim Beenden der PowerShell-Konsole vergisst diese alle
Einstellungen (z. B. geladene Snapins, definierte Aliase, definierte
Funktionen, eingebundene PowerShell-Provider und die
Befehlsgeschichte). Mithilfe sogenannter Profildateien kann man
der PowerShell-Konsole beim Start ihr Gedächtnis zurückgeben.
Profile sind PowerShell-Skripte mit dem Namen "Profile" und der
Dateinamenserweiterung .ps 1.

Eine Profile.ps 1 kann es auf zwei Ebenen geben:

```
Global für alle Benutzer im PowerShell-Installationsordner
Benutzerbezogen im Dateisystemverzeichnis
```
Noch eine weitere Dimension kommt hinzu, weil es Profilskripte
für einen speziellen Power-Shell-Host (also Konsole und ISE)
geben kann, aber auch Profilskripte, die für alle Hosts gelten.

## 23.1 Profilpfade


Die folgende Tabelle zeigt, wie man über die eingebaute Variable
$profile diese Pfade ermitteln kann.

ProfiltypProfilpfad

```
Aktueller Benutzer,
aktueller Host
```
```
$profile.CurrentUserCurrentHost
oder $profile
```
```
Alle Benutzer, aktueller
Host
```
$profile.AllUsersCurrentHost

```
Aktueller Benutzer, alle
Hosts
```
$profile.CurrentUserAllHosts

Alle Benutzer, alle Hosts $profile.AllUsersAllHosts

Die folgende Tabelle nennt alle sechs Profilpfade für die Windows
PowerShell und die ISE.


In einem konkreten PowerShell-Host werden also immer
maximal vier Profilskripte ausgeführt. Diese vier Pfade kann man
auch über eingebaute Variablen ermitteln. (siehe nächstes
Listing).


```
Listing 23.1 [2_Aufbauwissen\Profile\Profilpfade.ps1]
Write-host "Ermitteln der PowerShell-Profilpfade in PowerS
hell $($psversiontable.
psversion)" - ForegroundColor cyan
```
```
Write-host "AllUsersCurrentHost" - ForegroundColor Yellow
$profile.AllUsersCurrentHost
Write-host "CurrentUserCurrentHost" - ForegroundColor Yello
w
$profile.CurrentUserCurrentHost
Write-host "AllUsersAllHosts" - ForegroundColor Yellow
$profile.AllUsersAllHosts
Write-host "CurrentUserAllHosts" - ForegroundColor Yellow
$profile.CurrentUserAllHosts
```
Bild 23.1 Profilpfade in Windows PowerShell auf Windows 10


Bild 23.2 Profilpfade in PowerShell 7 auf Windows 10

###### 23.2 Ausführungsreihenfolge

Die Ausführungsreihenfolge ist so, dass die Profilskripte für alle
Benutzer Vorrang vor den benutzerspezifischen Profilskripten
haben. Zudem haben die Profilskripte für alle Power-Shell-Hosts
Vorrang vor den Profilskripten für den konkreten Host. Es wird
aber kein Profilskript unterdrückt: Alle werden ausgeführt, wie
die folgende Abbildung beweist.

Bild 23.3 Ausführungsreihenfolge der Profilskriptdateien (am Beispiel Windows
PowerShell)

###### 23.3 Beispiel für eine Profildatei


Das folgende Listing zeigt die Profildatei des Autors dieses Buchs.

```
HINWEIS: Erläuterungen zu den geladenen Modulen wie
"Oh-my-Posh", "Terminalicons" und "PSCX" sowie
"ITVisions_PowerShell_Extensions" und finden Sie in den
Kapiteln "PowerShell-Werkzeuge/Erweiterungen der
Konsolen" und "Ausgewählte PowerShell-Erweiterungen".
```

Listing 23.2 Beispiel für eine Profildatei
[2_Aufbauwissen/Profile/Profile.ps1]

```
# --------------------------------------------------------
-------------------
# Profilskript von Dr. Holger Schwichtenberg
# Stand 09.04.2022
# --------------------------------------------------------
-------------------
```
```
function Test-WindowsTerminal { test-path env:WT_SESSION }
# Quelle: https://github.
com/microsoft/terminal/issues/ 6269
```
```
# Titelzeile anpassen
$Wi = [System.Security.Principal.WindowsIdentity]::GetCurr
ent()
$wp = New-Object System.Security.Principal.WindowsPrincipa
l($wi)
if ($wp.IsInRole([System.Security.Principal.WindowsBuiltIn
Role]::Administrator))
{
$Status = "[Admin-Rechte]"
}
else
{
$Status = "[normale Rechte]"
}
```
```
# Module laden
Import-Module ITVisions_PowerShell_Extensions # erfordert
voerherige Installation:
```

https://www.it-visions.de/Scripting/PowerShell/powershellc
ommandletextensions
Import-Module PSCX # erfordert voerherige Installation: h
ttps://www.
powershellgallery.com/packages/Pscx

# Diese Module nur laden, wenn wir in Windows Terminal sin
d
if (Test-WindowsTerminal)
{
Import-Module Terminal-Icons
Import-Module oh-my-posh # erfordert voerherige Installati
on: https://www.
powershellgallery.com/packages/oh-my-posh
oh-my-posh init pwsh | Invoke-Expression
}

# Ausgabe
clear-host
$anz
"Hallo $([System.Environment]::UserName), Deine PowerShell
$($psversiontable.
PSVersion ) ist bereit auf System $([System.Environment]::
MachineName): $status"

#"Anzahl der verfügbaren Module: " + (Get-module -ListAvai
lable).Count
#"Anzahl der geladenen Module: " + (Get-Module).Count
#if ($PSVersionTable.PSEdition -eq "Desktop") { "Anzahl de
r verfügbaren Snap-Ins: " +
(Get-PSSnapin).Count
#"Anzahl der geladenen Snap-Ins: " + (Get-PSSnapin -reg).C


```
ount }
#"Verfügbare Commandlets und Funktionen: "+ ((Get-Comman
d).Count + (dir function:).
Count)
```
Bild 23.4 Start der PowerShell 7 im Windows Terminal mit obigem Profilskript

```
TIPP: Um große Profildateien übersichtlicher zu
gestalten, darf man sie auf mehrere Dateien aueilen und
die einzelnen Dateien dann mit dem Punkt-Operator über
das sogenannte "Dot Sourcing" aus dem Hauptskript (das
immer Profile.ps 1 heißen muss) aufrufen.
```

###### 23.4 Starten der PowerShell ohne

###### Profilskripte

Man kann die Ausführung der Profilskripte unterbinden, indem
man powershell.exe mit dem Parameter -NoProfile aufru:

```
Powershell.exe -NoProfile
```
Zum Starten der PowerShell ISE ohne Laden des Profils gibt es
die gleiche Kommandozeilenoption:

```
PowerShell_ise.exe –NoProfile
```

# 24 Digitale Signaturen für

# PowerShell-Skripte

Im Unternehmenseinsatz sollte man digitale Signaturen
verwenden und die Ausführungsrichtlinie für Skripte auf
"AllSigned" setzen, sodass keine unsignierten Skripte ausgeführt
werden können und somit Sie die volle Kontrolle haben, welche
Skripte ausgeführt werden:

```
Set-ExecutionPolicy AllSigned -force
```
```
ACHTUNG: Dies gilt auch für Profilskripte! Wenn Sie diese
Option aktivieren, müssen auch die Profilskripte signiert
werden, sonst sehen Sie die in der folgenden Abbildung
gezeigte Fehlermeldung.
```

###### 24.1 Zertifikat erstellen

Für das digitale Signieren von Skripten benötigt man zunächst
ein digitales Zertifikat, das den Zweck "Code Signing" besitzt.

Normalweise verwenden Sie entweder ein Zertifikat der
Zertifizierungsstelle Ihres Unternehmens oder Sie können ein
Zertifikat einer öffentlichen Zertifizierungsstelle beantragen, die
Windows bereits kennt (z. B. Deutsche Telekom, GlobalSign,
Thawte, VeriSign).

```
TIPP: Die bekannten Zertifizierungsstellen sehen Sie in
der MMC-Konsole für die Zertifikatsverwaltung unter
"Lokale Computer/Vertrauenswürdige
Stammzertifizierungsstellen" oder per PowerShell: Dir
Cert:\LocalMachine\Root.
```
Wenn Sie kein solches digitales Zertifikat zum Signieren von
Programm- bzw. Skript-Code besitzen, können Sie sich selbst ein
Zertifikat (z. B. mit dem Kommandozeilenwerkzeug
makecert.exe) ausstellen. Ab Windows 8 und Windows Server
2012 gibt es dafür auch ein Commandlet: New-
SelfSignedCertificate. Die ObjectID 1.3.6.1.5.5.7.3.3 legt dabei
den Zweck "Code Signing" fest.

```
New-SelfSignedCertificate -CertStoreLocation 'CERT:\Curren
tuser\MY' - Subject
'CN=IhrName_CodeSigning' - TextExtension "2.5.29.37={text}
1.3.6.1.5.5.7.3.3"
```

```
HINWEIS: Dies ist ein sogenanntes "selbst signiertes"
Zertifikat, d. h., das Zertifikat ist gleichzeitig seine eigene
Zertifizierungsstelle.
```
Ein selbst erstelltes Zertifikat müssen Sie selbst noch in der
Zertifikatsverwaltung als "Vertrauenswürdige
Stammzertifizierungsstelle" und "Vertrauenswürdige
Herausgeber" eintragen. Dies erledigen Sie in der MMC
"Zertifikatsverwaltung" per Drag&Drop bei gedrückter STRG-
Taste oder mit dem nachstehenden PowerShell-Skript.
Wahlweise kopieren Sie das Zertifikat in diese Ordner beim
aktuellen Benutzer oder in dem lokalen Computer.


Bild 24.1 Manuelles Kopieren des Zertifikats


Listing 24.1 [3_Einsatzgebiete\Sicherheitseinstellungen\CopyCertToStore.ps1]

```
# Kopieren eines Zertifikats. Das ist leider nicht möglich
per Copy-Item! "Der
Anbietervorgang wurde beendet, da der Anbieter diesen Vorg
ang nicht unterstützt."
function Copy-Certificate($SourceStoreScope, $SourceStoren
ame, $certname,
$DestStoreScope, $DestStoreName)
{
"Kopiere: " +$cert.Subject + " nach " + $DestStoreScope +
"/" + $DestStoreName
```
```
$SourceStore = New-Object -TypeName System.Security.Crypto
graphy.X 509 Certificates.
X 509 Store -ArgumentList $SourceStorename, $SourceStoreScop
e
$SourceStore.Open([System.Security.Cryptography.X 509 Certif
icates.
OpenFlags]::ReadOnly)
```
```
$certliste = $SourceStore.Certificates | Where-Object {
$_.subject -eq $certname }
```
```
foreach($cert in $certliste)
{
$DestStore = New-Object -TypeName System.Security.Cryptogr
aphy.X 509 Certificates.
X 509 Store -ArgumentList $DestStoreName, $DestStoreScope
$DestStore.Open([System.Security.Cryptography.X 509 Certific
ates.OpenFlags]::ReadWrite)
```

```
$DestStore.Add($cert)
"Kopiert: " +$cert.Subject + " nach " + $DestStore.Locatio
n + "/" + $DestStore.Name
}
}
```
```
$SourceStoreScope = 'CurrentUser'
$SourceStorename = 'My'
$certname = "cn=HS_CodeSign"
$DestStoreScope = 'LocalMachine'
$DestStoreName = 'root'
Copy-Certificate $SourceStoreScope $SourceStorename $certn
ame $DestStoreScope
$DestStoreName
```
```
$SourceStoreScope = 'CurrentUser'
$SourceStorename = 'My'
$certname = "cn=HS_CodeSign"
$DestStoreScope = 'LocalMachine'
$DestStoreName = 'Trustedpublisher'
Copy-Certificate $SourceStoreScope $SourceStorename $certn
ame $DestStoreScope
$DestStoreName
```
###### 24.2 Skripte signieren

Zum Signieren von PowerShell-Skripten bietet die PowerShell
das Commandlet Set-AuthenticodeSignature. Um ein Skript zu
signieren, müssen Sie die folgenden Schritte ausführen:


Laden Sie das gewünschte Zertifikat (das den Zweck "Code
Signing" besitzt):

```
$cert = (dir "cert:/currentuser/my/") | where Subject -eq
"CN=HS_CodeSigning"
```
Eine weitere Variante ist es, eine Zertifikatsdatei mit Public
und Private Key (.pfx) von der Festplatte zu laden:

```
$cert = Get-PfxCertificate "x:\meineZertifikate\HS_CodeSig
ning.pfx"
```
Signieren Sie das Skript dann mit dem auf eine der o. g.
Weisen geladenen Schlüssel:

```
Set-AuthenticodeSignature x:\Pfad\Skript.ps 1 $cert
```

Bild 24.2 Vergrößerung der Skript-Datei durch eine digitale Signatur

```
HINWEIS: Es kann pro Skript nur eine Signatur geben. Das
sogenannte "Co-Signing" mehrerer Personen (Vier-Augen-
Prinzip) wird nicht unterstützt.
```
###### 24.3 Verwenden signierter Skripte


Wenn Sie nun Set-ExecutionPolicy AllSigned eingeben, sollte
das von Ihnen signierte PowerShell-Skript dennoch laufen, alle
unsignierten Skripte aber nicht mehr. Mit Get-
AuthenticodeSignature können Sie die digitale Signatur testen,
ohne das Skript auszuführen.

Bild 24.3 Testen und Ausführen von Skripten mit digitaler Signatur

###### 24.4 Mögliche Fehlerquellen

Falls ein Skript zwar signiert ist, aber die Signatur von einer nicht
vertrauten Zertifizierungsstelle kommt, erhalten Sie den
Laufzeitfehler: "Die Datei kann nicht geladen werden. Eine
Zertifikatkette wurde zwar verarbeitet, endete jedoch mit einem
Stammzertifikat, das beim Vertrauensanbieter nicht als
vertrauenswürdig gilt." Bei einem selbst signierten Zertifikat fehlt
dann der oben erwähnte Zertifikatskopiervorgang.

Falls die PowerShell beim Start des Skripts noch einmal
nachfragt, ob Sie das Skript wirklich laufen lassen wollen, dann
bedeutet dies, dass das Skript zwar von jemandem signiert ist
und Sie die Zertifizierungsstelle, die das Zertifikat ausgestellt hat,


in Ihrer Stammzertifizierungsstelle kennen, aber dass Sie diesem
Skriptautor noch nicht explizit vertrauen. (Bei einem selbst
signierten Zertifikat fehlt dann der oben erwähnte
Zertifikatskopiervorgang.) Durch die Option "Always Run" würde
der Skriptautor unter die "Vertrauenswürdigen Herausgeber" in
die Zertifikatsverwaltung aufgenommen werden.

Bild 24.4 Nachfrage bei fehlendem Vertrauen in den Herausgeber

Wenn Sie ein signiertes Skript modifizieren, selbst wenn es nur
eine kleinste Kleinigkeit ist, müssen Sie die Signatur immer
erneuern. Sonst erhalten Sie den Laufzeitfehler: "Skript kann
nicht geladen werden. Der Inhalt der Datei wurde
möglicherweise von einem nicht autorisierten Benutzer oder
Prozess manipuliert, da der Hash der Datei nicht mit dem in der
digitalen Signatur gespeicherten Hash übereinstimmt. Das Skript
wird auf dem angegebenen System nicht ausgeführt."


# 25 Hintergrundauräge

# ("Jobs")

PowerShell bietet schon seit der Version 2.0 die Möglichkeit,
Befehle und Skripte im Hintergrund auszuführen, ohne dass es
während der Ausführungszeit eine Interaktion mit der aktuellen
PowerShell-Sitzung gibt. Hintergrundauräge blockieren die
aktuelle PowerShell-Sitzung nicht, d. h., der Benutzer kann
währenddessen andere Befehle eingeben. Hintergrundauräge
bieten sich also insbesondere für lang dauernde Befehle und
Skripte an.

Folgende Commandlets sind für die Handhabung der
Hintergrundauräge implementiert:

```
Start-Job: Start eines Hintergrundaurags
Get-Job: Liste aller laufenden und abgeschlossenen
Hintergrundauräge
Receive-Job: Zugriff auf das Ergebnis eines
Hintergrundaurags
Stop-Job: Beenden eines Hintergrundaurags
Wait-Job: Warten auf das Ende eines Hintergrundaurags
```

Remove-Job: Entfernen eines Hintergrundaurags

###### 25.1 Voraussetzungen

Die PowerShell muss für die Fernausführung konfiguriert sein,
auch wenn die Hintergrundauräge auf dem gleichen Rechner
laufen. Hintergrund ist, dass die Kommunikation zwischen
Hauptprozess und den Hintergrundprozessen für die
Hintergrundauräge auch über WS-Management erfolgt.

Details lesen Sie bitte im Kapitel 10 "Fernausführung
(Remoting)".

###### 25.2 Architektur

Jobs laufen grundsätzlich in einem eigenen Prozess
(powershell.exe). Die Kommunikation zwischen aufrufendem
PowerShell-Prozess und dem ausführenden PowerShell-Prozess
erfolgt über WinRM (siehe Kapitel 10 "Fernausführung
(Remoting"). Bei lokalen Hintergrundaurägen erfolgt die
Kommunikation zwischen aufrufendem PowerShell-Prozess und
dem ausführenden PowerShell-Prozess durch den IPC-Kanal, im
entfernten Fall über HTTP.


Bild 25.1 Durch den Start des Hintergrundaurags wurde eine neue Instanz der
powershell.exe gestartet.

###### 25.3 Starten eines

###### Hintergrundaurags

Einen Hintergrundaurag startet der Administrator über Start-
Job oder Invoke-Command -AsJob.

```
start-job -scriptblock { Get-ChildItem c:\Windows -recurs
e}
```
Start-Job liefert als Ergebnis eine Instanz der Klasse
System.Management.Automation. PSRemotingJob.

Beispiel:


Der folgende Befehl erstellt eine Statistik über alle DLLs im
Windows-Installationsverzeichnis und dauert in der Regel
mehrere Sekunden:

```
Get-ChildItem c:\Windows *.dll -recurse -ea silentlycontin
ue | measure length
```
- min -max -sum -average

Es bietet sich an, diesen Befehl als Job zu starten:

```
$cmd = { Get-ChildItem c:\Windows *.dll -recurse -ea silen
tlycontinue | measure
length -min -max -sum -average }
$job = Start-Job -scriptblock $cmd -Name DLLStatistics
```
###### 25.4 Hintergrundauräge abfragen

Das von Start-Job gelieferte PSRemotingJob-Objekt dient der
weiteren Nutzung des Aurags.

```
$job = Start-Job -scriptblock $cmd -Name DLLStatistics
```
Das commandlet Get-Job liefert den Zustand aller
Hintergrundauräge. Es gibt die Status: Running, Failed, Stopped
und Completed.

Das Ergebnis des Hintergrundaurags, also den Inhalt der
Pipeline nach der Ausführung, kann man abrufen über:

```
Receive-Job $job
```

Bild 25.2 Ausführen und Auswerten eines Hintergrundaurags

```
HINWEIS: Genau wie bei der Fernausführung findet auch
bei Hintergrundaurägen eine
Serialisierung/Deserialisierung statt, so dass die
Ergebnisobjekte keine Methoden mehr besitzen.
```
Bild 25.3 Inhalt der Pipeline nach Receive-Job

Receive-Job kann auch ausgeführt werden, wenn der Aurag
noch läu. Receive-Job liefert dann alle bis dahin von dem
Aurag erzeugten Ergebnisobjekte. Bei weiteren Aufrufen von


Receive-Job werden dann nur noch die verbliebenen Objekte
geliefert.

```
TIPP: Mit dem Parameter -keep in Receive-Job kann man
erreichen, dass bereits abgerufene Ergebnisse erneut
abgerufen werden können.
```
###### 25.5 Warten auf einen

###### Hintergrundaurag

Mit Wait-Job kann man auf die Fertigstellung eines
Hintergrundaurags warten. Dabei kann man optional angeben,
wie lange man warten möchte (Timeout in Sekunden):

```
Wait-Job -ID 10 - timeout 60
```
###### 25.6 Abbrechen und Löschen von

###### Aurägen

Einen Hintergrundaurag kann man mit Stop-Job vorzeitig
beenden:

```
Stop-Job -id 23 # Abbrechen des Auftrags Nummer 23
Stop-Job $job # Abbrechen anhand des Auftragsobjekts
```

Der Aurag wird dann in der Auragsliste als "Stopped"
angezeigt.

Mit Remove-Job kann man Auräge aus der Auragsliste löschen:

```
Remove-Job -job 23
Remove-Job $job
```
```
HINWEIS: Man kann Auräge nur löschen, wenn diese im
Status "Stopped" oder "Completed" sind.
```
###### 25.7 Analyse von Fehlermeldungen

Die Ursache für einen fehlgeschlagenen Hintergrundaurag kann
man auslesen über:

```
$job.ChildJobs[ 0 ].JobStateInfo.Reason
```
In vielen Fällen sieht man den Fehler aber auch über Receive-Job.

###### 25.8 Fernausführung von

###### Hintergrundaurägen

Auch Fernaufrufe kann man als Hintergrundauräge starten.
Gerade bei langsamen Verbindungen bzw. vielen abzufragenden


Computern bietet sich dies an. Hier kommt Invoke-Command mit
dem Parameter AsJob (und optional -JobName) zum Einsatz.

```
Invoke-Command -computername F 170 - scriptblock { Get-Child
Item c:\windows *.dll
```
- recurse } - asjob -JobName "DLL_List"

Wahlweise kann man hier über -ComputerName eine temporäre
Sitzung öffnen oder über Start-PSSession vorher eine
permanente Sitzung.

Den Status des Hintergrundaurags kann man, wie bei lokalen
Aurägen, über Get-Job abfragen. Das Attribut Location zeigt
dann den entfernten Rechnernamen. Auch die Steuerung über
Receive-Job, Stop-Job und Remove-Job steht zur Verfügung.

Bild 25.4 Fernausführung eines Hintergrundaurags

###### 25.9 Praxislösung: Einen Job auf

###### mehreren Computern starten


In der folgenden Praxislösung wird ein Job auf insgesamt fünf
Computern parallel gestartet. Die einzelnen Job-Objekte werden
in einem Array für die spätere Auswertung gemerkt.


Listing 25.1 [2_Aufbauwissen\Jobs\WPS_Jobs_Remote.ps1]

```
function print($s)
{
Write-host $s -ForegroundColor green
}
```
```
$computerList = 'D141','D142','D143','D144','D145'
$meineJobs = @()
```
```
foreach($c in $computerList)
{
Write-Host "Starte Job auf $c"
$j = Invoke-Command -scriptblock { Get-ChildItem c:\Windo
ws | Measure-Object }
```
- ComputerName $c -AsJob
$j | ft
$meineJobs += $j
}

```
Write-Host "tue irgendwas anderes für 3 Sekunden ..."
Start-Sleep -Seconds 3
```
```
Write-Host "Jobstatus nun:"
foreach($j in $meineJobs)
{
$j
}
```
```
foreach($j in $meineJobs)
{
Write-Host "Ergebnis von Job $($j.id) auf Computer $($j.Lo
```

```
cation)"
receive-job $j -Wait | ft
}
```
Die folgende Abbildung zeigt den Ablauf des Skripts nur für zwei
PCs, da sonst die Ausgabe zu lang würde für den Abdruck im
Buch.

Bild 25.5 Ausgabe des obigen Skripts


# 26 Geplante Aufgaben und

# zeitgesteuerte Jobs

von Peter Monadjemi

Eine geplante Aufgabe ermöglicht das Ausführen von Aufgaben,
wie das Durchführen eines Backups oder die Defragmentierung
eines Laufwerks, zu bestimmten Zeitpunkten und/oder in
festgelegten Intervallen. Geplante Aufgaben (im Original
"Scheduled Tasks") sind seit Windows NT 4 eine Eigenscha des
Betriebssystems. In der Vergangenheit war das automatisierte
Anlegen von geplanten Aufgaben mit Hilfe der PowerShell nur auf
Umwegen möglich. Seit Windows Server 2012 und Windows 8
gibt es dafür das Modul ScheduledTasks mit dessen Commandlets
der Umgang mit geplanten Aufgaben sehr einfach wird.

Ein zeitgesteuerter Job ist ein regulärer PowerShell-Job, der auf
einer geplanten Aufgabe basiert und damit ebenfalls zu einem
bestimmten Zeitpunkt und/oder in festgelegten Intervallen
ausgeführt wird. Für den Umgang mit zeitgesteuerten Jobs gibt
es seit Windows 8 und Windows Server 2012 das Modul
PSScheduledJob.


Beide Module erfüllen unterschiedliche Anforderungen,
wenngleich es Überschneidungen gibt. Über eine geplante
Aufgabe wird eine beliebige Windows-Anwendung zeitgesteuert
ausgeführt – das kann natürlich auch die PowerShell sein, die auf
diese Weise ein Skript unter einem bestimmten Benutzerkonto
ausführt. Über einen zeitgesteuerten Job wird ein Power-Shell-
Job (auf der Grundlage einer geplanten Aufgabe) zeitgesteuert
ausgeführt. Das werden in der Regel Commandlets, Funktionen
und andere PowerShell-Befehle sein, wobei ein Job, z. B. über
das Start-Process-Commandlet, natürlich auch eine beliebige
Windows-Anwendung starten kann. Geplante Aufgaben werden
auf der Ebene des Betriebssystems eingesetzt, zeitgesteuerte
Jobs sind zwar stets Teil eines PowerShell-Skripts, doch auch sie
werden vom Betriebssystem verwaltet, da sie auf geplanten
Aufgaben basieren, die eine PowerShell- Sitzung starten, um den
Job ausführen zu können. Die PowerShell-Konsole muss daher
nicht ausgeführt werden, damit ein zeitgesteuerter Job laufen
kann.

###### 26.1 Geplante Aufgaben (Scheduled

###### Tasks)

Eine geplante Aufgabe (engl. "Scheduled Tasks") ist eine
Funktion des Windows-Betriebssystems. Bis zur PowerShell-
Version 3.0 wurden geplante Aufgaben in erster Linie manuell
über das Verwaltungsprogramm Aufgabenplanung angelegt. Als
Alternativen standen in der Vergangenheit benutzerdefinierte
Commandlets, die auf COM-Schnittstellen basieren, oder das
Befehlszeilentool Schtasks.exe zur Verfügung. Seit Windows


Server 2012/R 2 und Windows 8.x spielen diese Varianten im
Zusammenhang mit der PowerShell keine Rolle mehr, denn für
den Umgang mit geplanten Aufgaben gibt es das Modul
ScheduledTasks mit insgesamt 19 Commandlets.

```
HINWEIS: Das Modul ScheduledTasks steht erst ab
Windows Server 2012/R 2 und Windows 8.x zur Verfügung.
```
Geplante Aufgaben anlegen

Das Anlegen einer geplanten Aufgabe ist in der Regel ein
mehrstufiger Prozess. Im ersten Schritt wird mit dem New-
ScheduledTaskAction-Commandlet die Aktion festgelegt, die
später im Rahmen der geplanten Aufgabe ausgeführt werden
soll.

```
BEISPIEL: Der folgende Befehl legt über New-
ScheduledTaskAction eine Aktion an, die die PowerShell
startet, um ein vorbereitetes Skript auszuführen. Das
Ergebnis wird einer Variablen zugewiesen. Damit der
Befehl ausgeführt werden kann, muss der Pfad der Ps1-
Datei entsprechend angepasst werden.
```
```
$TaskAction = New-ScheduledTaskAction -Execute powe
rshell.exe -Argument
"-NoProfile -File x:\Skripte\PsWriteFile.ps1"
```

Im zweiten Schritt wird mit dem New-ScheduledTaskTrigger-
Commandlet ein Task-Trigger angelegt, der den Zeitpunkt
festgelegt, an dem die geplante Aufgabe ausgeführt werden soll.
Das resultierende Objekt wird wieder einer Variablen
zugewiesen:

```
$TaskTrigger = New-ScheduledTaskTrigger -At (Get-Date).Add
Minutes( 1 ) - Once
```
Soll die Aufgabe unter einem anderen Benutzerkonto ausführen,
kann der erforderliche "Security Principal" über das New-
ScheduledTaskPrincipal-Commandlet angelegt werden.
Benutzername und das dazugehörige Kennwort können aber
auch direkt angegeben werden.

Im dritten und letzten Schritt wird die geplante Aufgabe über das
Register-ScheduledTask-Commandlet registriert:

```
Register-ScheduledTask -TaskName PSTest -Trigger $TaskTrig
ger -Action $TaskAction
```
- User "\PsUser" - Password "Pa`$`$w 0 rd


BEISPIEL: Das folgende Skript fasst die einzelnen Schritte
zum Anlegen einer geplanten Aufgabe noch einmal
zusammen. Vorsorglich wird die Aufgabe "PsTest" zu
Beginn über Unregister-ScheduledTask entfernt.

```
<#
.Synopsis
Anlegen einer geplanten Aufgabe
#>
# Für alle Fälle Task durch Abmelden entfernen
```
```
Unregister-ScheduledTask -TaskName PsTest -ErrorAct
ion SilentlyContinue
```
- Confirm:$False

```
$Ps 1 Path = "x:\Skripte\PsWriteFile.ps1"
```
```
$TaskAction = New-ScheduledTaskAction -Execute "pow
ershell.exe
```
- Argument -NoProfile -File $Ps 1 Path -WorkingDirec
tory $(Split-Path -Path
$Ps 1 Path)"

```
$TaskTrigger = New-ScheduledTaskTrigger -At (Get-Da
te).AddMinutes( 1 ) - Once
```
```
Register-ScheduledTask -TaskName PSTest -Trigger $T
askTrigger -Action
$TaskAction
```

```
Die neue geplante Aufgabe erscheint danach in der
Aufgabenplanung. Da beim Anlegen über den TaskPath-
Parameter kein Pfad angegeben wurde, erscheint sie auf
der obersten Ebene unter "Aufgabenplanungsbibliothek".
Da der Sicherheitskontext bei der Ausführung der
geplanten Aufgaben keine Rolle spielt, hätte das Beispiel
auch mit einem zeitgesteuerten Job umgesetzt werden
können.
```
```
Bild 26.1 Die geplante Aufgabe wurde angelegt.
```
Spezielle Einstellungen festlegen

Über das Commandlet New-ScheduledTaskSettingsSet werden
spezielle Einstellungen festgelegt, die die Ausführung der
geplanten Aufgabe betreffen. Das resultierende Objekt wird dem
Settings-Parameter von Register-ScheduledTask übergeben. Es
steht eine Fülle von Einstellungen zur Auswahl, die alle ein
Pendant in den Eigenschaen einer Aufgabe im Rahmen der
Aufgabenplanung besitzen. Die folgende Tabelle stellt einige der
Einstellungen, die über gleichnamige Parameter gesetzt werden,
zusammen.


Tabelle 26.1 Einige der Einstellungen, die für eine geplante Aufgabe festgelegt
werden können

Einstellung Bedeutung

```
AllowStartIfOnBatteries Die Aufgabe startet auch dann,
wenn der Computer nicht am
Stromnetz angeschlossen ist.
```
```
DisallowDemandStart Die Aufgabe kann nicht explizit
(z. B. im Rahmen der
Aufgabenverwaltung) gestartet
werden.
```
```
DisallowHardTerminate Die Aufgabe kann nicht über
den Task-Manager beendet
werden.
```
```
DontStopIfGoingOnBatteries Die Aufgabe soll nicht
angehalten werden, wenn der
Computer nicht mehr am
Stromnetz angeschlossen ist.
```
```
Hidden Die Aufgabe wird in der
Aufgabenplanung nicht
angezeigt.
```
```
NetworkName Spielt im Zusammenspiel mit
dem
RunOnlyIfNetworkAvailable
eine Rolle und legt den Namen
eines Netzwerkprofils fest, das
herangezogen wird, um
```

```
festzustellen, ob die Ausgabe
ausführen kann.
```
```
Priority Legt eine Prioritätsstufe von 1
(niedrig) bis 10 für die Aufgabe
fest. Der Default-Wert ist 7.
```
```
RunOnlyIfNetworkAvailable Die Aufgabe wird nur bei einer
aktiven Netzwerkverbindung
gestartet.
```
Vorhandene geplante Aufgaben verwalten

Über das Get-ScheduledTask-Commandlet erhält man alle
geplanten Aufgaben zurück (natürlich auch jene, die außerhalb
der PowerShell angelegt wurden). Da der TaskName-Parameter
Platzhalter akzeptiert, lassen sich Aufgaben über ihren Namen
einfach lokalisieren.

```
BEISPIEL: Der folgende Befehl listet alle Aufgaben auf, die
mit der Silbe "PS" beginnen.
Get-ScheduledTask -TaskName PS*
```
Die Details zu einem einzelnen Task liefert das Get-
ScheduledTaskInfo-Commandlet. Der folgende Befehl gibt Details
wie die letzte Ausführungszeit einer geplanten Aufgabe zurück:


```
Get-ScheduledTaskInfo -TaskName PSTest
```
Geplante Aufgaben auf einem

ausfallsicheren Rechnerverbund ("fail over

cluster") ausführen

Eine geplante Aufgabe kann auch auf einem ausfallsicheren
Rechnerverbund ("failover cluster") ausgeführt werden. Dazu
wird die Aufgabe mit dem Register-ClusteredScheduled-Task-
Commandlet registriert. Der Name des Clusters wird über den
Cluster-Parameter festgelegt. Über den TaskType-Parameter wird
die Art des Rechnerverbunds bestimmt. Zur Auswahl stehen
"ResourceSpecific", "AnyNode" und "ClusterWide".

###### 26.2 Zeitgesteuerte Jobs

Ein zeitgesteuerter Job (engl. "Scheduled Job") unterscheidet
sich von einem regulären Job dadurch, dass er zu einem
festgelegten Zeitpunkt und/oder in einem festgelegten Intervall
startet. Die Grundlage dafür ist (natürlich) eine geplante Aufgabe.
Sie legt eine neue Power-Shell-Sitzung über den Start von
Powershell.exe an und führt über den Command-Parameter das
Skript bzw. den Skriptblock aus. Zeitgesteuerte Jobs und
geplante Aufgaben sind damit zwar eng verwandt, decken aber
trotzdem verschiedene Anforderungsbereiche ab. Für den
Umgang mit zeitgesteuerten Jobs stellt die PowerShell (ab
Windows 7 und Windows Server 2008/R2) das Modul


PSScheduledJob mit insgesamt 16 Commandlets zur Verfügung.
Sechs davon kümmern sich um das Verwalten zeitgesteuerter
Jobs (Tabelle 26.2), sieben Commandlets um den Umgang mit
Job-Triggern und die restlichen drei um Optionen, die bei einem
zeitgesteuerten Job zusätzlich gesetzt werden können.

```
HINWEIS: Das Modul "PSScheduledJob" ist
gekennzeichnet als ein Modul, das nicht unter PowerShell
7 läu. Einzelne Commandlets wie Get-ScheduledJob
laufen zwar, aber es kam in Versuchen zu Problemen beim
Anlegen von Jobs. Skripte, die unter Windows PowerShell
einwandfrei funktionierten, liefen nicht mit PowerShell 7.
```

Tabelle 26.2 Die Commandlets für den Umgang mit zeitgesteuerten Jobs

Commandlet Bedeutung

```
Disable-
ScheduledJob
```
Deaktiviert einen zeitgesteuerten Job.

```
Enable-
ScheduledJob
```
```
Aktiviert einen nicht aktiven
zeitgesteuerten Job.
```
```
Get-
ScheduledJob
```
```
Holt alle vorhandenen zeitgesteuerten
Jobs.
```
```
Register-
ScheduleJob
```
Legt einen neuen zeitgesteuerten Job an.

```
Set-
ScheduledJob
```
```
Ändert einzelne Einstellungen eines
zeitgesteuerten Jobs.
```
```
Unregister-
ScheduleJob
```
Entfernt einen zeitgesteuerten Job.

Die Rolle der Job-Trigger

Grundlage für einen zeitgesteuerten Job ist der sog. "Job-
Trigger" (Trigger = "Schalter"). Dieser wird über das Commandlet
New-JobTrigger angelegt. Ein Job-Trigger steht für einen
bestimmten Zeitpunkt und/oder ein Zeitintervall und wird einem
zeitgesteuerten Job beim Registrieren zugeordnet. Für den
Umgang mit Job-Triggern enthält das Modul ScheduleJobs sieben
Commandlets (Tabelle 26.3). Praktisch ist, dass sich ein Job-
Trigger vorübergehend deaktivieren lässt. Damit kann man


erreichen, dass ein Job vorübergehend nicht zu einem
festgelegten Zeitpunkt gestartet wird. Um einen zeitgesteuerten
Job anzulegen, legt man zuerst per New-JobTrigger-Commandlet
einen oder mehrere Job-Trigger an und weist diese einem Job zu,
der per Register-ScheduledJob-Commandlet angelegt wird.

Tabelle 26.3 Die Commandlets aus dem Modul ScheduledJobs für den Umgang mit
Job-Trigger

Commandlet Bedeutung

```
Add-
JobTrigger
```
```
Fügt einem zeitgesteuerten Job einen
weiteren Job-Trigger hinzu.
```
```
Disable-
JobTrigger
```
```
Deaktiviert einen Job-Trigger bei einem
zeitgesteuerten Job.
```
```
Enable-
JobTrigger
```
```
Aktiviert einen Job-Trigger bei einem
zeitgesteuerten Job.
```
```
Get-
JobTrigger
```
```
Holt alle Job-Trigger, die bereits
zeitgesteuerten Jobs zugeordnet wurden.
```
```
New-
JobTrigger
```
Legt einen neuen Job-Trigger an.

```
Remove-
JobTrigger
```
```
Entfernt einen Job-Trigger von einem
zeitgesteuerten Job.
```
```
Set-
JobTrigger
```
```
Ändert einzelne Einstellungen eines
vorhandenen Job-Triggers.
```

BEISPIEL: Der folgende Befehl legt einen Job-Trigger für
die Uhrzeit 23:00 an. Über den Switch-Parameter Once
wird angegeben, dass der Job-Trigger nur einmal aktiv
werden soll. Das resultierende Objekt (vom Typ
ScheduledJobTrigger) wird einer Variablen zugewiesen,
damit diese später beim Registrieren des zeitgesteuerten
Jobs angegeben werden kann:

```
$Tr 23 Uhr = New-JobTrigger -At 23:00 - Once
```

```
BEISPIEL: Der folgende Befehl legt einen Job-Trigger an,
der jeden Sonntag um 0 Uhr aktiv wird. Der Switch-
Parameter Weekly sorgt dafür, dass der Job wöchentlich
ausgeführt wird.
$SoNacht = New-JobTrigger -At 00:00 - DaysOfWeek
Sunday -Weekly
Dank der Auswahllisten der PowerShell ISE (seit Version
3.0) ist die Auswahl der Parameterwerte wie z. B. die der
Wochentage beim Parameter DaysOfWeek sehr einfach.
```
```
Bild 26.2 Die Auswahllisten der PowerShell ISE erleichtern die Auswahl für
einen Parameterwert.
```
Grundsätzlich können einem zeitgesteuerten Job mehrere Job-
Trigger zugewiesen werden, wenn dieser zu unterschiedlichen
Zeitpunkten und/oder in unterschiedlichen Intervallen starten
soll.

Das Auflisten aller Job-Trigger, die bereits einem zeitgesteuerten
Job zugeordnet wurden, erledigt das Get-JobTrigger-


Commandlet. Jene Job-Trigger, die einem Job zugeordnet
wurden, erhält man über dessen JobTriggers-Eigenscha.

```
BEISPIEL: Der folgende Befehl listet die Job-Trigger des
zeitgesteuerten Jobs mit der Id 1 auf.
```
```
Get-ScheduledJob -Id 1 | Select-Object -ExpandPrope
rty JobTriggers
```
Jobs sofort starten

Neu seit PowerShell-Version 4.0 ist bei den Commandlets
Register-ScheduledJob und Set-ScheduledJob der Parameter -
RunNow, der einen Job sofort startet. Ein Trigger ist optional
zusätzlich möglich.

```
$SoNacht = New-JobTrigger -At 00:00 - DaysOfWeek Sunday -We
ekly
$SB = { "Dieser Job läuft unter Thread-ID: $([System.Threa
ding.
Thread]::CurrentThread.ManagedThreadId)" | Set-Content
w:\temp\job.txt }
$SJob = Register-ScheduledJob -ScriptBlock $SB -Name TestJ
ob 2 - RunNow -Trigger
$SoNacht
```

Zeitgesteuerte Jobs anlegen

Ein zeitgesteuerter Job wird über das Commandlet Register-
ScheduledJob angelegt (und entsprechend über das Commandlet
Unregister-ScheduledJob wieder entfernt). Dabei werden ein
Name, ein oder mehrere Job-Trigger und entweder der Pfad
einer Skriptdatei oder ein Skriptblock als Parameterwerte
übergeben. Das Ergebnis ist ein Objekt vom Typ
ScheduledJobDefinition (im Namensraum
Microsoft.PowerShell.ScheduledJob). Damit der Job auch dann
starten kann, wenn die PowerShell-Sitzung längst beendet wurde
(und sich der Computer eventuell im Ruhezustand befindet),
wird eine geplante Aufgabe ("Scheduled Task") angelegt, die in
der Aufgabenplanung (MMC "Task Scheduler") von Windows im
Pfad \Microsoft\Windows\PowerShell\ScheduledJobs\ erscheint.
Zum festgelegten Zeitpunkt wird der Job über die geplante
Aufgabe gestartet und kann danach über die Job-Commandlets
wie Get-Job oder Receive-Job angesprochen werden. Ausgeführt
werden können alle Befehle, die keine interaktive Shell erfordern.
Nicht möglich ist daher das Starten von Windows-Anwendungen
(der Prozess wird gestartet, das Anwendungsfenster wird aber
nicht angezeigt) oder das Anzeigen von Meldungsboxen.

```
HINWEIS: Beim Ausgeben von Meldungen während der
Ausführung eines Jobs muss berücksichtigt werden, dass
die Anzeige von Mitteilungsboxen über [System.
Windows.Forms.Messagebox]::Show() nicht möglich ist.
```

BEISPIEL: Im folgenden Beispiel wird ein zeitgesteuerter
Job angelegt, der eine Minute später eine Meldung (und
die interne Thread-ID) ausgibt. Um die Befehlsfolge
ausführen zu können, muss die PowerShell explizit als
Administrator gestartet werden.

```
$TrGleich = New-JobTrigger -At ((Get-Date) + (New-T
imeSpan -Minutes 1 ))
```
- Once
$SB = { "Thread-ID: $([System.Threading.Thread]::Cu
rrentThread.
ManagedThreadId)" }
$SJob = Register-ScheduledJob -ScriptBlock $SB -Tri
gger $TrGleich -Name
Meldung

Bild 26.3 Für einen zeitgesteuerten Job wird eine geplante Aufgabe
angelegt.


BEISPIEL: Im folgenden Beispiel wird ein zeitgesteuerter
Job angelegt, der (jeden Sonntag um Mitternacht) ein
Skript ausführt, das alle .ps1-Dateien in einem Verzeichnis
in eine Netzwerkfreigabe sichert.

```
$SoNacht = New-JobTrigger -At 00:00 - DaysOfWeek Sun
day –Weekly
$SJob 1 = - Register-ScheduledJob -FilePath x:\Backu
p.ps1-Trigger $SoNacht
```
- Name -Ps 1 Backup

Das Skript Backup.ps 1 soll, auch wenn es nicht direkt zum
Thema des Kapitels passt, der Vollständigkeit halber
vollständig abgedruckt werden. Damit es ausgeführt
werden kann, müssen die Variablen $PS 1 Path,
$PS 1 SharePath und $ShareUserName angepasst werden. Das
Skript geht davon aus, dass die Freigabe durch ein
Kennwort geschützt ist, das während der Ausführung des
Skripts abgefragt wird. Außerdem muss das Skript explizit
als Administrator ausgeführt werden.


<#
.Synopsis
Sichern aller Ps1-Dateien auf eine Netzwerkfreigab
e
#>

$VerbosePreference = "Continue"

$PS 1 Path = "x:\PowerShell"
$ShareUserName = "Admin"
$PS 1 SharePath = "\\192.168.2.138\\PowerShellSkripte
\\PS 1 Backup"
$PSEventSourceName = "PS 1 Backup"
# Wenn die Eventquelle PSBackup nicht existiert dan
n anlegen
if (![System.Diagnostics.Eventlog]::SourceExists($P
SEventSourceName))
{
New-EventLog -LogName Application -Source $PSEven
tSourceName
}

# Wenn Netzwerklaufwerk nicht existiert dann anlege
n
if (-Not (Get-PSDrive -Name PS 1 Share -ErrorAction S
ilentlyContinue))
{
New-PSDrive -Name PS 1 Share -Root $PS 1 SharePath -P
SProvider FileSystem

- Credential $ShareUserName | Out-Null
}


```
Write-EventLog -LogName Application -Source $PSEven
tSourceName -EntryType
Information -EventId 100 - Message "Backup wird gest
artet."
Write-Verbose -Message "Backup wird gestartet."
```
```
$CopyResult = Get-ChildItem -Path $PS 1 Path -File -I
nclude *.ps 1 - Recurse |
Copy-item -Destination PS 1 Share: - PassThru
```
```
Write-EventLog -LogName Application -Source $PSEven
tSourceName -EntryType
Information -EventId 100 - Message "Backup wurde abg
eschlossen –
$($CopyResult.Count) Skripte wurden gesichert."
Write-Verbose -Message "Backup wurde beendet"
```
```
$VerbosePreference = "SilentlyContinue"
```
Spezielle Optionen bei zeitgesteuerten Jobs

Über das Commandlet New-ScheduledJobOption werden einem
zeitgesteuerten Job eine Reihe von "Spezialeinstellungen" mit
auf den Weg gegeben, die in Tabelle 29.4 anhand der Parameter
dieses Commandlets zusammengestellt sind. Diese Parameter
sind notwendig, da z. B. nicht vorausgesetzt werden kann, dass
der Computer zum Zeitpunkt, wenn ein zeitgesteuerter Job


starten soll, eingeschaltet ist oder eine Netzwerkverbindung zur
Verfügung steht. Auch der Umstand, dass ein mobiler Computer
nicht an das Stromnetz angeschlossen sein muss, wird durch
einen Parameter berücksichtigt.

```
BEISPIEL: Der folgende Befehl startet einen Job so, dass
die dem Job zugrunde liegende Aufgabe in der
Aufgabenverwaltung von Windows ausgeblendet wird.
```
```
$TrGleich = New-JobTrigger -At ((Get-Date) + (New-T
imeSpan -Minutes 1 ))
```
- Once
$SB = { del c:\Temp }
$SesOpt = New-ScheduledJobOption -HideInTaskSchedul
er
$J 1 = Register-ScheduledJob -ScriptBlock $SB – Name
TestJob -Trigger
$TrGleich -ScheduledJobOption $SesOpt


Tabelle 26.4 Die wichtigsten Parameter des Commandlets New-ScheduledJobOption

Parameter Bewirkt, dass...

```
RunElevated... der Job mit erweiterten
Administratorberechtigungen
ausgeführt wird. Dazu muss dem
Credential-Parameter eine
Administratorbenutzerkennung
übergeben werden.
```
```
HideInTaskScheduler... der Job in der Aufgabenplanung
als "ausgeblendete Aufgabe"
geführt wird und daher nur dann
erscheint, wenn die Einstellung
"Ausgeblendete Aufgaben
einblenden" gesetzt ist.
```
```
RestartOnIdleResume... der Job fortgesetzt wird, wenn
die CPU in den Ruhezustand eintritt.
```
```
MultipleInstancePolicy... eine Regel aktiv wird, die
festlegt, was passiert, wenn
derselbe Job ein weiteres Mal
gestartet wird. Die Voreinstellung
bewirkt, dass der weitere Job
ignoriert wird.
```
```
RequireNetwork... der Job nur gestartet wird, wenn
eine Netzwerkverbindung zur
Verfügung steht.
```
StopIfGoingOffIdle... der Job angehalten wird, wenn


die CPU ihren Ruhezustand verlässt.

WakeToRun... der Computer den Ruhezustand

```
verlässt, damit der Job gestartet
werden kann.
```
ContinueIfGoingOnBat-
tery

... der Job nicht angehalten wird,
wenn der Computer auf
Batteriebetrieb geht (was
ansonsten der Fall wäre).

StartIfOnBattery... der Job auch dann gestartet

```
wird, wenn der Computer auf
Batteriebetrieb ist (was ansonsten
nicht der Fall wäre).
```
IdleTimeOut... der Job erst nach dem Ablauf

```
einer über diesen Timespan-
Parameter festgelegten
Ruhezeitspanne startet, wenn der
Parameter StartIfIdle gesetzt wird.
Befindet sich die CPU nicht lange
genug im Ruhezustand, wird der
Job nicht gestartet.
```
IdleDuration... der Job erst nach dem über den

```
TimeSpan-Wert festgelegten
Zeitraum der Ruhephase gestartet
wird. Spielt nur eine Rolle, wenn der
Parameter StartIfIdle gesetzt wird.
```
StartIfIdle... der Job gestartet wird, wenn


sich die CPU die über den
Parameter IdleDuration festgelegte
Zeitspanne im Ruhezustand
befunden hat.


27 PowerShell-Workflows

von Peter Monadjemi
Ein Workflow fasst eine Folge von Arbeitsschritten, die in diesem Zusammenhang Aktivitäten
genannt werden, zusammen und führt diese nacheinander aus. Damit unterscheidet sich ein
Workflow zunächst nicht von einem Skript oder einer Anwendung. Das Besondere an einem
Workflow ist, dass die Aktivitäten nicht programmiert werden müssen, sondern mit Hilfe eines
Designers zusammengestellt werden können. Eine weitere Besonderheit ist der Umstand, dass ein
Workflow nach einem Neustart des Rechners automatisch fortgesetzt wird und sich daher Abläufe
abbilden lassen, die über einen längeren Zeitraum ausgeführt werden sollen. Das .NET Framework
unterstützt die Ausführung solcher Workflows seit der Version 3.0, mit der Version 4.0 wurde die
"Workflow-Engine" grundlegend verbessert und in Version 4.5 nochmals erweitert. Seit
PowerShell-Version 3.0 lassen sich Workflows erstmals mit PowerShell-Befehlen umsetzen. Damit
besteht die Möglichkeit, mit Hilfe von PowerShell-Skripten Automatisierungsszenarien abzubilden,
die auf mehreren Computern im Netzwerk über einen längeren Zeitraum ausgeführt und nach
einem Neustart eines entfernten Computers automatisch fortgesetzt werden. Der Umstand, dass
einzelne Aktivitäten im Rahmen eines Workflow auf Wunsch auch parallel ausgeführt werden
können, eröffnet weitere Anwendungsbereiche.

27.1 Ein erstes Beispiel

Workflow klingt zunächst nach einer technisch anspruchsvollen Angelegenheit. Das ist bei der
PowerShell aber zum Glück nicht der Fall. Dem Entwicklungsteam der PowerShell kam es darauf
an, die Workflow-Funktionalität so einfach und (aus der Perspektive von PowerShell-Anwendern)
so "natürlich" wie möglich zur Verfügung zu stellen. Die Anwender sollten beim Umgang mit
Workflows keine neue Syntax lernen müssen. Ein Workflow wird durch das neue PowerShell-
Befehlswort workflow definiert. Es folgt ein Skriptblock, der als Workflow-Aktivität ausgeführt wird.
Der neue Workflow, der intern als WorkflowInfo-Objekt vorliegt, wird durch Eingabe seines Namens
ausgeführt. Wie bei einer Funktion gibt es Parameter, denen beim Aufruf Argumente übergeben
werden.


```
BEISPIEL: Das folgende Beispiel zeigt einen Workflow, der per WMI ein paar Eckdaten über
das Betriebssystem abfragt.
workflow w 1
{
$WMI = Get-WmiObject -Class Win32_OperatingSystem
$OS = New-Object -Typename PSObject -Property @{Name=$WMI.
Caption;Version=$WMI.Version; SP=$WMI.CSDVersion }
$OS
}
```
Der Workflow wird durch Eingabe des Namens "w1" in der PowerShell zur Ausführung gebracht.
Soll der Workflow auf anderen Computern ausführen, müssen die Namen der Computer auf den
Parameter PSComputerName folgen:

```
w 1 - PSComputerName Server1, Server 2
```
Außerhalb einer Domäne ist eine Authentifizierung über den PSCredential-Parameter erforderlich.
Auf dem Remote-Computer müssen lediglich das .NET Framework und nur die Power-Shell ab
Version 2.0 installiert sein (sofern der Workflow InlineScript-Aktivitäten umfasst, die im Rahmen
einer PowerShell-Session ausgeführt werden).
Im Moment unterscheidet sich ein Workflow rein äußerlich durch nichts von einer Funktion. Es gibt
aber wichtige Unterschiede, die in Kürze deutlich werden.
Ein

```
Get-Command -Name W 1 | Get-Member
```
ergibt, dass hinter einem Workflow ein Objekt vom Typ WorkflowInfo steht, dass eine Vielzahl von
Eigenschaen besitzt, die den Workflow definieren.

```
HINWEIS: Die nahe Verwandtscha eines Workflow zu einer Funktion wird durch den
Umstand unterstrichen, dass sich die WorkflowInfo-Klasse, auf der ein Workflow basiert,
von der FunctionInfo-Klasse ableitet, auf der eine Funktion basiert (das lässt sich über ein
(Get-Command -Name w 1 ).psobject.Typenames herausfinden, wenn "w1" der Name eines
Workflow ist). Es gibt allerdings kein Workflow-Laufwerk, auf dem alle Workflows
zusammengefasst werden, und damit keine Möglichkeit, einen Workflow aus der aktuellen
PowerShell-Session zu entfernen.
```
Interessanter ist der Umstand, dass ein Workflow, genau wie ein Commandlet, automatisch einen
Satz von Standardparametern besitzt:

```
Get-Command -Name W 1 - Syntax
w 1 [<AllgmeineWorkflowparameter>] [<CommonParameters>]
```

Die allgemeinen Workflow-Parameter sind in der folgenden Tabelle zusammengestellt.


Tabelle 27.1 Die allgemeinen Workflow-Parameter

```
Parameter Bedeutung
AsJob Bewirkt, dass das Job-Objekt für den Job, durch den der Workflow
ausgeführt wird, sofort zurückgegeben wird, so dass die Ausführung
des Workflow die PowerShell-Session nicht blockiert. Ohne diesen
Parameter muss man auf die Beendigung des Jobs warten.
JobName Optionaler Name für den Job, durch den der Workflow ausgeführt
wird.
PSAllowRedirection Erlaubt, dass bei der Verwendung des ConnectionURI-Parameters die
Verbindung auf einen anderen Computer umgelenkt werden kann, der
vom ausgewählten Endpunkt zurückgegeben wird. Die Anzahl der
maximal erlaubten Umleitungen kann im Rahmen der
Sessionoptionen eingestellt werden.
PSApplicationName Legt den Namen der "Anwendung" fest, die über die ConnectionURI
angesprochen wird. Die Voreinstellung ist der Wert der Variablen
$PSSessionApplicationName ("wsman"). Spielt nur in Ausnahmefällen
eine Rolle.
PSAuthentication Legt die Art der Authentifzierung fest, wenn ein Workflow remote
ausgeführt werden soll. Die Voreinstellung ist hier Default.
PSAuthenticationLevel Legt die Art der Authentifizierung bei der Ausführung einer WMI-
Aktivität auf einem anderen Computer fest. Die Voreinstellung ist hier
Default (Windows-Authentifizierung).
PSCertificateThumbprint Legt den "Daumenabdruck" eines Zertifikats fest, mit dem sich ein
lokaler Benutzer authentifizieren kann, wenn der Zugriff nicht
innerhalb der Domäne erfolgt. Spielt nur selten eine Rolle.
PSComputerName Gibt den oder die Computer an, auf denen der Workflow ausgeführt
werden soll.
PSConfigurationName Legt den Namen der Workflow-Session-Konfiguration fest. Der
Standardname ist "PowerShell.Workflow". Muss ebenfalls nur in
Ausnahmefällen geändert werden.
PSConnectionRetryCount Anzahl der Versuche, die der Workflow unternehmen soll, um mit
einem Remote-Computer eine Verbindung herzustellen.
PSConnectionRetry
IntervalSec
```
```
Zeitspanne in Sekunden, die zwischen zwei Versuchen liegen soll, um
mit einem Remote-Computer eine Verbindung herzustellen.
PSConnectionURI Legt über eine URI im allgemeinen Format "<Transportprotokoll>://<
Computername>:<Port>/<Anwendungsname>" den Endpunkt einer
```

```
Remote-Verbindung fest. Die Voreinstellung ist http://localhost:
5985 /wsman und muss nur in Ausnahmefällen geändert werden.
PSCredential Führt eine Authentifizierung über Benutzername und Kennwort als
SecureString durch.
PSElapsedTimeoutSec Entspricht der PSRunningTimeoutSec-Property, nur dass hier auch die
Zeit berücksichtigt wird, die der Workflow unterbrochen wird.
PSParameterCollection Steht für eine Hashtable, die pro Computer, auf denen der Workflow
ausgeführt werden soll, wiederum eine Hashtable enthält, in der die
Parameterwerte für diesen speziellen Workflow untergebracht sind.
Diese Hashtable besitzt den Aufbau: @{PSComputerName=
"Server1";Parameter 1 =Wert;Parameter 2 =Wert},@{PSComputerName=
"Server2";Parameter 1 =Wert; Parameter 2 =Wert}
PSPersist Legt fest, ob und in welchem Umfang der Workflow seinen Zustand
speichert. Der Parameter kann drei Werte annehmen: $True (der
Zustand wird nach jeder Aktivität gespeichert), $False (der Zustand
wird nie gespeichert) und "Undefiniert". Letzterer ist die
Voreinstellung und bewirkt, dass der Workflow seinen Zustand zu
Beginn und am Ende speichert.
PSPrivateMetadata Ermöglicht es dem Workflow, direkt zusätzliche Daten für die
Ausführung in Gestalt einer Hashtable zu übergeben.
PSRunningTimeoutSec Anzahl Sekunden, die ein Workflow maximal ausführen darf, bevor die
Ausführung mit einem TimeOut abbricht.
PSSessionOption Ermöglicht eine Reihe von knapp zwei Dutzend von speziellen
Einstellungen, die die Remote-Verbindung betreffen. Eine davon ist
"SkipCACheck", durch die bei einem selbst ausgestellten Zertifikat auf
die Überprüfung des Herausgeberzertifikats verzichtet wird.
PSUseSSL Gibt an, dass eine HTTPS-Verbindung verwendet wird (setzt ein
Serverzertifikat voraus).
```
Die Rolle der Aktivitäten

Ein Workflow besteht aus einzelnen Aktivitäten. Eine Aktivität steht für einen Abschnitt während
der Ausführung des Workflows, der wiederum andere Aktivitäten enthalten kann. Der Umstand,
dass ein Workflow "reguläre" Commandlets enthält, bedeutet aber nicht, dass diese von der
PowerShell ausgeführt werden. Wie es im nächsten Abschnitt kurz erläutert wird, werden die
Commandlets vor der Ausführung des Workflows in entsprechende Aktivitäten umgesetzt, die der
Reihe nach abgearbeitet werden. Dies bedeutet, dass nicht jedes Commandlet und jede
"Befehlskonstruktion" für einen Workflow in Frage kommt. Mehr zu den Unterschieden in einem
der folgenden Abschnitte.


Bild 27.1 Ein Workflow besteht aus Aktivitäten.

Die PowerShell 5.x umfasst knapp 200 verschiedene Aktivitäten. Dazu gehören neben den
wichtigsten Commandlets auch eine Reihe von "Spezialaktivitäten" wie z. B. Suspend-Workflow,
durch das die Ausführung eines Commandlets unterbrochen wird. Die folgende Tabelle stellt diese
Aktivitäten zusammen.

Tabelle 27.2 Spezielle Aktivitäten für die Ablaufsteuerung

```
Aktivität Bedeutung
Suspend-Workflow Unterbricht die Ausführung des Workflows.
Inlinescript Bewirkt, dass der folgende Skriptblock von der PowerShell ausgeführt
wird.
Checkpoint-
Workflow
```
```
Bewirkt, dass der Workflow seinen aktuellen Zustand speichert.
```
Ein Blick hinter die Kulissen

Um die Ausführung von Workflows zu ermöglichen, hat das PowerShell-Team die PowerShell auf
eine neue Grundlage gestellt. Während die Version 2.0 auf einem klassischen Interpreter basierte,
bei jedem die Befehle eines Skripts der Reihe nach interpretiert und ausgeführt werden, wird ein
PowerShell-Befehl intern von einem sog. Compiler in einen abstrakten Syntaxbaum (kurz AST für
"Abstract Syntax Tree") umgesetzt, der anschließend "abgearbeitet" wird. Die direkte Umsetzung
eines Befehls unmittelbar nach seiner Eingabe besitzt den (in der Regel) angenehmen Nebeneffekt,
dass Fehler wie eine vergessene Klammer, unmittelbar nach der Eingabe in der PowerShell ISE
angezeigt werden.
Vor der Ausführung eines Workflows wird dieser in eine XML-Struktur umgewandelt, die auf der
Beschreibungssprache XAML (Extensible Application Markup Language) basiert, die von Microso
auch in anderen Zusammenhängen, etwa als Beschreibungssprachen für Fenster und
Benutzeroberflächen auf der Basis von WPF (Windows Presentation Foundation), verwendet wird.
Auf der Grundlage der XAML-Definition generiert die PowerShell eine Proxy-Funktion, über die der
Workflow als Job zur Ausführung gebracht wird. Wird beim Aufruf des Workflows der AsJob-


Parameter übergeben, wird das resultierende Job-Objekt zurückgegeben und der Anwender kann
über das Receive-Job-Commandlet die vom Workflow in die Pipeline gelegten Daten abrufen.
Ansonsten wartet die Proxy-Funktion darauf, dass der Workflow fertig ist, und ru danach das
Receive-Job-Commandlet auf.
Über den Befehl

```
Get-Command -Name Workflowname | Format-List ScriptBlock
```
wird der Inhalt dieser Proxy-Funktion ausgegeben.

27.2 Unterschiede zu einer Function bzw. einem Skript

Auch wenn die Beschreibung eines Workflows der einer Funktion bzw. eines Skripts sehr ähnlich
ist, gibt es natürlich wichtige Unterschiede. Der wichtigste Unterschied zwischen einem Workflow
und einem PowerShell-Skript ist, dass ein Workflow, der auf einem Computer im Netzwerk
ausgeführt wird, einen Neustart des Computers "überlebt" und seine Arbeit nach dem Neustart an
dem Punkt fortsetzt, an dem er unterbrochen wurde. Damit ergibt sich auch der typische
Anwendungsbereich für Workflows: Automatisierungsszenarien, bei denen eine Folge von
Schritten auf einer beliebigen Anzahl von Rechnern im Netzwerk ausgeführt werden soll, die
eventuell einen Neustart erforderlich machen, und bei denen externe Parameter, wie z. B. eine
explizite Bestätigung durch einen "menschlichen Operator", einbezogen werden sollen. Diese
Szenarien lassen sich durch ein einfaches PowerShell-Skript nicht ab bilden.
Weitere Unterschiede sind:
Workflows werden nicht von der PowerShell, sondern von der Workflow-Laufzeit ausgeführt.
Ein remote ausgeführter Workflow, dessen Ausführung durch einen Neustart des Computers
unterbrochen wurde, wird nach dem Neustart automatisch fortgesetzt.
Ein Workflow kann jederzeit seinen Zustand (u. a. die Werte der in dem Workflow definierten
Variablen) speichern. Dieser Umstand ist immer dann von Bedeutung, wenn ein Workflow
nach einem Neustart fortgesetzt werden soll. Er kann dadurch die Arbeit an dem Punkt
fortsetzen, an dem er unterbrochen wurde.
Workflow-Aktivitäten können in Visual Studio mit Hilfe eines komfortablen Designers definiert
und von der PowerShell ausgeführt werden. PowerShell-Workflow-Aktivitäten können mit
allgemeinen Workflow-Aktivitäten kombiniert werden.

27.3 Einschränkungen bei Workflows

Auch wenn eine Workflow-Definition einer Funktionsdefinition ähnelt, gibt es wichtige
Unterschiede, was ihren Inhalt angeht. Eine Vielzahl von Commandlets und Befehlstechniken sind
in einer Workflow-Definition nicht erlaubt. Zum einen, weil sie technisch nicht oder nur sehr
aufwendig umgesetzt werden können. Zum anderen, weil sie keinen Sinn ergeben würden. Das
klassische Beispiel ist das Start-Transcript-Commandlet, das die Mitprotokollierung der Ein- und
Ausgaben einer PowerShell-Session startet. Da ein Workflow nicht in einer interaktiven


PowerShell-Session ausgeführt wird, ergibt dieses Commandlet genauso wenig einen Sinn wie z.
B. das Read-Host-Commandlet. Weniger einleuchtend düre der Umstand sein, dass die folgende
Befehlsfolge innerhalb eines Workflows nicht erlaubt ist:

```
$P = Get-Process -Name Calc
$P.Kill()
```
Der Grund ist, dass der direkte Aufruf von Methoden nicht erlaubt ist (in diesem Fall wäre ein Stop-
Process eine naheliegende Alternative). Möchte man die Kill()-Methode unbedingt aufrufen, muss
die Befehlsfolge lediglich in eine inlinescript-Aktivität gesetzt werden:

```
inlinescript {
$P = Get-Process -Name Calc
$P.Kill()
}
```
Es ist interessant, dass der Aufruf von Methoden nicht grundsätzlich unterbunden wird. Wird eine
Methode mit Argumenten aufgerufen und der Rückgabewert der Methode einer Variablen
zugewiesen, hat die PowerShell nichts dagegen. Der folgende Aufruf ist innerhalb eines Workflows
erlaubt:

```
$Wochentag = (Get-Date).AddDays( 1 )
"Morgen ist $Wochentag"
```
Der Aufruf von

```
(Get-Date).AddDays( 1 )
```
führt dagegen zu dem inzwischen bekannten Fehler, der innerhalb der ISE bereits unmittelbar
nach der Eingabe angezeigt wird.
Natürlich sind alle Unterschiede zwischen einem Workflow und einem "regulären" Power-Shell-
Skriptblock dokumentiert – einige werden bereits unmittelbar nach der Eingabe innerhalb der ISE
angezeigt. Zum Beispiel innerhalb des TechNet-Portals unter der folgenden Adresse:
[http://technet.microso.com/en-us/library/jj](http://technet.microso.com/en-us/library/jj) 574194 % 28 d=printer%29.aspx
Die folgende Aufzählung, die keinen Anspruch auf Vollständigkeit erhebt, fasst die wichtigsten
Unterschiede zusammen:
Ein Workflow kann keine "interaktiven" Befehle enthalten, wie z. B. Read-Host, Write-Host
oder Start-Transcript.
Bei Commandlets sind keine Positionsparameter erlaubt. Jedem Parameterwert muss daher
sein Name vorausgehen.
Ein Workflow darf keinen Begin-, Process- und End-Bereich enthalten.
Ein Parameter kann nicht mit dem Attributwert ValueFromPipeline versehen werden. Einem
Workflow können daher keine Werte über die Pipeline übergeben werden.
Direkte Methodenaufrufe (ohne Argumente) sind nicht erlaubt.


Variablennamen müssen mit einem Buchstaben beginnen und dürfen nur Buchstaben, Ziffern
und die Zeichen "-" und "_" enthalten.
Viele dieser Einschränkungen lassen sich umgehen, indem der oder die Befehle in eine
inlinescript-Aktivität gesetzt werden.

27.4 Workflows in der Praxis

Auf den folgenden Seiten werden die verschiedenen grundlegenden Eigenschaen von Workflows
an kleinen Beispielen vorgestellt.

Workflows mit Parametern

Einem Workflow werden auf die gleiche Weise wie bei einer Funktion Parameter übergeben.

```
BEISPIEL: Das folgende Beispiel definiert einen Workflow, der über einen Parameter eine
Aktivität eine bestimmte Anzahl o ausführt.
workflow w 2
{
param([Int]$Anzahl)
1..$Anzahl | Foreach-Object -Process { "Aktivität..."
}
}
w 2 - Anzahl 10
Auch bei diesem einfachen Beispiel tritt wieder ein "Spezialfall" auf. Beim Foreach-Object-
Commandlet muss der Process-Parameter explizit angegeben werden, da in einem
Workflow keine Positionsparameter (also Parameter, die ihren Wert über die Position des
Arguments erhalten) zulässig sind.
```
Workflow mit Rückgabewerten

Workflows werden intern als Jobs ausgeführt. Eine interaktive PowerShell steht während ihrer
Ausführung nicht zur Verfügung. Direkte Ein- und Ausgaben per Read- Host und Write-Host sind
daher nicht möglich. Ausgaben, die ein Workflow tätigen soll, werden, wie bei einem "regulären"
Job, direkt in die Pipeline gelegt, so dass ein Workflow, genau wie eine Function, direkt einer
Variablen zugewiesen werden kann. Eine Ausnahme liegt vor, wenn der Workflow mit dem AsJob-
Parameter gestartet wurde. In diesem Fall werden die Rückgabewerte über das Receive-Job-
Commandlet abgeholt.


```
BEISPIEL: Das folgende Beispiel zeigt einen Workflow, der prü, ob ein Hotfix installiert ist,
dessen ID als Parameterwert übergeben wird. Der Rückgabewert ($true oder $false) wird in
die Pipeline gelegt.
workflow w 3
{
param([String]$HotfixID)
(Get-Hotfix -ID $HotfixID -ErrorAction SilentlyContinue) - ne $null
}
w 3 - HotfixID KB 98630
```
Gültigkeitsbereich von Variablen innerhalb eines Workflows

In einem Workflow gelten andere Gesetze, was den Gültigkeitsbereich von Variablen angeht, als
innerhalb einer Function. Der wichtigste Unterschied ist, dass ein Workflow, genau wie ein Job,
eine abgeschlossene Einheit darstellt und daher nicht auf Variablen zugreifen kann, die außerhalb
des Workflows definiert sind. Auch für eine inlineScript-Aktivität gelten andere Gesetze. Ein
Befehl muss über die neuen Befehlswörter using und workflow auf eine Variable zugreifen, die
außerhalb der Aktivität (aber noch innerhalb des Workflows) definiert ist.


```
BEISPIEL: Das folgende Beispiel zeigt einen Workflow, in dem über das sequence-
Schlüsselwort eine eigene Aktivität definiert wird:
workflow w 1
{
$Anzahl = 1
sequence {
$Anzahl
}
}
Für den Wert von $Anzahl wird innerhalb der Aktivität der Wert 1 ausgegeben, da die
Variable in diesem Bereich sichtbar ist.
Anders sieht es aus, wenn innerhalb der sequence-Aktivität der Wert der Variablen geändert
werden soll. Eine harmlose Zuweisung wie
$Anzahl = 2
führt zu einem Fehler, da die Variable $Anzahl bereits definiert wurde. Soll ihr Wert
geändert werden, kommt das neue Befehlswort workflow zum Einsatz:
$workflow:Anzahl = 2
Um deutlich zu machen, dass sich diese Zuweisung auf eine bereits im Workflow definierte
Variable bezieht, musste das PowerShell-Team dem Befehl workflow eine zweite Bedeutung
geben. Auch wenn es nicht zu Verwechslungen kommen kann, ganz optimal ist diese
Doppelbelegung natürlich nicht.
```
Eine weitere Variante, was den Gültigkeitsbereich von Variablen betri, liegt immer dann vor,
wenn eine inlinescript-Aktivität im Spiel ist. In dieser Aktivität müssen Workflow-Variablen lesend
über das Befehlswort using und schreibend, wie bereits gezeigt, über das Befehlswort workflow
angesprochen werden.


BEISPIEL: Das folgende Beispiel ist etwas umfangreicher. Es durchsucht die ersten n Zeilen
aller ps1-Dateien in einem vorgegebenen Verzeichnis auf das Kommentarzeichen "#". Am
Ende wird die Anzahl der gefundenen Zeilen ausgegeben. Die Anzahl der pro Datei zu
untersuchenden Zeilen wird über die Variable $AnzahlZeilen festgelegt. Damit diese
Variable innerhalb des inlinescript-Bereichs angesprochen werden kann, wird das
Befehlswort using verwendet.

```
workflow w 1
{
$AnzahlZeilen = 1
$AnzahlTreffer = 0
inlinescript {
Get-ChildItem -Path $PsHome -Include *.ps 1 - Recurse | Foreach-Object {
Write-Verbose "Prüfe $($_.Fullname)"
if ((Get-Content -Path $_.FullName -TotalCount $Using:AnzahlZeilen |
Out-String -Stream) - like "*#")
{ $AnzahlTreffer++ }
}
}
"$AnzahlTreffer Kommentarzeilen gefunden"
}
```
Wird der Workflow mit dem Verbose-Parameter aufgerufen, wird zwar deutlich, dass eine
Reihe von ps1-Dateien durchsucht wird, die Variable $AnzahlTreffer besitzt am Ende aber
den Wert 0, da innerhalb der Aktivität inlinescript eine neue Variable $AnzahlTreffer
definiert wird, die außerhalb der Aktivität nicht mehr zur Verfügung steht. Die Lösung
besteht darin, das Ergebnis der inlinescript-Aktivität der Workflow-Variablen
$AnzahlTreffer zuzuweisen:

```
workflow w 1
{
$AnzahlZeilen = 2
$AnzahlTreffer = 0
$AnzahlTreffer = inlinescript {
Get-ChildItem -Path $PsHome -Include *.ps 1 - Recurse | Foreach-Object {
Write-Verbose "Prüfe $($_.Fullname)"
if ((Get-Content -Path $_.FullName -TotalCount $Using:AnzahlZeilen |
Out-String -Stream) - like "*#")
{ $AnzahlTreffer++ }
}
$AnzahlTreffer
}
"$AnzahlTreffer Kommentarzeilen gefunden"
}
```
AUCH wenn die Variable $AnzahlTreffer zwei Mal vorkommt, handelt es sich um zwei
unterschiedliche Variablen, da sie in unterschiedlichen Gültigkeitsbereichen definiert sind.


Zugriff auf Variablen außerhalb des Workflows

Ein Workflow kann grundsätzlich nicht auf Variablen zugreifen, die außerhalb des Workflows gültig
sind. Auch die Übergabe einer Variablen als Referenz an einen Workflow ist nicht möglich. Soll ein
Workflow dem aufrufenden Skript Werte zurückgeben, legt er diese ganz einfach in die Pipeline.
Eine Alternative ist eine gemeinsame Umgebungsvariable, die über [System.
Environment]::SetEnvironmentVariable() auf Benutzer- oder Maschinenebene angelegt wird.

```
BEISPIEL: Das folgende Beispiel zeigt eine Workflow-Definition, der ein Parameterwert
übergeben wird, den sie in eine Umgebungsvariable einträgt, die wiederum nach
Beendigung des Workflows abgefragt wird.
workflow w 4
{
param([Int]$Wert)
inlinescript
{
"Der Wert ist: $using:Wert"
[System.Environment]::SetEnvironmentVariable("TestWert", $Wert, "User")
}
}
[System.Environment]::SetEnvironmentVariable("TestWert", 1000, "User")
w 4 - Wert 3000
[System.Environment]::GetEnvironmentVariable("TestWert","User")
```
Verschachtelte Workflows

Wie Funktionen können auch Workflows verschachtelt sein. In diesem Fall wird der "innere"
Workflow als Teil des äußeren Workflows ausgeführt. Jeder Workflow bildet eine eigene Aktivität
und damit auch einen eigenen Gültigkeitsbereich für Variablen und Funktionen. Eine Funktion, die
im äußeren Workflow definiert ist, existiert für einen inneren Workflow daher nicht.


```
BEISPIEL: Das folgende Beispiel ist absichtlich sehr einfach gehalten. Es definiert innerhalb
des Workflows w 1 einen weiteren Workflow w 2 , der innerhalb von w 1 aufgerufen wird.
workflow w 1
{
$ID = 1
"w 1 wird ausgeführt..."
workflow w 2
{
"w 2 wird ausgeführt - der Wert (ID=$ID)"
}
w 2
}
Die Variable $ID steht innerhalb des Workflows w 2 nicht zur Verfügung. Sie müsste als
Parameter an den Workflow übergeben werden.
```
Ein Spezialfall liegt vor, wenn der innere Workflow im Rahmen einer weiteren Aktivität aufgerufen
werden soll. Das Problem: Im Rahmen dieser Aktivität ist der Workflow nicht bekannt und kann
daher nicht aufgerufen werden. Ein "Workaround" besteht darin, den Workflow einer Skriptblock-
Variablen zuzuweisen und diese Variable innerhalb der Aktivität über using anzusprechen.

```
BEISPIEL: Das folgende Beispiel ru innerhalb eines Workflows einen "inneren" Workflow
im Rahmen einer ForEach-Object-Aktivität mehrfach auf und benutzt dazu den Umweg über
eine Skriptblock-Variable, die den Workflow repräsentiert und auf die der innere Workflow
dank der Verwendung von using zugreifen kann.
workflow w 1
{
workflow w 2
{ "Worfklow w2..." }
$SB = { w 2 }
inlinescript {
1..3 | ForEach-Object -process { $using:SB }
}
}
```
Parallele Aktivitäten

Einzelne Befehle innerhalb eines Workflows können auch parallel ausgeführt werden. Das
bedeutet konkret, dass die einzelnen Aktivitäten auf allen vorhandenen Kernen der CPU


gleichzeitig ausgeführt werden. Dazu wird innerhalb eines Workflows ein neuer Skriptblock
definiert, dem das Befehlswort parallel vorausgeht.

```
BEISPIEL: Das folgende Beispiel definiert einen Workflow, in dem drei Aktivitäten, jeweils
bestehend aus einem ForEach-Object-Commandlet, parallel ausgeführt werden. Zum
"Beweis" dafür, dass die Ausführung tatsächlich gleichzeitig stattfindet, wird die Nummer
der Aktivität mit ausgegeben. Bei der Ausgabe wird deutlich, dass die drei Aktivitäten
durcheinander ausgeführt werden. Außerdem wird durch die Ausgabe der sog. Thread-ID
deutlich, dass jede Aktivität auf ihrem eigenen "Ausführungsfaden" (engl. "thread")
innerhalb des Prozesses ausführt.
workflow w 1
{
parallel {
1..10 | Foreach-Object -Process {
$ThreadID = [System.Threading.Thread]::CurrentThread.ManagedThreadId
"Aktivität 1: Laufe auf Thread-Nr. $ThreadID"
Start-Sleep -Milliseconds 500
}
1..10| Foreach-Object -Process {
$ThreadID = [System.Threading.Thread]::CurrentThread.ManagedThreadId
"Aktivität 2: Laufe auf Thread-Nr. $ThreadID"
Start-Sleep -Milliseconds 500
}
1..10| Foreach-Object -Process {
$ThreadID = [System.Threading.Thread]::CurrentThread.ManagedThreadId
"Aktivität 3: Laufe auf Thread-Nr. $ThreadID"
Start-Sleep -Milliseconds 500
}
}
}
```
Sollen die Befehle eines Skriptblocks innerhalb eines Workflows explizit sequenziell ausgeführt
werden, muss ihnen das Befehlswort sequential vorausgehen. Bezogen auf das obige Beispiel
würde sich die Ausgabe dahingehend unterscheiden, dass die drei Aktivitäten streng in
Reihenfolge ihres Auretens abgearbeitet werden (und dass zwei Aktivitäten auf demselben
Thread ausgeführt werden können).

Spezialfall foreach-Befehl

Für den foreach-Befehl der PowerShell steht innerhalb eines Workflows (und leider nur dort) der
Parameter parallel zur Verfügung. Er bewirkt, dass die Befehle des folgenden Schleifen-
Skriptblocks parallel ausgeführt werden.


```
BEISPIEL: Das folgende Beispiel definiert einen Workflow, der eine Reihe von Befehlen im
Rahmen des foreach-Befehls parallel ausführt.
workflow w 1
{
foreach -parallel ($i in 1..10)
{
$ThreadID = [System.Threading.Thread]::CurrentThread.ManagedThreadId
"Aktivität $($i): Laufe auf Thread-Nr. $ThreadID"
Start-Sleep -Milliseconds 500
}
}
Der "Beweis", dass die Befehle tatsächlich parallel ausgeführt werden, besteht auch bei
diesem Beispiel darin, dass die Nummern der Aktivitäten durcheinander ausgegeben
werden. Ohne den parallel-Parameter werden sie nacheinander ausgegeben.
```
Die Speicherung des Workflow-Zustands (Persistenz)

Unter dem allgemeinen Begriff "Zustand" (engl. "state") wird bei einem Workflow sein Ist-Zustand
in einem bestimmten Moment während seiner Ausführung zusammengefasst. Dazu gehören u. a.
die Werte der Variablen und der aktuell ausgeführte Befehl. Der Umstand, dass ein Workflow
seinen Zustand, z. B. über die Aktivität Checkpoint-Workflow, jederzeit speichern kann, ist eine
Voraussetzung dafür, dass ein Workflow nach einer Unterbrechung nahtlos fortgesetzt werden
kann. Eine solche Unterbrechung ist im Allgemeinen ein Neustart des Computers, auf dem der
Remote-Workflow ausgeführt wird.
Die Fähigkeit eines Workflows, seinen Zustand speichern zu können, heißt Persistenz.

```
HINWEIS: Die PowerShell speichert den Zustand eines Workflows im Dateisystem im
Benutzerprofilverzeichnis. Zu den gespeicherten Informationen gehören die Workflow-
Definition, die Workflow-Parameter, der Zustand des ausführenden Jobs, weitere interne
Zustandsinformationen und Metadaten, die mit dem Workflow in Beziehung stehen.
```
Möchte man erreichen, dass der Workflow seinen Zustand nach jeder Aktivität speichert, muss
beim Aufruf der PSPersist-Parameter mit dem Wert $True gesetzt werden.

Workflows unterbrechen und fortsetzen

Der wichtigste Unterschied zwischen einem Workflow und einem Skript besteht darin, dass ein
Workflow über die Suspend-Workflow-Aktivität unterbrochen und zu einem späteren Zeitpunkt über
das Commandlet Resume-Job fortgesetzt werden kann. Das klassische Beispiel ist ein Arbeitsablauf,


in dem "mittendrin" eine E-Mail verschickt wird und die Abarbeitung des Arbeitsablaufs danach
unterbrochen wird, damit sie zu einem späteren Zeitpunkt fortgesetzt werden kann. Die
Fortführung des Arbeitsablaufs muss entweder durch einen "menschlichen Eingriff" oder über ein
systemweites Ereignis, etwa das Starten eines bestimmten Prozesses, fortgesetzt werden.
Bezogen auf den beschriebenen Arbeitsablauf muss der Empfänger der E-Mail entscheiden, ob der
Workflow fortgesetzt wird oder nicht (was natürlich ebenfalls, z. B. über eine Posteingangsregel,
automatisiert werden kann). Ob der Empfänger dies nach einigen Minuten oder nach einem
längeren Urlaub tut, spielt für die Ausführung des Workflows keine Rolle, da er seinen Zustand
entweder implizit (nach wichtigen Operationen), über den Workflow-Parameter PSPersist:$True
nach jeder Aktivität oder über die Checkpoint-Workflow-Aktivität gezielt sichert.

```
BEISPIEL: Das folgende Beispiel definiert einen Workflow, der nach Ausgabe einer Meldung
die Ausführung anhält. Der Zustand besteht aus dem Wert der Variable $State. Dabei wird
ein Job-Objekt angelegt, dessen Eckdaten wie üblich ausgegeben werden.
workflow w 1
{
"Workflow startet"
$State = 1000
suspend-Workflow
"Der aktuelle Zustand: $State"
}
Id Name PSJobTypeName State HasMoreData Location Command
-- ---- ------------- ----- ----------- -------- -------
120 Job 120 PSWorkflowJob Suspended True localhost w 1
Receive-Job -id 120
Der aktuelle Zustand: 1000
Über das Resume-Job-Commandlet kann der Workflow unter Angabe seiner Job-Id
fortgesetzt werden. Die resultierende Ausgabe muss, wie bei Jobs üblich, über das Receive-
Job-Commandlet abgeholt werden.
```
Fehlersuche in Workflows (Debugging)

Genau wie die Ausführung eines Jobs kann auch ein Workflow leider nicht debuggt, also unter der
Steuerung des PowerShell-Debuggers ausgeführt, werden. Ein Haltepunkt innerhalb einer
Workflow-Definition besitzt keine Wirkung.
Ein praktischer Tipp, um diese Einschränkung zu umgehen, besteht darin, die Befehle zuerst
außerhalb des Workflows zu testen und sie erst danach in den Workflow einzubauen. Das Testen
umfangreicherer Workflows kostet aber generell Zeit.

27.5 Workflows in Visual Studio erstellen


Ein PowerShell-Workflow kann alternativ innerhalb der Microso-Entwicklungsumgebung Visual
Studio (ab Version 2010 Professional Edition) mit Hilfe eines Designers, auf dem die einzelnen
Aktivitäten angeordnet werden, erstellt werden. Das Ergebnis ist eine Textdatei im XAML-Format
(Extensible Application Markup Language), die den Workflow definiert. Ausgeführt wird der
Workflow durch das Import-Module-Commandlet, auf das der Pfad der XAML-Datei folgt. Dieser Typ
von Workflow wird XAML-Workflow genannt und unterscheidet sich von einem Skript-Workflow nur
durch die Art der Umsetzung, nicht aber durch seine Möglichkeiten.
Ein XAML-Workflow bietet den Vorteil, dass er von Anwendern erstellt werden kann, die nur geringe
PowerShell-Kenntnisse besitzen und sich nicht mit den Details während der Eingabe eines Skript-
Workflows beschäigen möchten, wenngleich die Umsetzung ganz ohne Power-Shell-Kenntnisse
nicht gelingen wird und zudem gewisse Grundkenntnisse im Umgang mit .NET-Datentypen
voraussetzt. Ein weiterer Vorteil ist, dass der Workflow innerhalb des Designers in einer visuellen
Notation vorliegt, die ausgedruckt und/oder als Grundlage für eine Diskussion über die Aufgaben
des Workflows dienen kann.

```
HINWEIS: Über die Eigenscha XamlDefinition des WorkflowInfo-Objekts erhält man die
XAML-Definition eines Skript-Workflows:
Get-Command -Name W 1 | Format-List XamlDefinition
```
Die XAML-Definition eines Workflows, der (über Write-Output) lediglich das Literal "Hallo, Welt" in
die Pipeline legt und damit ausgibt, sieht stark vereinfacht (u. a. wurden alle Namensraum-
Deklarationen weggelassen) wie folgt aus:

```
<Activity
x:Class="Microsoft.PowerShell.DynamicActivities.Activity_1331639546"
xmlns=http://schemas.microsoft.com/netfx/ 2009 /xaml/activities
>
<Sequence>
<ns1:WriteOutput>
<ns1:WriteOutput.InputObject>
<InArgument x:TypeArguments="ns4:PSObject[]">
<ns2:PowerShellValue x:TypeArguments="ns4:PSObject[]"
Expression="&quot;Hallo,Welt&quot;" />
</InArgument>
</ns1:WriteOutput.InputObject>
</ns1:WriteOutput>
<Sequence.Variables>
<Variable Name="WorkflowCommandName" x:TypeArguments="ns0:String" Default =
"w1" />
</Sequence.Variables>
</Sequence>
</Activity>
```
Es wird deutlich, dass der Workflow durch das <Activity>-Element definiert wird und aus einem
<Sequence>-Element als Stammelement besteht. Die Ausgabe des Literals übernimmt die WriteOut-


Aktivität, die im Namespace Microsoft.PowerShell.Utility.Activities und in der Assembly
Microsoft.PowerShell.Utility.Activities.dll definiert ist. Die auszugebende Zeichenkette wird
dem InputObject-Parameter als Array von PSObject-Werten übergeben.
Für die grafische Erstellung eines XAML-Workflows wird Visual Studio ab Version 2010 benötigt.
Erforderlich ist mindestens die Professional Edition, die kostenlosen Express Editionen gehen
nicht, da es hier keinen Workflow-Designer gibt. Dass Visual Studio als Werkzeug verwendet wird,
bedeutet nicht, dass für die Umsetzung Programmierkenntnisse benötigt werden, denn bei der
Umsetzung ist keine Programmierung im Spiel. Allerdings muss man sich mit dem Konzept der
Datentypen und wie diese aus verschiedenen Assembly-Bibliotheken ausgewählt werden,
auseinandersetzen. Dies ist z. B. Voraussetzung, um den Output eines Commandlets dem nächsten
Commandlet als Input zuweisen zu können. Die Ausdrücke werden nicht in der PowerShell-Syntax,
sondern in C# oder Visual Basic definiert.
Die Vorgehensweise bei der Umsetzung besteht darin, ein neues Projekt vom Typ
"Konsolenanwendung für Workflows" in der Kategorie "Workflow" anzulegen, den Workflow mit
Hilfe eines Designers zusammenzustellen und die daraus resultierende XAML-Datei über das
Import-Module-Commandlet zu laden. Anschließend steht der Workflow auf die exakt gleiche Art
und Weise zur Verfügung wie ein innerhalb der PowerShell definierter Skript-Workflow.
Was im letzten Absatz im Schnelldurchlauf zusammengefasst wurde, soll im Folgenden an einem
kleinen Beispiel Schritt für Schritt umgesetzt werden. Das Beispiel wurde absichtlich sehr einfach
eingehalten und ist damit zwangsläufig praxisfern, da bereits die Umsetzung eines aus sechs
einfachen Aktivitäten bestehenden Workflows aus mehreren Dutzend Teilschritten besteht. Der
Workflow schreibt die Anzahl der laufenden Prozesse in eine Textdatei, startet den Computer neu
und fügt anschließend erneut die Anzahl der laufenden Prozesse in dieselbe Textdatei ein und gibt
am Ende eine kurze Meldung aus. Es versteht sich von selbst, dass dafür kein Workflow benötigt
wird. Die Beschreibung soll Sie in die Lage versetzen, einen Workflow für ein praxisnahes Szenario
umzusetzen. Hat man die Grundregeln bei der Umsetzung verstanden, ist man in der Lage, beliebig
komplexe Abläufe abzubilden.

Schritt 1

Starten Sie Visual Studio, legen Sie ein neues Projekt vom Typ "Konsolenanwendung für
Workflows" an und geben Sie dem Projekt den Namen "DemoWorkflow".


Bild 27.2 Das Workflow-Projekt wird angelegt.

Schritt 2

Eine lästige Kleinigkeit muss bei Visual Studio bei jedem neuen Projekt erledigt werden. In den
Projekteigenschaen muss für das Ziel-Framework das voreinstellte ".NET Framework 4 Client
Profile" gegen das ".NET Framework 4"-Profil, das die komplette Laufzeit repräsentiert,
ausgetauscht werden. Wählen Sie dazu im Projekt-Menü den Eintrag "DemoWorkflow-
Eigenschaen.. ." ("DemoWorkflow" ist der Name des Projekts) und wählen Sie in der Auswahlliste
"Zielframework" den Eintrag ".NET Framework 4" (oder höher). Damit die Einstellung wirksam
wird, muss das Projekt danach geschlossen und erneut geöffnet werden, was automatisch
geschieht.

Bild 27.3 In den Projekteigenschaen muss das .NET Framework 4-Profil eingestellt werden.


Schritt 3

Zu Beginn sehen Sie eine leere Designerfläche. Hier sollen in Kürze die einzelnen Aktivitäten
abgelegt werden.

Bild 27.4 Zu Beginn ist die Designerfläche noch leer.

Machen Sie über das Ansicht-Menü die Toolbox sichtbar. Hier werden alle zur Verfügung stehenden
Aktivitäten angeboten. Am Anfang düren in der Kategorie "Allgemein" noch keine Aktivitäten
angeboten werden, sie ist daher ebenfalls noch relativ leer.

Bild 27.5 In der Toolbox werden noch keine PowerShell-Aktivitäten angezeigt.

Schritt 4


Gehen Sie wie folgt vor, um alle PowerShell-Aktivitäten hinzuzufügen.
Klicken Sie die Toolbox mit der rechten Maustaste an und wählen Sie den Eintrag "Elemente
auswählen".

Bild 27.6 Zur Toolbox werden weitere Elemente hinzugefügt.

Wechseln Sie in das Register "System.Activities-Komponenten". Alle Aktivitäten, die noch nicht
angekreuzt sind, die aber Teil der Toolbox sein sollen, müssen angekreuzt werden.


Bild 27.7 Nicht alle Aktivitäten werden am Anfang in der Toolbox angezeigt.

Am Anfang werden Sie in der Liste aber keine PowerShell-Aktivitäten finden, da noch keine
hinzugefügt wurden. Das muss einmalig nachgeholt werden. Die einzelnen PowerShell-Aktivitäten
sind auf die folgenden sechs Assembly-Bibliotheken verteilt:
Microso.PowerShell.Activities.dll
Microso.Powershell.Core.Activities.dll
Microso.PowerShell.Utility.Activities.dll
Microso.PowerShell.Management.Activities.dll
Microso.PowerShell.Diagnostics.Activities.dll
Microso.PowerShell.Security.Activities.dll
Die ersten vier Bibliotheken sollten auf alle Fälle hinzugefügt werden, am besten alle sechs. Die
Dateien befinden sich im "GAC" (Global Assembly Cache) des .NET Frameworks. Dahinter steckt
eine Verzeichnishierarchie im Verzeichnis c:\Windows\Microso.NET\Assembly\GAC_ MSIL.

Bild 27.8 Die PowerShell-Aktivitäten befinden sich im GAC-Verzeichnis des .NET Frameworks.

Sie müssen daher für jede einzelne Assembly auf den Durchsuchen-Button klicken, die DLL-Datei in
ihrem jeweiligen Unterverzeichnis lokalisieren und sie auswählen. Dadurch werden die in der Datei
enthaltenen Aktivitäten in die Liste der für die Toolbox verfügbaren Aktivitäten aufgenommen.


Bild 27.9 Eine Assembly mit PowerShell- Aktivitäten wird ausgewählt.

Zwar wird es durch das Hinzufügen aller zur Verfügung stehenden PowerShell-Aktivitäten in der
Toolbox recht voll, doch ersparen Sie sich so eine Suche nach einer Aktivität, deren Assembly-
Bibliothek nicht geladen wurde.

Bild 27.10 Die PowerShell-Aktivitäten werden ausgewählt...


Bild 27.11... und sind danach Teil der Toolbox.

```
TIPP: Werden die Toolbox-Elemente alphabetisch sortiert, lassen sich einzelne Elemente
leichter lokalisieren.
```
```
Bild 27.12 Die Toolbox-Elemente können sortiert werden.
```
Schritt 5


Als letzte Formalität muss in das Projekt ein Verweis auf die PowerShell-Assembly System.
Management.Automation.dll eingefügt werden, denn sie enthält jene Datentypen, die später über
die Definition einer Variablen und die Parameterübergabe benötigt werden. Klicken Sie im
Projektmappen-Explorer, der über das Ansicht-Menü gegebenenfalls sichtbar gemacht werden
muss, den Eintrag "Verweise" mit der rechten Maustaste an und wählen Sie "Verweis hinzufügen".
Auch diese Datei befindet sich im GAC unter c:\Windows\Microso.Net\Assemblies\GAC_MSIL und
dort im Verzeichnis System.Management.Automation. Wählen Sie in dem Unterverzeichnis dieses
Verzeichnisses die Datei aus und bestätigen Sie die Auswahl, um den Verweis hinzuzufügen.

Bild 27.13 In das Projekt muss ein Verweis...

Bild 27.14... auf die Assembly System.Management.Automation.dll hinzugefügt werden.

Schritt 6

Im nächsten Schritt wird der Workflow mit seinen Aktivitäten umgesetzt. Ordnen Sie als Erstes eine
Sequence-Aktivität aus dem Abschnitt "Ablaufsteuerung" auf der Designerfläche an. Hier werden
die einzelnen Aktivitäten platziert.


Bild 27.15 Die Sequence-Aktivität ist Teil der Kategorie "Ablaufsteuerung".

Bild 27.16 Der Workflow beginnt mit einer Sequence.

Schritt 7

Platzieren Sie in der Sequence-Aktivität die Aktivität "Get-Process", die damit als erste Aktivität in
den Workflow aufgenommen wird.

Bild 27.17 In den Workflow wurde die Get-Process-Aktivität aufgenommen.

Schritt 8

Das Ergebnis von Get-Process soll einer Variablen zugewiesen werden. Drücken Sie F4, um die
Eigenschaen der Aktivität anzuzeigen, und tragen Sie in der Zeile "Result" in das Eingabefeld auf


der linken Seite "Prozesse" ein. Das ist der Name einer Variablen, die aktuell noch nicht definiert
ist. Alternativ können Sie den Wert über den Ausdruckseditor eingeben, der durch einen Klick auf
den Button mit den drei Punkten geöffnet wird.

Bild 27.18 Im Eigenschaendialog werden die Commandlet-Parameter als Eigenschaen der Aktivität angeboten.

Bild 27.19 Im Ausdrucks-Editor erhält die Property Result einen Wert.

Da es die Variable Prozesse noch nicht gibt, ist eine Fehlermeldung die Folge, die durch ein rotes
Ausrufezeichen angezeigt wird.


Bild 27.20 Der Workflow enthält einen Fehler.

Schritt 9

In diesem Schritt wird die Variable Prozesse definiert. Im unteren Bereich des Workflow-Designers
werden die Kategorien "Variablen", "Argumente" und "Importe" angeboten. Selektieren Sie
"Variablen", um den Bereich zu öffnen, in dem Workflow-Variablen angezeigt und angelegt werden
können. Sollte in der Spalte "Name" keine Eingabe möglich sein, muss die Sequence-Aktivität
selektiert werden.

Bild 27.21 Die Variable "Prozesse" wird definiert.

Tragen Sie für den Namen "Prozesse" ein. Als Variablentyp wird "String" voreingestellt. Dies ist
aber der falsche Datentyp. Damit Get-Process seine Ausgabe in die Variable ablegen kann, muss
diese vom Typ "PSDataCollection<PSObject>" sein. Dieser Typ wird aber noch nicht in der Liste
angeboten, er muss daher über den Eintrag "Nach Typen suchen.. ." hinzugefügt werden.


Bild 27.22 Nicht jeder Datentyp wird am Anfang in der Auswahlliste angeboten.

Nach Auswahl von "Nach Typen suchen.. ." erscheint ein weiterer Auswahldialog. Hier kann einer
Variablen oder einem Parameter ein bestimmter Datentyp zugeordnet werden.

Bild 27.23 In diesem Auswahldialog werden Datentypen für eine Variable oder einen Parameter lokalisiert.

Geben Sie den Datentyp "PSDataCollection" in das Eingabefeld "Typname" ein. Sie werden
feststellen, dass er kurz danach in der Liste der referenzierten Assemblies aufgeführt wird. Sollte
dies nicht der Fall sein, wurde noch kein Verweis auf die Assembly System.Management.Automation
hinzugefügt und Sie müssen Schritt 5 wiederholen.

Bild 27.24 Der Datentyp PSDataCollection wurde gefunden.


Schritt 10

Das Einfügen des Datentyps geht aber noch nicht, es erscheint eine Fehlermeldung. Der Grund ist,
dass auch für den Typplatzhalter T ein Typ ausgewählt werden muss. Öffnen Sie die Auswahlliste
neben System.Management.Automation.PSDataCollection und lokalisieren Sie dieses Mal den Typ
"PSObject".

Bild 27.25 Auch der Typ "PSObject" muss zuerst lokalisiert werden.

Bild 27.26 PSObject wird für den Typ-Platzhalter T ausgewählt.

Damit kann Get-Process seinen Output der Variablen Prozesse zuweisen. Im Workflow-Designer
werden keine Fehler mehr angezeigt.

Bild 27.27 Der Workflow-Designer zeigt keine Fehler mehr an.


Schritt 11

Fügen Sie als zweite Aktivität Set-Content hinzu und platzieren Sie sie unterhalb von Get-Process.

Bild 27.28 Der Workflow umfasst eine zweite Aktivität.

Schritt 12

Tragen Sie für den Path-Parameter den Pfad "c:\Users\Administrator\WFOutput.txt" ein (der Pfad
muss natürlich existieren – ansonsten tragen Sie einen beliebigen Pfad ein, für den der Besitzer des
ausführenden PowerShell-Prozesses, in dem der Workflow gestartet wird, Schreibberechtigungen
besitzt). Doch auch hier ist es im Ausdrucks-Editor mit einem simplen String nicht getan. Wie es die
Parameterbeschreibung bereits vorgibt, muss hier ein String-Array angegeben werden, da dies der
Datentyp des Path-Parameters ist.
Der Workflow-Designer erwartet, dass der Typ entweder als C#- oder als Visual-Basic-Ausdruck
angegeben wird. Geben Sie in den Ausdrucks-Designer den folgenden Ausdruck ein:

```
New String() { "w:\Workflow\WFOutput.txt" }
```
Auf diese Weise wird in Visual Basic ein String-Array mit einem String definiert.


Bild 27.29 Im Im Ausdrucks-Designer wird der Wert für den Path-Parameter festgelegt.

Schritt 13

Das, was Set-Content bei der Ausführung des Workflows in die Datei schreiben soll, wird über den
Value-Parameter festgelegt. Da eine Zeichenkette geschrieben werden soll, geben Sie in den
Ausdrucks-Editor für diesen Parameter den folgenden Ausdruck ein:

```
New Object() { String.Format("Anzahl Prozesse: { 0 }", Prozesse.Count) }
```
Bild 27.30 Im Ausdrucks-Designer wird der Wert für den Value-Parameter festgelegt.

Schritt 14


Platzieren Sie unterhalb der Set-Content-Aktivität die Aktivität Restart-Computer. Sie soll den
Computer neu starten.

Schritt 15

Setzen Sie bei Restart-Computer sowohl den Wait- als auch den Force-Parameter auf den Wert
"True".

Bild 27.31 Ausdrucks-Designer wird der Wert für den Wait-Parameter festgelegt.

Schritt 16

Platzieren Sie unterhalb der Restart-Computer-Aktivität die Aktivität Get-Process. Tragen Sie im
Ausdrucks-Editor für den Parameter Result erneut die Variable Prozesse ein.

Schritt 17

Platzieren Sie unterhalb der Get-Process-Aktivität die Aktivität Add-Content. Tragen Sie für den
Path-Parameter den Pfad "w:\workflow\WFOutput.txt" ein und für den Value-Parameter erneut den
folgenden Wert im Ausdrucks-Editor ein:

```
New Object() { String.Format("Anzahl Prozesse: { 0 }", Prozesse.Count) }
```
Dieser Ausdruck bewirkt, dass die Anzahl der laufenden Prozesse als Teil der Zeichenkette in die
Datei geschrieben wird. Dies ist keine PowerShell-Syntax, sondern, wie bereits erwähnt, ein Visual-
Basic-Ausdruck.

Schritt 18


Platzieren Sie unterhalb der Add-Content-Aktivität die Aktivität Write-Output. Tragen Sie im
Ausdrucks-Editor für den Parameter InputObject den folgenden Ausdruck ein:

```
New PSObject() { "Fertig..." }
```
Bild 27.32 Im Ausdrucks-Editor erhält der Parameter InputObject seinen Wert.

Damit ist der Workflow fertig. Im Workflow-Designer sollten keine Fehler angezeigt werden.

Bild 27.33 Der Workflow umfasst insgesamt sieben Aktivitäten.

Schritt 19


Ändern Sie im Projektmappen-Explorer den Namen der Datei "Workflow1.xaml" in
"PSDemoWorkflow.xaml".

Bild 27.34 Der Name der Workflow-Datei wird geändert.

Schritt 20

Dieser Schritt ist optional. Erstellen Sie das Projekt über das Menü Erstellen und dort über den
Eintrag "DemoWorkflow neu erstellen". Beim Erstellen wird ein Fehler aureten. Die
Fehlermeldung besagt, dass die Assembly Microsoft.PowerShell.Workflow.ServiceCore nicht
gefunden werden kann. Fügen Sie diese Assembly-Bibliothek, wie unter Schritt 5 für
System.Management.Automation beschrieben, dem Projekt aus dem GAC als Verweis hinzu.

Bild 27.35 Die Assembly Microso.PowerShell.Workflow.ServiceCore.dll wird aus dem GAC als Verweis hinzugefügt.


Damit sollte sich das Projekt fehlerfrei erstellen lassen.

Bild 27.36 Beim Erstellen erscheinen in der Fehlerliste keine Fehler mehr.

Schritt 21

Damit ist der Workflow endlich fertig und kann in der PowerShell ausgeführt werden. Sie
benötigen dazu lediglich den Pfad der XAML-Datei.
Diesen erhalten Sie z. B. aus der XAML-Definition des Workflows, die Sie sich anschauen können,
indem Sie die Innenfläche des Workflow-Designers selektieren, F 7 drücken und die Abfrage mit
"Ja" bestätigen.

Bild 27.37 Umschalten auf den XAML-Code-Editor

In der XAML-Definition ist u. a. der Pfad der XAML-Datei enthalten.

Bild 27.38 Der Pfad der XAML-Datei ist Teil der XAML-Definition.

Schritt 22

Laden Sie die XAML-Definition über das Import-Module-Commandlet:

```
Import-Module -Name x:\Skripte\PSDemoWorkflow.xaml
```

Schritt 23

Ein Get-Module zeigt an, dass das Modul und damit der Workflow mit dem Namen
"PSDemoWorkflow" geladen wurden.

Bild 27.39 Das Modul mit dem Workflow PSDemoWorkflow wurde geladen.

Schritt 24

Führen Sie den Workflow unbedingt auf einem Remote-Computer aus, da ansonsten der aktuelle
Computer heruntergefahren wird: PSDemoWorkflow -PSComputer Server 1 - Credential
Administrator.

Bild 27.40 Der Workflow wird ausgeführt.

Schritt 25


Verbinden Sie sich im Rahmen einer Remote-Session mit dem Server, auf dem der Workflow
ausgeführt wurde, und sehen Sie nach, ob die Datei "WFOutput.txt" angelegt wurde, was der Fall
sein sollte.

Bild 27.41 Im Rahmen des Workflows wurde auf dem Server eine Datei angelegt.

Das war sehr viel Aufwand für ein einfaches Resultat. Bei der Übung ging es in erster Linie darum,
die Umsetzung eines PowerShell-Workflows mit Visual Studio zu demonstrieren. Man muss kein
Entwickler sein, da keine Programmierung vorkommt. Ganz ohne jegliche Grundkenntnisse aus
dem Bereich der Programmierung geht es aber nicht, da die Auswahl der Datentypen oder das
Festlegen eines Parameterwerts gewisse Kenntnisse voraussetzt. Das sind aber Kenntnisse, die
man sich relativ einfach aneignen kann, zumal die Art und Weise, wie ein Ausdruck im Ausdrucks-
Editor zusammengestellt wird, immer dieselbe ist und die angezeigten Fehlermeldungen sehr
hilfreich sind.


### 28 Ereignissystem

In der Windows-(Programmier-)Welt gibt es verschiedene Formen von
Ereignissen. Es gibt Einträge im Windows-Ereignisprotokoll, .NET-
Objekte können Ereignisse auslösen und die Windows Management
Instrumentation (WMI) kann Ereignisse auslösen. Auch die PowerShell
kennt eigene Ereignisse.

Das Ereignissystem in PowerShell bildet einen gemeinsamen Rahmen,
in dem sich alle vier vorgenannten Ereignisarten behandeln lassen.
Dabei werden die Windows-Ereignisprotokolle unter WMI-Ereignissen
erfasst.

28.1 WMI-Ereignisse

Die Windows Management Instrumentation (WMI) bietet eine
Ereignisinfrastruktur, die den Administrator über jegliche Veränderung
im WMI-Repository (z. B. Erzeugen einer neuen Instanz, Löschen einer
Instanz, Ändern des Werts einer Instanz) informieren kann. Auf diese
Weise kann sich ein Administrator über Änderungen informieren
lassen, z. B. das Starten oder Ende eines Prozesses oder Dienstes, das
Erzeugen einer neuen Datei in einem bestimmten Pfad oder das
Hinzufügen eines USB-Geräts. Den Ereignisauslöser spezifiziert man
dabei durch eine sogenannte WMI-Ereignisabfrage.


28.2 WMI-Ereignisabfragen

WMI-Ereignisabfragen sind genau wie normale WMI-Abfragen in der
WMI Query Language (WQL) verfasst, die SQL ähnlich ist, aber
Unterschiede aufweist.

Eine WMI-Ereignisabfrage bezieht sich immer auf eine WMI-
Ereignisklasse. Mit der WHERE-Klausel werden das zu beobachtende
Managed Object (MO) und die in dem MO zu beobachtenden Attribute
definiert.

```
SELECT * FROM eventklasse WHERE bedingung
```
Alle Ereignisklassen sind Unterklassen eines Ereignistyps. Die
Ereignistypen wiederum sind Unterklassen der Klasse __Event. Sie sind
in der Regel an dem führenden doppelten Unterstrich und der Endung
auf Event erkennbar. WMI unterscheidet vier Arten von Ereignissen
(siehe Tabelle).


Tabelle 28.1 WMI-Ereignisklassen. Die Ereignistypen sind die Oberklassen zu den rechts
genannten Ereignisklassen.

Ereignisart (Oberklasse) Ereignisklasse

```
__ClassOperationEvent __ClassCreationEvent
__ClassDeletionEvent
__ClassModificationEvent
__ExtrinsicEvent __SystemEvent
RegistryValueChangeEvent
Win32_ComputerShutdownEvent
Win32_ProcessStartTrace
Win32_SystemConfigurationChangeEvent
Win32_PowerManagementEvent
u. a.
__InstanceOperationEvent __InstanceCreationEvent
__InstanceDeletionEvent
__InstanceModificationEvent
```
```
__NamespaceOperationEvent __NamespaceCreationEvent
__NamespaceDeletionEvent
__NamespaceModificationEvent
```
```
ACHTUNG: Bitte beachten Sie, dass das Ereignis
__InstanceModificationEvent wirklich nur ausgeführt wird,
wenn sich ein Attributwert ändert. Wenn Sie beispielsweise die
Prozessorlast auf die Überschreitung der 80 %-Grenze prüfen,
dann bekommen Sie ein Ereignis beim Überschreiten der
Grenze. Wenn danach der Wert konstant bei 100 % liegt,
bekommen Sie keine weiteren Ereignisse. Sie erhalten erst
wieder ein Ereignis, wenn der Wert sich nochmals ändert (z. B.
von 100 % auf 99 %).
```
Ereignisabfragen unterstützen als zusätzliche SQL-Schlüsselwörter
WITHIN, GROUP BY und HAVING:


Dabei gibt WITHIN 10 das Abfrageintervall in Sekunden an (wird
immer gebraucht, wenn es keinen speziellen Ereignissender
gibt!).

GROUP BY bündelt eine Anzahl von Einzelereignissen zu einem
Gesamtereignis.

HAVING dient der Definition einer Bedingung innerhalb der
Gruppierung.


Tabelle 28.2 Beispiele für WMI-Ereignisabfragen

WQL Erläuterung

```
Select * From
__InstanceCreationEvent within 3
Where TargetInstance ISA
'Win32_Process'
```
```
Alle drei Sekunden wird
geprü, ob ein Prozess
gestartet wurde.
```
```
Select * From
__InstanceDeletionEvent within 2
Where TargetInstance ISA
'Win32_Process'
```
```
Alle zwei Sekunden wird
geprü, ob ein Prozess
beendet wurde.
```
```
SELECT * FROM
__InstanceCreationEvent WITHIN 30
WHERE TargetInstance ISA
'Win32_Process' AND
TargetInstance.Name = 'notepad.exe'
```
```
Alle dreißig Sekunden
wird geprü, ob der
Editor Notepad gestartet
wurde.
```
```
SELECT * FROM
__InstanceModificationEvent WITHIN 5
where TargetInstance ISA
'Win32_Service
```
```
Alle fünf Sekunden wird
geprü, ob sich etwas an
einem Systemdienst
geändert hat.
```
```
SELECT * FROM
__InstanceModificationEvent WITHIN 5
WHERE TargetInstance ISA
"Win32_Service" AND TargetInstance.
State="Stopped"
```
```
Alle fünf Sekunden wird
geprü, ob ein
Systemdienst den Status
Stopped bekommen hat.
```
```
SELECT * FROM
__InstanceCreationEvent WHERE
TargetInstance ISA "Win32_NTLogEvent"
AND
TargetInstance.Logfile="Application"
OR TargetInstance.Logfile="System"
```
```
Jeder neue Eintrag in
den Ereignisprotokollen
System und Application
löst ein Ereignis aus.
```
```
SELECT * from
Win32_SystemConfigurationChangeEvent
Es wird ständig geprü,
ob sich die
Systemkonfiguration
```

```
ändert (z. B. Anstecken
eines USB-Sticks).
```
28.3 WMI-Ereignisse seit PowerShell 1.0

Grundsätzlich war es schon in PowerShell 1.0 möglich, eine WMI-
Ereignisabfrage über die .NET-Klasse
System.Management.ManagementEventWatcher zu nutzen (siehe folgendes
Listing).

```
Listing 28.1 Skript zum Warten auf WMI-Ereignisse
[2_Aufbauwissen/WMI/WMI_EventListener.wps]
$scope = New-Object System.Management.ManagementScope("\\.\roo
t\cimV2")
$query = "SELECT * FROM __InstanceModificationEvent WITHIN 5 w
here TargetInstance ISA
'Win32_Service' AND TargetInstance.State='Stopped'"
$watcher = New-Object System.Management.ManagementEventWatcher
($scope,$query)
do
{
$b = $watcher.WaitForNextEvent()
"Ereignis: Dienst gestoppt: " + $b.TargetInstance.Name
}
while ($true) # Endlosschleife
```

28.4 Registrieren von

WMIEreignisquellen seit

PowerShell 2.0

Seit PowerShell 2.0 ist die Unterstützung für WMI-Ereignisabfragen
nun wesentlich komfortabler. Durch ein einziges Commandlet
(Register-WmiEvent) kann der Administrator die WMI-Ereignisabfrage
und die gewünschte Reaktion festlegen.

Das Commandlet Register-WmiEvent erzeugt ein Ereignis-Abonnement
für WMI-Ereignisse. Parameter des Commandlets sind:

```
query: Text der WMI-Ereignisabfrage
computer: System, auf dem die WMI-Ereignisabfrage ausgeführt
werden soll. Standard ist das lokale System.
sourceIdentifier: Name für das Abonnement. Dieser Name muss
in der aktuellen Power-Shell-Sitzung eindeutig sein.
messageData: Text, der beim Auslösen des Ereignisses in die WMI-
Ereignisliste geschrieben wird
action: auszuführende Aktion in Form eines PowerShell-Befehls
```
Es folgen einige Beispiele.

Beispiel 1: Beobachten, ob sich der Status eines Dienstes ändert:

```
Register-WmiEvent -query "SELECT * FROM __InstanceModification
Event WITHIN 5 where TargetInstance ISA 'Win32_Service'" - sour
ceIdentifier "Dienst:Status" - messageData "Der Status eines Di
enstes hat sich geändert!"
```
Beispiel 2: Beobachten, ob ein Prozess gestartet wird:


```
Register-WmiEvent -query "Select * From __InstanceCreationEven
t within 3 Where TargetInstance ISA 'Win32_Process'" - sourceId
entifier " "Prozessstart" " - MessageData "Ein neuer Prozess wu
rde gestartet!"
```
Beispiel 3: Beobachten, ob ein Prozess beendet wird:

```
Register-WmiEvent -query "Select * From __InstanceDeletionEven
t within 3 Where TargetInstance ISA 'Win32_Process'" - sourceId
entifier " "Prozessende" " - messageData "Ein Prozess wurde bee
ndet!"
```
Es ist sehr einfach, ein entferntes System zu überwachen, sofern der
Benutzer, der die Registrierung einleitet, dort Administrationsrechte
hat. Da der Fernzugriff auf WMI basiert, ist PowerShell Remoting hier
nicht erforderlich.

```
Register-WmiEvent -ComputerName F 171 - query "Select * From __I
nstanceCreationEvent within 1 Where TargetInstance ISA 'Win32_
Process'" - sourceIdentifier "F 171 Neuer -Prozess" - messageData
"Ein neuer Prozess wurde gestartet auf F171"
```
Zum Anzeigen aller registrierten Abonnements führt man aus:

```
Get-EventSubscriber
```
Zum Löschen eines Abonnements mit Unregister-Event muss man
Bezug auf den beim Erzeugen angegebenen Namen nehmen, z. B.:

```
Unregister-Event "Dienst:Status "
```
28.5 Auslesen der Ereignisliste


Das Commandlet Get-Event listet alle aufgetretenen Ereignisse auf.
Filtern ist möglich mit dem Parameter –SourceIdentifier oder
natürlich mit dem Commandlet Where-Object. Jedes ausgelöste
Ereignis hat einen eindeutigen EventIdentifier.

Beispiel 1:

```
Get-Event -sourceIdentifier "Dienst:Status"
```
Beispiel 2:

```
Get-Event | Where-Object {$_.MessageData -like "*Prozess*"}
```
Beispiel 3:

```
Get-event -eventidentifier 15
```
Um Details über das ausgelöste Ereignis zu erfahren, muss man das
Attribut SourceEventArgs und dessen Unterattribute betrachten.

Der Zugriff auf SourceEventArgs.NewEvent liefert eine Instanz einer
WMI-Ereignisklasse (z. B. root/CIMV 2 \__InstanceCreationEvent),
verpackt in das .NET-Objekt ManagementBaseObject.

```
(Get-event -eventidentifier 15 ).SourceEventArgs.NewEvent
```
Bild 28.1 Registrieren eines Ereignisses und Auslesen der Ereignisliste


Um zu erfahren, welches WMI-Objekt das Ereignis ausgelöst hat, grei
man auf TargetInstance zu:

```
(Get-event -eventidentifier 1 ).SourceEventArgs.NewEvent.Target
instance
```
Bild 28.2 Ausgabe von Details zu einem Ereignis

```
HINWEIS: Sie können nur aus der aktuellen PowerShell-
Sitzung auf die Ereignisliste zugreifen. Ein Zugriff von einer
zweiten Instanz der Power-Shell ist nicht möglich!
```

Die Ereignisse verbleiben so lange in der Liste, bis sie explizit gelöscht
werden oder die aktuelle PowerShell-Sitzung geschlossen wird.

Beispiel: Löschen des Ereignisses 123

```
Remove-Event -EventIdentifier 123
```
Beispiel: Löschen aller Ereignisse von der Ereignisquelle "Neuer
Prozess"

```
Remove-Event -Source "Neuer Prozess"
```
```
ACHTUNG: Remove-Event ohne Angabe eines Parameters löscht
die gesamte Ereignisliste.
```
28.6 Reagieren auf Ereignisse

Mit dem Parameter -action kann man Register-WmiEvent auch eine
direkte Vorgabe für eine Reaktion auf ein Ereignis in Form eines
PowerShell-Skriptblocks mitgeben. In dem Skriptblock kann man über
$eventArgs auf die gleichen Informationen zugreifen, die man bei Get-
Event über SourceEventArgs erhält, z. B. bei einem WMI-Ereignis des
Typs InstanceOperationEvent:

```
$eventArgs.NewEvent.TargetInstance.Name
```
Beispiel 1

Einfache Ausgabe, wenn ein Prozess gestartet wird:


```
Register-WmiEvent -query "Select * From __InstanceCreationEven
t within 3 Where TargetInstance ISA 'Win32_Process'" - sourceId
entifier "Neuer Prozess mit Aktion" – messageData "Ein neuer P
rozess wurde gestartet" - action { Write-Host "Neuer Prozess: "
$eventArgs.NewEvent.TargetInstance.Name }
```
Beispiel 2

Einfache Ausgabe, wenn ein Dienst sich ändert:

```
Register-WmiEvent -query "SELECT * FROM __InstanceModification
Event WITHIN 5 where TargetInstance ISA 'Win32_Service'" - sour
ceIdentifier "Dienst:Status:Aktion" - action { Write-Host "Der
Status des Dienstes" $eventArgs.NewEvent.TargetInstance.Name "
hat sich geändert. Status ist jetzt: " $eventArgs.NewEvent.Tar
getInstance.State }
```
Beispiel 3

Einfache Ausgabe, wenn auf einem entfernten System ein Prozess
startet:

```
Register-WmiEvent -ComputerName F 171 - query "Select * From __I
nstanceCreationEvent within 1 Where TargetInstance ISA 'Win32_
Process'" - sourceIdentifier "F 171 Neuer -Prozess: Aktion" - mes
sageData "Ein neuer Prozess wurde auf F 171 gestartet " - action
{ Write-Host "Neuer Prozes auf F171: " $eventArgs.NewEvent.Tar
getInstance.Name }
```
Der Skriptblock kann aber auch komplexer sein.


```
Listing 28.2 Versuch, einen gestoppten Dienst neu zu starten
[2_Aufbauwissen/Events/WPS2_WMIEvents_Service_Restart.ps1]
$Aktion = {
[console]::beep(440,10)
$dienst = $eventArgs.NewEvent.TargetInstance
Write-Host "Dienst $($dienst.Name): Der Status hat sich geände
rt. Status ist nun:
$($dienst.State)!" - ForegroundColor yellow
if ($dienst.State -eq "Stopped")
{
Write-Host "Neustart des Dienstes $($dienst.Name)..." - Foregroun
dColor yellow
Start-Service $dienst.Name
}
}
Register-WmiEvent -query "SELECT * FROM __InstanceModification
Event WITHIN 1 where TargetInstance ISA 'Win32_Service'" - sour
ceIdentifier "Dienst:Status:Aktion" - action $Aktion
```
Das obige Skript registriert bei Änderungen an Diensten einen
Skriptblock, der prü, ob ein Dienst nun beendet ist, und diesen dann
neu startet. Wie die folgende Abbildung zeigt, wird durch den Neustart
ein weiteres Ereignis ausgelöst.


Bild 28.3 Ablauf des Skripts WPS2_WMIEvents_DienstRestart.ps 1

28.7 W MI-Ereignisse seit PowerShell-

Version 3.0

Seit PowerShell-Version 3.0 gibt es als Alternative zu Register-
WmiEvent auch Register-CimIndicationEvent – mit den gleichen
Parametern.


```
Listing 28.3 Ablauf des Skripts WPS3_WMIEvents_Service_Restart.ps 1
$Aktion = {
[system.console]::beep(1540,30)
$dienst = $eventArgs.NewEvent.TargetInstance
Write-Host "Dienst $($dienst.Name): Der Status hat sich geände
rt. Status ist nun:
" $dienst.State "!" - ForegroundColor yellow
if ($dienst.State -eq "Stopped")
{
Write-Host "Neustart des Dienstes $($dienst.Name)..." - Foregroun
dColor yellow
Start-Service $dienst.Name
}
}
Register-CimIndicationEvent -query "SELECT * FROM __InstanceMo
dificationEvent WITHIN
1 where TargetInstance ISA 'Win32_Service'" - sourceIdentifier
"Dienst:Neustart"
```
- action $Aktion

28.8 Registrieren von .NET-Ereignissen

Auch viele .NET-Klassen besitzen Ereignisse, für die man sich in der
PowerShell 2.0 registrieren kann. Das Beispiel zeigt die Registrierung
für die Ereignisse Created, Changed und Deleted für die Klasse
System.IO.FileSystemWatcher, mit der man Veränderungen im
Dateisystem überwachen kann.


```
Listing 28.4 Warten auf Ereignisse im Dateisystem
[WPS2_DOTNETEvents_Filesystemobject.ps1]
$fsw = New-Object System.IO.FileSystemWatcher
$fsw.Path = "w:\temp"
$aktion = {
[console]::beep(440,10)
Write-Host "Dateisystemereignis: " $eventArgs.FullPath ": " $e
ventArgs.ChangeType
Write-Host
}
```
```
Register-ObjectEvent -InputObject $fsw -EventName Created -Act
ion $aktion
Register-ObjectEvent -InputObject $fsw -EventName Changed -Act
ion $aktion
Register-ObjectEvent -InputObject $fsw -EventName Deleted -Act
ion $aktion
```
Bild 28.4 Einsatz des obigen Skripts zur Datensystemüberwachung. Das obere PowerShell-
Fenster registriert die Änderungen, die das untere am Dateisystem vornimmt.


```
TIPP: Die Ereignisbindung für mehrere Ereignisse kann man
auch elegant in einer Schleife erledigen:
```
```
# # Trick: Alle Ereignisse auf einmal binden
foreach ($o in @("Created", "Deleted", "Changed", "Renam
ed"))
{
Register-ObjectEvent $fsw $o -Action $aktion
}
```
28.9 Erzeugen von Ereignissen

Die Ereignisinfrastruktur der PowerShell kann man auch unabhängig
von WMI verwenden. Die PowerShell bietet hierfür das Commandlet
New-Event zum Erzeugen eigenständiger Ereignisse.

```
New-Event -SourceIdentifier "Import beendet" - sender "Datenimp
ortskript" - MessageData
"Der Datenimport ist beendet" - eventarguments "Anzahl: 23345",
"Dauer: 12 sek"
```
Diese Ereignisse wandern auch in die Ereignisliste, die man mit Get-
Event einsehen kann. Auch diese Ereignisse gelten aber nur für die
aktuelle Sitzung.


Bild 28.5 Erzeugen eigener Ereignisse


# 29 Datenbereiche und

# Datendateien

PowerShell unterstützt (schon seit Version 2.0) Datenbereiche in
Skripten bzw. in externen Dateien, mit denen man Daten und
Programmcode besser voneinander trennen kann. Die Daten
können in mehreren Sprachen vorliegen, damit sich
mehrsprachige Skripte einfacher erstellen lassen.


```
HINWEIS: Bei einer kompilierten Anwendung würde kein
Sowareentwickler auf die Idee kommen, Daten, die sich
ändern können, direkt in den Quellcode einzubetten,
denn jede Änderung der Daten würde eine
Neukompilierung der Anwendung nach sich ziehen. Bei
Skripten, die im Quellcode ausgeliefert werden und die
dann beim Start interpretiert werden, ist es aber omals
durchaus ein adäquates Mittel, die Daten direkt in das
Skript einzubetten. Die Skriptdatei kann man schnell mit
jedem Texteditor ändern.
Sofern die Datenmenge nicht zu groß ist, ist der Vorteil bei
der Kombination von Daten und Skript in einer Datei, dass
man eine bessere Übersicht hat und es nicht passieren
kann, dass die Datendatei verloren geht bzw. bei einem
Kopier- oder Verschiebevorgang von dem Skript getrennt
wird.
```
###### 29.1 Datenbereiche

Ein PowerShell-Datenbereich beginnt mit dem Befehlswort Data.
Danach folgen in geschweien Klammern die Daten, jeweils eine
Information pro Zeile. Der Datenbereich darf Kommentare
beinhalten (beginnend mit dem Zeichen "#", siehe Listing); diese
müssen in eigenen Zeilen stehen. Der Datenbereich wird einer
Variablen zugewiesen, deren Name in PowerShell immer mit
einem Dollarzeichen beginnen muss.


Über den Variablennamen erfolgt die Nutzung der Daten. Ein
Zugriff auf den Variablennamen liefert alle Daten ohne die
Kommentare. Der Zugriff auf den Index $Variable[x] liefert die x-
te Information, wobei auch hier alle Kommentare ignoriert
werden. Wenn man sich den Typ der Variablen mit Get-Member
ansieht, so erkennt man, dass PowerShell den Datenbereich als
ein Object-Array ablegt und darin jede einzelne Information
entweder mit ihrem jeweiligen Standarddatentyp (z. B. die 1 wird
als System. Int 32 abgelegt) oder gemäß des explizit
angegebenen Datentyps wie im Fall [system.datetime] "1. 7.
2013" speichert. Ein Zugriff auf ein Element über die Obergrenze
hinaus liefert keine Fehlermeldung, sondern den Null-Wert,
(siehe letzte Codezeile: $intro[ 5 ]).


```
Listing 29.1 Definition und Nutzung eines Datenbereichs in PowerShell-Skripten
# ------ 1. Datenbereich
$Intro = Data {
# Erste Information
"Beispiel für einen PowerShell-Datenbereich"
# Autor
"Dr. Holger Schwichtenberg"
# Blog
"www.dotnet-doktor.de"
# Erstellungstermin
[system.datetime] "1. 7. 2013"
# Version
1
}
# ------ Zugriff auf alle Daten aus dem 1. Datenbereich
$intro | gm
```
```
# ------ Zugriff auf einzelne Daten aus dem 1. Datenbereic
h
"Skriptbeschreibung $($intro[ 0 ])"
"Autor: $($intro[ 1 ])"
"Blog: $($intro[ 2 ])"
"Version: $($intro[ 4 ])"
"Datum: $($intro[ 3 ])"
"Sonstiges: $($intro[ 5 ])"
```
Der Zugriff über die Position ist nicht sehr erquicklich, daher
unterstützt die PowerShell auch Datenbereiche mit Hash-
Tabellen. Auch dort ist jede Zeile ein Element, wobei die Zeile
jeweils Namen und Wert enthält, getrennt durch ein
Gleichheitszeichen. Die Name-Wert-Paare müssen in eine


mehrzeilige Zeichenkette (im PowerShell-Jargon "Here-String")
eingebettet sein (@'...'@).

Das Commandlet ConvertFrom-StringData sorgt für die
Aufspaltung der Name-Wert-Paare. Es muss, wie das nächste
Listing zeigt, in der Data-Sektion eingesetzt werden. Das Listing
umfasst zwei Datenbereiche mit den Elementen Startmeldung,
Endemeldung und Fehlermeldung.

Im Programmcode kann man dann über
"$Datenbereichname.Elementname" (z. B. $Texte.
Startmeldung) auf die Elemente zugreifen. Auch dies zeigt das
nächste Listing.


```
Listing 29.2 Datenbereiche mit Hashtable in PowerShell-Skripten
# ------ 2. Datenbereich
$Texte = Data {
ConvertFrom-StringData @'
# Standardmeldungen
Startmeldung = Skript beginnt
Endemeldung = Skript beendet!
'@}
```
```
# ------ 3. Datenbereich
$Fehlertexte = Data {
ConvertFrom-StringData @'
# Besondere Meldungen
Fehlermeldung = Es ist ein Fehler aufgetreten: Arbeiten Si
e nicht nach 17 Uhr!
'@}
```
```
# ------ Verwendung des 2. Datenbereichs
$Texte.Startmeldung
```
```
# ------ Verwendung des 3. Datenbereichs
if ([DateTime]::Now.Hour -ge 17 ) { Write-Host $Fehlertext
e.Fehlermeldung }
```
```
# ------ Verwendung des 2. Datenbereichs
$Texte.Endemeldung
```
Die folgende Abbildung zeigt, dass der mitgelieferte Editor
"PowerShell Integrated Scripting Environment" (ISE) auch in der
aktuellen Version in PowerShell 5.x die Farbunterscheidung
zwischen Elementen und Kommentarzeilen bei Daten in Here-


Strings im Gegensatz zu einfachen Datensektionen nicht mehr
leistet.

Bild 29.1 Die Farbhervorhebung versagt bei Datensektionen mit Here-Strings
[2_Aufbauwissen\Datafiles\ WPS2_DataSection.ps1]

###### 29.2 Datendateien

In Skripte eingebettete Daten sind aber sicherlich auch
Geschmackssache. Viele Entwickler werden für eine klare
Trennung zwischen Programmcode und Daten votieren. Einen
Power-Shell-Datenbereich kann man auch in einer
eigenständigen Datei mit der Dateinamenerweiterung .psd 1
speichern, siehe Listing. Die Datendateien müssen etwas anders
aufgebaut sein; es darf hier keine Variablendeklaration geben.


```
Listing 29.3 Externe Datendatei als .psd1-Datei
ConvertFrom-StringData @'
# Standardmeldungen
Startmeldung = Skript beginnt
Endemeldung = Skript beendet!
# Besondere Meldungen
Fehlermeldung = Es ist ein Fehler aufgetreten: Arbeiten Si
e nicht nach 17 Uhr!
'@
```
Den Inhalt dieser Datei lädt man dann mit Import-LocalizedData
(siehe nächstes Listing) und weist ihn damit einer Variablen zu.
Das Commandlet lädt automatisch eine. psd 1 - Datei, die im
gleichen Verzeichnis liegt und den gleichen Namen besitzt (aber
eine andere Dateinamenserweiterung: also Skriptdaten abc.ps 1
lädt abc.psd 1 ).


```
Listing 29.4 Nutzung der .psd1-Datei
$Texte = Import-LocalizedData `
```
- BaseDirectory $PSScriptRoot `
- FileName WPS2_DataFile.psd 1

```
# ------ Verwendung des 1. Datenbereichs
$Texte.Startmeldung
```
```
# ------ Verwendung des 2. Datenbereichs
if ([DateTime]::Now.Hour -ge 17 ) { Write-Host $Texte.Fehle
rmeldung }
```
```
# ------ Verwendung des 1. Datenbereichs
$Texte.Endemeldung
```
Alternativ kann man natürlich auch mit dem Parameter -FileName
einen anderen Namen angeben. Wenn die Datendatei auch noch
in einem anderen Verzeichnis liegt, darf man den
Verzeichnisnamen aber nicht vor dem Dateinamen angeben,
sondern muss den Parameter -BaseDirectory dazu bemühen, z.
B.

```
$Texte = Import-LocalizedData -BaseDirectory D:\Datafiles\
```
- FileName WPS_DataFile.
psd 1
$Texte = Import-LocalizedData

###### 29.3 Mehrsprachigkeit/Lokalisierung


Die PowerShell unterstützt (seit Version 2.0) die Lokalisierung
von Skripten durch das Anlegen von mehreren Datendateien für
unterschiedliche Sprachregionen. Dabei verwendet die
PowerShell ein Verfahren, das angelehnt ist an das im .NET
Framework verwendete Lokalisierungsverfahren.

Sprachen unterscheidet die PowerShell wie das .NET Framework
mit Sprachkürzeln, z. B. "de" für die deutsche Sprache und "en"
für die englische Sprache. Man kann auch genauer nach
Regionen differenzieren, z. B. "de-DE" für die deutsche Sprache
in Deutschland, "de-CH" für die deutsche Sprache in der Schweiz,
"en-GB" für Englisch in England und "en-US" für Englisch in den
USA.

Sofern im Skript keine andere Weisung erfolgt, orientiert sich die
PowerShell an der für die Windows-Benutzeroberfläche
eingestellten Anzeigesprache (UI Culture), die immer aus Sprache
und Region besteht. Wird die Kombination (z. B. "de-DE") nicht
gefunden, wird nur nach der Sprache (z. B. "de") gesucht. Wird
auch diese nicht gefunden, sucht die PowerShell nach einer
Standardsprache (neutrale Sprache).

Zunächst legt man für jedes Sprachkürzel ein Unterverzeichnis
relativ zum Pfad des Skripts an. Jedes Unterverzeichnis erhält
eine sprachspezifische Kopie der .psd1-Datendatei, siehe nächste
Abildung sowie folgende Listings.


Bild 29.2 Verzeichnisstruktur für Lokalisierung mit Deutsch, britischem Englisch und
amerikanischem Englisch sowie einer "neutralen" Sprache

```
Listing 29.5 Datendatei Data/en-US/WPS2_LocalDataFile.psd 1
```
```
ConvertFrom-StringData @'
# Standardmeldungen
Startmeldung = Script starts ...
Endemeldung = Script finished!
# Besondere Meldungen
Fehlermeldung = An error occurred: Don't work after 5 p.
m.!
'@
```

```
Listing 29.6 Datendatei Data/en-GB/WPS2_LocalDataFile.psd 1 – etwas höflicher
als im Amerikanischen
ConvertFrom-StringData @'
# Standardmeldungen
Startmeldung = Script starts ...
Endemeldung = Script finished!
# Besondere Meldungen
Fehlermeldung = An error occurred: Don't work after five
o'clock, please!
'@
```
Bei Import-LocalizedData gibt man dann das Wurzelverzeichnis
an. Die konkret zu ladende Datendatei richtet sich nach der
aktuellen UICulture, die man mit dem Commandlet Get-
UICulture oder der globalen Variablen $PSUICulture auslesen
kann. $PSUICulture ist die eingestellte "Anzeigesprache".
$PSCulture ist die "Formatsprache" für Datum, Uhrzeit und
Währung.

Leider kann man auf $PSUICulture nicht schreibend zugreifen,
um die Sprache im laufenden Programmcode zu ändern. Man
kann aber, wie man es in .NET gewohnt ist, das Property
CurrentUICulture im Objekt
[System.Threading.Thread]::CurrentThread ändern (siehe
Listing). Nach einem Ändern der Thread-Sprache muss man
ImportLocalizedData (erneut) aufrufen! Alternativ kann man bei
Import-LocalizedData auch den zusätzlichen Parameter -
UICulture de-de angeben.


```
Listing 29.7 Umschalten der Sprache im Ablauf einer Skriptdatei
[System.Threading.Thread]::CurrentThread.CurrentUICulture
= New-Object
System.Globalization.CultureInfo("de-de")
$texte = Import-LocalizedData -BaseDirectory d:\Datafiles
$Texte.Startmeldung
if ([DateTime]::Now.Hour -le 17 ) { Write-Host $Texte.Fehle
rmeldung }
$Texte.Endemeldung
```
Aber Achtung: Nach einem Umschalten mit CurrentUICulture
aktualisieren sich die Werte, die Get-UICulture und $PSUICulture
liefern, leider nicht, siehe Bild.

Bild 29.3 Get-UICulture und $PSUICulture liefern keine aktuellen Werte.


# 30 Desired State

# Configuration (DSC)

Desired State Configuration (DSC) ist ein deklaratives Verfahren
zur Systemkonfiguration, das Microso mit der PowerShell
Version 4.0 erstmals eingeführt hatte. Seit PowerShell 7.2 ist DSC
nicht mehr Teil der PowerShell, sondern ein getrenntes Modul in
der PowerShell Gallery.


HINWEIS: Während DSC zu Zeiten von PowerShell 4.0
noch einen sehr bescheidenen Funktionsumfang hatte,
gibt es mittlerweile doch einige DSC-Ressourcen.
Allerdings liefert Microso diese nicht mit der PowerShell
oder Windows aus, sondern stellt sie über die PowerShell
Gallery unter dem Oberbegriff "DSC Resource Kit" [siehe
[http://www.powershellgallery.com/packages?](http://www.powershellgallery.com/packages?)
q=Tags% 3 A% 22 DSCResourceKit% 22 ] zum Nachladen zur
Verfügung. Zum Stand 4.12.2015 gibt es dort 229
Ressourcen.

Allerdings fällt auf, dass alle diese Ressourcen mit einem
"x" beginnen, wobei dieser Buchstabe für "experimentell"
steht, d. h., Microso gibt keinerlei Support für diese
Ressourcen. Sie können bei Problemen damit also nicht
bei Microso anrufen! Seit April 2015 ist das "DSC
Resource Kit" – wie viele andere Microso-Produkte im
Namen der neuen Offenheit des Unternehmens – im
Status "Open Source". Den Quellcode, den jedermann
auch nach Belieben verändern darf, finden Sie unter

https://github.com/powershell/dscresources

und

https://github.com/Microso/PowerShell-DSC-for-Linux.


```
HINWEIS: Noch ein Vorwort zu DSC: Sie werden in diesem
Kapitel sehen, dass DSC an einigen Stellen zu kompliziert
ist und der Aufwand höher ist als mit normalen
PowerShell-Commandlets und -Skripten. Dennoch soll
DSC hier im Buch nicht verschwiegen werden. DSC kann
durch die idempotente Ausführung auch prägnanter sein,
wenn die DSC-Ressourcen mächtig genug sind.
Entscheiden Sie selbst, was Ihnen besser gefällt.
```
###### 30.1 Grundprinzipien

Bei klassischer scriptbasierter Konfiguration legt der
Administrator die einzelnen Schritte zur Zielkonfiguration fest. Er
muss in der Regel vor Beginn eines Konfigurationsschritts prüfen,
ob die Konfiguration schon vorhanden ist, bevor er sie ausführt.
Auch das Rückgängigmachen einer Konfiguration muss er durch
einzelne explizite Schritte realisieren und dabei insbesondere
Fälle berücksichtigen, bei denen eine komplexere Konfiguration
vielleicht nur teilweise vorhanden ist.

Bei DSC hingegen beschreibt der Administrator deklarativ nur das
Ziel einer Konfiguration. DSC ist selbst in der Lage, den aktuellen
Zustand zu prüfen, einen nicht notwendigen Schritt zu
überspringen, eine aus (vielen) Teilen bestehende Konfiguration
durchzusetzen und auch diese Schritte wieder rückgängig zu
machen.


```
HINWEIS: Aus der Sicht von DSC ist es kein Fehler, wenn
eine Konfiguration (oder Teile davon) schon vorhanden ist
(idempotente Ausführung).
```
Alle DSC-Prozesse werden ausgeführt von einem Windows-
Systembaustein namens "Local Configuration Manager" (LCM).

###### 30.2 DSC für PowerShell 7

DSC war in Windows PowerShell 4.0 bis PowerShell 7.1 Teil der
PowerShell. In PowerShell 7.0 und 7.1 war DSC-Version 2.0
enthalten.

Seit PowerShell-Version 7.2 hat Microso DSC vom PowerShell-
Kern abgetrennt und in ein Modul in der PowerShell Gallery
[https://www.powershellgallery.com/packages/PSDesired
StateConfiguration] ausgelagert. Daher muss seit PowerShell 7.2
DSC zunächst installiert werden, wenn man es nutzen will:

```
Install-Module -Name PSDesiredStateConfiguration -Reposito
ry PSGallery
```

Bild 30.1 Installation des neuen DSC-Moduls


Bild 30.2 Zum Redaktionsschluss dieses Buchs ist die Version 2.0.5 die aktuelle
stabile Version des DSC-Moduls. Microso arbeitet seit einiger Zeit an Version 3.0.


```
ACHTUNG: Die Abtrennung von DSC von der PowerShell
in Version 7.2 stellt einen "Breaking Change" dar, denn
DSC-Befehle laufen nun nicht mehr ohne vorherige
Installation des Moduls. Dies ist ein Verstoß gegen das
Semantic Versioning [https://semver.org/]: Änderungen an
der zweiten Stelle der Versionsnummer dürfen keine
Breaking Changes enthalten!
```
###### 30.3 Ressourcen

DSC kennt "Ressourcen". Für eine Ressource (z. B. Benutzer,
Gruppen, Dienste, Umgebungsvariablen, Prozesse, Registry)
definiert der Administrator den Zielzustand. Zu jeder
konfigurierbaren Ressource gibt es in der PowerShell einen DSC-
Ressourcentyp (z. B. User, Group, Service, Environment, Process,
Registry).

Eine sehr universelle Ressource ist die "Script"-Ressource. Mit
dieser kann man beliebige PowerShell-Skripte in einer DSC-Datei
verwenden und so auch Aktionen ermöglichen, die nicht durch
eine der bestehenden Ressourcen abgedeckt sind. Das Pendant
unter Linux, das beliebige Shell-Sprachen unterstützt, ist die
Ressource "nxScript".


```
TIPP: Die Ressourcentypen sind erweiterbar. Zusätzliche
Ressourcen gibt es in der PowerShell Gallery:
http://www.powershellgallery.com. Man kann auch selbst eigene
Ressourcen schreiben.
```
###### 30.4 Verfügbare DSC-Ressourcen

Die Tabelle zeigt die mit PowerShell 5.x ausgelieferten DSC-
Ressourcen (das sind nur wenige, von denen hier alle genannt
sind) sowie ausgewählte DSC-Ressourcen aus der PowerShell
Gallery (das sind viele, von denen hier nur wenige genannt sind)
zur Verwaltung von Windows, Microso Azure (Cloud) und Linux.


Tabelle 30.1 Eine kleine Auswahl der verfügbaren DSC-Ressourcentypen

```
Ressource Bedeutung und
wichtige Eigenschaen
```
Quelle

```
Archive Entpacken von ZIP-
Dateien. Die Quelle ist
bei Path anzugeben, das
Ziel bei DestinationPath.
```
```
PowerShell
5.x
```
```
Environment Einstellen einer
Umgebungsvariablen,
die durch Name und Value
festgelegt ist
```
```
PowerShell
5.x
```
```
File Verwaltung von Dateien
und Ordnern. Mit Type
unterscheidet man File
und Directory.
DestinationPath legt den
Zielpfad fest, Contents
den Inhalt. SourcePath ist
die Quelle, Recurse=$true
oder $false die
Rekursion.
```
```
PowerShell
5.x
```
```
Group Erstellen von
Benutzergruppen.
GroupName ist der Name
der Gruppe, Members legt
die Mitglieder fest.
```
```
PowerShell
5.x
```
```
Log
```

```
Eintrag im
Ereignisprotokoll.
Einzige Eigenscha ist
Message.
```
```
PowerShell
5.x
```
Package Installationspakete (MSI

```
oder setup.exe). Name ist
der Paketname, Path die
Herkun. Pflichtangabe
ist auch die GUID
ProductID. Mit Arguments
kann man Parameter
übergeben. ReturnCode
spezifiziert den
erwarteten
Rückgabewert.
```
```
PowerShell
5.x
```
WindowsProcess Start von Prozessen. Die

```
Herkun wird über Path
festgelegt, die Parameter
über Arguments.
WorkingDirectory ist das
Arbeitsverzeichnis.
```
```
PowerShell
5.x
```
Registry Erstellen von Registry-

```
Einträgen mit Key,
ValueName, ValueType und
ValueData
```
```
PowerShell
5.x
```
WindowsFeature,
WindowsOptional
Feature

```
Installieren von
Windows-Server-Rollen
(vgl. Add-
```
```
PowerShell
5.x
```

```
WindowsFeature). Die zu
installierende Rolle wird
durch Name festgelegt.
Dies ist nur möglich auf
Windows-Server-
Betriebssystemen.
```
Script Allgemeiner

```
Ressourcentyp, um
beliebige PowerShell-
Skripte auszuführen.
Dabei sind drei Skripte
anzugeben: TestScript
prü, ob die
Konfiguration vorhanden
ist. SetScript führt die
Konfiguration aus, wenn
TestScript den
Rückgabewert $false
lieferte. GetScript liefert
eine Hashtable mit der
Konfiguration.
```
```
PowerShell
5.x
```
Service Zustandsänderung von

```
Windows-
Systemdiensten. Name ist
der Dienstname, State
der gewünschte Zustand
(Running oder Stopped).
Auch StartType und ein
Konto (BuildInAccount
```
```
PowerShell
5.x
```

```
oder Credentials) kann
man angeben.
```
User Anlegen eines lokalen

```
Benutzers, der durch
User-Name, Description,
Fullname und Password
festgelegt wird.
Außerdem kann man
Password-
ChangeNotAllowed,
PasswordChangeRequired
und
PasswordNeverExpires
jeweils auf $true oder
$false setzen.
```
```
PowerShell
5.x
```
Computer Benennen eines

```
Computers und
Hinzufügen zu einer
Domäne oder
Arbeitsgruppe.
Eigenschaen sind Name,
Domain und Workgroup.
```
```
DSC Resource
Kit
```
xVHD Anlegen von VHD-

Dateien

```
DSC Resource
Kit
```
xVMHyperV Anlegen von virtuellen

Systemen in HyperV

```
DSC Resource
Kit
```
xVMSwitch Anlegen eines virtuellen

Netzwerkswitches in

```
DSC Resource
Kit
```

HyperV

xDNSServerAddress Festlegen von DNS-

```
Servern in der
Netzwerkkonfiguration
```
```
DSC Resource
Kit
```
xWebsite Veröffentlichen und

```
Konfigurieren einer
Website in den Internet
Information Services
(Name, Physical Path,
State, Protocol,
BindingInfo,
ApplicationPool)
```
```
DSC Resource
Kit
```
xIPAdress Festlegen der IP-Adresse

```
einer
Netzwerkverbindung
```
```
DSC Resource
Kit
```
xFirefox, xChrome Installation der aktuellen

```
Version des Firefox-
Browsers und des
Chrome-Browsers
```
```
DSC Resource
Kit
```
xWinEventLog Konfiguration der

```
Windows-
Ereignisprotokolle
```
```
DSC Resource
Kit
```
xSmbShare Erstellen einer

Dateisystemfreigabe

```
DSC Resource
Kit
```
xExch... Diverse Ressourcen zur DSC Resource


```
Microso-Exchange-
Server- Konfiguration
```
Kit

xADUser,
xADDomainTrust,
xADDomain-
Controller,
xADDomain,
xWaitForADDomain

```
Active-Directory-
Konfiguration
```
```
DSC Resource
Kit
```
xAzureVM Verwalten virtueller

```
Machines im Cloud-
Dienst "Microso Azure"
```
```
PowerShell
Gallery
```
xAzureSQLDatabase Verwalten von SQL-

```
Datenbanken im Cloud-
Dienst "Microso Azure"
```
```
PowerShell
Gallery
```
nxComputer Verwalten von

```
Computername,
Domänenname und
Zeitzone auf einem
Linux-System
```
```
PowerShell
Desired State
Configuration
for Linux
```
nxIPAddress IP-Adresskonfiguration

auf einem Linux-System

```
PowerShell
Desired State
Configuration
for Linux
```
nxService Dienste auf Linux-

Systemen

```
PowerShell
Desired State
Configuration
for Linux
```

nxFile Dateien und Ordner auf

Linux-Systemen

```
PowerShell
Desired State
Configuration
for Linux
```
nxPackage Sowarepakete auf

Linux-Systemen

```
PowerShell
Desired State
Configuration
for Linux
```
nxUser Lokale Benutzer auf

Linux-Systemen

```
PowerShell
Desired State
Configuration
for Linux
```
nxGroup Lokale Gruppen auf

Linux-Systemen

```
PowerShell
Desired State
Configuration
for Linux
```
nxScript Ausführung beliebiger

```
Linux-Skripte, wo die
Skriptsprache durch ein
Shebang (z. B. #!/bin/sh
oder #!/bin/bash) zu
Beginn des Skripts
definiert werden muss
```
```
PowerShell
Desired State
Configuration
for Linux
```
nxEnvironment Umgebungsvariablen auf

Linux-Systemen

```
PowerShell
Desired State
Configuration
for Linux
```

###### 30.5 Eigenschaen einer Ressource

Ressourcen haben Eigenschaen, die die Arbeit der Ressource
steuern und den Zielzustand festlegen. Die Eigenschaen werden
gemäß der Syntax Name="Wert" zugewiesen.

Alle Ressourcen haben folgende gemeinsamen Eigenschaen:

```
Ensure="Present" oder "Absent": Diese Eigenscha sorgt
dafür, dass eine Konfiguration durchgesetzt (falls sie nicht
vorhanden ist) oder rückgängig gemacht wird (falls sie
vorhanden ist).
DependsOn="[Ressourcentypename]RessourceName" ist ein
Verweis auf einen Ressourcenblock in derselben DSC-Datei.
Die dortige Bedingung muss erfüllt sein, bevor dieser
Ressourcenblock ausgeführt werden kann. Leider kann man
hier nicht mehrere Ressourcenblöcke angeben (zumindest
ist bei Microso nicht dokumentiert, wie es gehen soll, und
zahlreiche Versuche mit verschiedenen Syntaxformen haben
nicht zum Ziel geführt).
Mit der Eigenscha PSDSCRunAsCredential, die seit
PowerShell 5.0 auf allen Ressourcen verfügbar ist, kann eine
Ressourcenkonfiguration unter einem abweichenden
Benutzerkonto laufen. Mit partiellen DSC-Konfigurationen
kann der Benutzer eine Ressourcendeklaration auf mehrere
Dateien aueilen.
```
###### 30.6 Aufbau eines DSC-Dokuments


DSC-Dokumente deklarieren Eigenschaen für bestimmte
Instanzen von Ressourcen. Ein DSC-Dokument beginnt mit dem
Schlüsselwort configuration, gefolgt von dem im Rahmen der
gültigen PowerShell-Bezeichner frei wählbaren Namen der
Konfiguration. In geschweien Klammern folgt ein DSC-Knoten
(engl. Node) mit einem Rechnernamen oder einer IP-Adresse.
Innerhalb der DSC-Knoten gibt es einen oder mehrere DSC-
Ressourcenblöcke. Jeder Ressourcenblock bezieht sich auf eine
Ressourceninstanz und legt deren Eigenschaen fest. Der
Ressourcenblock beginnt mit Ressourcennamen und dann einem
im Rahmen der gültigen PowerShell-Bezeichner frei wählbaren
Namen für den Block. Ein DSC-Knoteneintrag kann fehlen, d. h.,
configuration { } kann direkt DSC-Ressourcenblöcke enthalten.
In diesem Fall bezieht sich die Konfiguration auf den lokalen
Rechner.

Es darf auch mehrere DSC-Knoteneinträge in einer Datei geben.
Es darf innerhalb einer Konfiguration und innerhalb eines DSC-
Knoteneintrags mehrere Einträge für den gleichen
Ressourcentyp, aber nicht für die gleiche Ressourceninstanz
geben. Zudem muss jeder Ressourcenblock aber einen
eindeutigen Namen haben, sonst kommt es zum Fehler
"duplicate resource identifier".

###### 30.7 Commandlets für die Arbeit mit

###### DSC

Für die Nutzung von DSC gibt es einige Commandlets.


Tabelle 30.2 DSC-Commandlets

Commandlet Beschreibung

```
Start- DscConfiguration Ausführen einer
Konfiguration
```
```
Get-DscConfiguration Liest die zuletzt auf einen
Computer angewendete DSC-
Konfiguration aus
```
```
Get-DscResource Liste aller lokal installierten
DSC-Ressourcentypen in
Form von Instanzen von
DscResourceInfo
```
```
Dieses Commandlet findet
auch die selbst erstellten und
bereits kompilierten
Konfigurationen.
```
```
Test-DscConfiguration Prü, ob auf einem Computer
die gewünschte
Konfiguration vorhanden ist
```
```
Restore-DscConfiguration Wiederherstellen der
vorherigen
Konfiguration/setzt einen
Computer auf einen
vorherigen Zustand zurück
```
```
Get-
DscLocalConfigurationManager
```
```
Auslesen der Konfiguration
des "Local Configuration
```

Manager"

```
New-DscCheckSum Erzeugt Prüfsummen für DSC-
Dateien und DSC-
Ressourcentypen
```
```
Set-
DscLocalConfigurationManager
```
```
Ändern der Konfiguration des
"Local Configuration
Manager"
```
###### 30.8 Ein erstes DSC-Beispiel

Das folgende Listing zeigt ein minimales Beispiel für eine DSC-
Datei mit dem Konfigurationsnamen "DSCErstesBeispiel" mit
einem DSC-Knoten und zwei DSC-Ressourcenblöcken mit Namen
"RegEintrag 1 Erzeugen" und "RegEintrag 2 Erzeugen" für den
Ressourcentyp Registry, die dafür sorgen, dass es zwei Windows-
Registrierungsdatenbankeinträge "Inhaber" und "Produkte" im
Schlüssel "HKEY_LOCAL_MACHINE\SOFTWARE\www.IT-
Visions.de" gibt. Die Konfiguration wird auf dem lokalen System
ausgeführt, was durch "node localhost" ausgedrückt wird.

Diese Datei kann man unter beliebigem Namen ablegen, gefolgt
von der Dateinamenserweiterung .ps1. Es bietet sich an, die Datei
wie die Konfiguration zu benennen, also DSC ErstesBeispiel.ps 1.


```
Listing 30.1 [/2_Aufbauwissen/DSC/DSC_ErstesBeispiel.ps1]
"Lade DSC..."
configuration DSCErstesBeispiel
{
node localhost
{
Registry RegEintrag 1 Erzeugen
{
Ensure ="Present"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\www.IT-Visions.de"
ValueName="Inhaber"
ValueData="Dr. Holger Schwichtenberg"
}
Registry RegEintrag 2 Erzeugen
{
Ensure ="Present"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\www.IT-Visions.de"
ValueName="Produkte"
ValueData="Schulung,Beratung,Support"
}
}
}
"DSC ist geladen!"
```
###### 30.9 Kompilieren und Anwendung

###### eines DSC-Dokuments


Das DSC-Dokument muss für die Ausführung in das Managed
Object Format (MOF), das die Desktop Management Task Force
(DMTF) im Rahmen des Common Information Model (CIM)
spezifiziert hat [vgl. https://www.dmtf.org/standards/cim],
umgewandelt werden. MOF basiert auf der Interface Definition
Language (IDL).

Um das DSC-Dokument anzuwenden, sind drei Schritte
notwendig:

1. Das DSC-Dokument muss ausgeführt werden wie eine
    normale PowerShell-Skriptdatei (in der ISE oder an der
    Kommandozeile). Normalerweise erhält man dabei keine
    Ausgabe. In dem Fall des obigen ersten Beispiels erhält man
    eine Ausgabe, weil vor und nach dem configuration-Block
    noch Ausgabebefehle stehen.
2. Nun kompiliert man die Konfiguration, indem man den
    Namen der Konfiguration an der Konsole wie den Namen
    einer PowerShell-Funktion ausführt. Das Ergebnis ist eine
    MOF-Datei. Die PowerShell antwortet mit dem Namen der
    erzeugten MOF-Datei. Dies ist im obigen Fall, wo es keinen
    dedizierten DSC-Knoten gibt, der Name "localhost.mof". Die
    Datei landet in einem Unterverzeichnis, das so heißt wie die
    Konfiguration. Man sollte dabei aufpassen, wo man mit dem
    aktuellen Verzeichnis steht, denn die Datei wird relativ zum
    aktuellen Standort abgelegt.
3. Im letzten Schritt wird nun die kompilierte MOF-Datei
    ausgeführt und damit die Konfiguration angewendet. Dies
    erfolgt mit dem Commandlet Start-DscConfiguration
    erneut unter Angabe des Konfigurationsnamens.

```
Start-DscConfiguration DSCErstesBeispiel -wait -verbose.
```

```
Normalerweise wird die Konfiguration in einem
Hintergrundjob ausgeführt, sodass der Windows-Benutzer
nichts davon sieht; er müsste mit Get-Job den Job-Status
abfragen. Mit –wait wird bestimmt, dass die Konfiguration
interaktiv gestartet wird. - verbose sorgt wie immer für eine
detaillierte Ausgabe.
```
Die folgende Abbildung zeigt die Ausgabe des obigen Ablaufs. Die
Verbose-Ausgabe zeigt dem Nutzer hier an, dass der Schlüssel
noch nicht existierte.

Bild 30.3 Ablauf des ersten Beispiels

Um die gleiche Konfiguration noch einmal auszuführen, muss
man nur den dritten Schritt wiederholen. Wenn die Windows-
Registrierungsdatenbankeinträge schon vorhanden sind, lautet
die Meldung Found registry key value 'HKLM:\software\www.it-
visions.de\Produkte' with type 'String' and data
'Schulung,Beratung,Support'.


Dies ist aber keine Fehlermeldung. Aus der Sicht von DSC ist es
eben im Sinne einer idempotenten Ausführung kein Fehler, wenn
eine Konfiguration schon vorhanden ist.

Ob die Konfiguration erfolgreich angewendet ist, kann man mit
Test-DscConfiguration prüfen. Das Commandlet antwortet mit
true oder false.


TIPP: Man kann die Ausführungsschritte 2 und 3 natürlich
automatisieren, indem man sie mit in die DSC-
Konfigurationsdatei packt, da dort beliebige PowerShell-
Befehle vor und nach dem configuration {}-Block
möglich sind.


Listing 30.2 [/2_Aufbauwissen/DSC/DSCErstesBeispiel.ps 1 mit
automatischer Ausführung]

```
"Lade DSC..."
cd c:\temp
configuration DSCErstesBeispiel
{
node localhost
{
Registry RegEintrag 1 Erzeugen
{
Ensure ="Present"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\www.IT-Vision
s.de"
ValueName="Inhaber"
ValueData="Dr. Holger Schwichtenberg"
}
Registry RegEintrag 2 Erzeugen
{
Ensure ="Present"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\www.IT-Vision
s.de"
ValueName="Produkte"
ValueData="Schulung,Beratung,Support"
}
Registry RegEintrag 3 Erzeugen
```

```
{
Ensure ="Present"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\www.IT-Vision
s.de"
ValueName="Angelegt am"
ValueData=$(Get-date)
}
}
}
"DSC ist geladen und wird nun kompiliert"
DSCErstesBeispiel
"DSC ist kompiliert und wird nun gestartet"
Start-DscConfiguration DSCErstesBeispiel -wait -ver
bose
.
```
###### 30.10 Variablen in DSC-Dateien

In der nachstehenden Variante des ersten Beispiels werden drei
Variablen zu Beginn der Datei definiert, die dann in der DSC-
Konfiguration zum Einsatz kommen. Zudem erfolgt die
Ausführung nicht mehr auf "localhost", sondern auf einem
entfernten Rechner, der auch durch eine Variable festgelegt ist.


HINWEIS: Im nächsten Listing sieht man auch, dass
PowerShell-Syntax innerhalb des
Konfigurationsdokuments zum Einsatz kommen darf.
Neben einer Variablendeklaration ist auch ein Zugriff auf
PowerShell-Commandlets wie Get-Date (siehe
"RegEintrag 4 Erzeugen") möglich. Dies ist jedoch kein K.
o.-Kriterium für die Plattformunabhängigkeit, denn diese
Ausdrücke werden nicht auf dem Zielsystem, sondern
schon vorher beim Kompilieren des DSC-
Konfigurationsdokuments ausgewertet.


Listing 30.3 [2_Aufbauwissen\DSC\DSC_ErstesBeispiel_RemoteVariablen.ps1]

```
$computer = "D130"
$Firma = "www.IT-Visions.de"
$Aufrufer = [System.Environment]::machinename
"Lade DSC..."
configuration DSCErstesBeispiel
{
node $computer
{
Registry RegEintrag 1 Erzeugen
{
Ensure ="Present"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\$Firma"
ValueName="Inhaber"
ValueData="Dr. Holger Schwichtenberg"
}
Registry RegEintrag 2 Erzeugen
{
Ensure ="Present"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\$Firma"
ValueName="Produkte"
ValueData="Schulung,Beratung,Support"
}
Registry RegEintrag 3 Erzeugen
{
Ensure ="Present"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\$Firma"
ValueName="Computername"
ValueData="Erstellt von $Aufrufer"
}
Registry RegEintrag 4 Erzeugen
```

```
{
Ensure ="Present"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\$($ConfigurationData.
Firma)"
ValueName="Angelegt am"
ValueData=$(Get-date)
}
}
}
"DSC ist geladen!"
DSCErstesBeispiel
"DSC ist kompiliert"
Start-DscConfiguration DSCErstesBeispiel -verbose -wait
```
###### 30.11 Parameter für DSC-Dateien

DSC-Dateien können Parameter besitzen, die festgelegt werden
wie Parameter von Power-Shell-Funktionen in param()-Blöcken,
siehe nächstes Listing. Die Werte für die Parameter müssen beim
Kompilieren der MOF-Datei angegeben werden. Wenn
Pflichtparameter fehlen, wird die PowerShell den Benutzer um
interaktive Eingabe bitten.

Das folgende Listing zeigt eine Variante des ersten Beispiels nun
mit vier Parametern: einen für den Rechnernamen und drei für
die Windows-Registrierungsdatenbankeinträge.


Listing 30.4 [/2_Aufbauwissen/DSC/DSCZweitesBeispielMitParametern.ps1]

```
"Lade DSC..."
configuration DSCErstesBeispielMitParametern
{
param(
[Parameter(mandatory)][string]$Rechner,
[Parameter(mandatory)][string]$Firma,
[Parameter(mandatory)][string]$Inhaber,
[Parameter(mandatory)][string]$Produkte)
```
```
node $Rechner
{
Registry RegEintrag 1 Erzeugen
{
Ensure ="Present"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\$Firma"
ValueName="Inhaber"
ValueData=$Inhaber
}
Registry RegEintrag 2 Erzeugen
{
Ensure ="Present"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\$Firma"
ValueName="Produkte"
ValueData=$Produkte
}
}
}
"DSC ist geladen!"
DSCErstesBeispielMitParametern -Rechner D 140 - Firma "www.I
T-Visions.de" - Inhaber
```

```
"Dr. Holger Schwichtenberg" - Produkte "Schulung, Beratung,
Support"
"DSC ist kompiliert"
Start-DscConfiguration DSCErstesBeispielMitParametern -ver
bose -wait
```
###### 30.12 Konfigurationsdaten

Anstelle der Übergabe einzelner Parameter unterstützt DSC auch
die Konfigurationsdatenübergabe in einer dreifach
verschachtelten Hashtable.

```
ACHTUNG: Die Begrifflichkeiten, die Microso hier für
verschiedene Dinge verwendet, liegen leider eng
beieinander. Ein Konfigurationsdokument beschreibt eine
Konfiguration, die zusätzliche Konfigurationsdaten beim
Kompilieren erhalten kann.
```
Dabei ist "AllNodes" ein feststehender Ausdruck, mit dem man
eine Liste von Computern (wieder als Hashtable) festlegen kann,
auf die die Konfiguration anzuwenden ist. Die AllNodes-
Hashtable muss dann wieder eine Hashtable sein (das ist dann
die dritte Schachtelungsebene) mit einem Eintrag "NodeName"
(auch dieser Name ist festgesetzt von Microso). Der NodeName
enthält den Computernamen oder die IP-Adresse.

Darüber hinaus darf es aber auch noch weitere Einträge geben,
die dann spezifisch für den Computer sind. Die Rechnernamen in


"AllNodes" dürfen nicht doppelt vorkommen!

Darüber hinaus darf es auf der ersten Ebene der Konfigurations-
Hashtable auch beliebige eigene Einträge geben, die dann für alle
Rechner gelten.

Der folgende Listingausschnitt zeigt eine Konfigurations-
Hashtable mit vier Rechnernamen bei "AllNodes" und drei
benutzerdefinierten Einträgen für die Eingabedaten.


```
$Konfiguration = @{
# Eingabedaten
Firma = "www.IT-Visions.de";
Inhaber = "Dr. Holger Schwichtenberg";
Produkte = "Schulung, Beratung, Support";
```
```
# Rechnerliste
AllNodes = @(
@{
NodeName="D130";
Aufgabe ="Arbeitsplatz 1. Etage"
}
@{
NodeName="D140"
Aufgabe ="Arbeitsplatz 2. Etage"
}
@{
NodeName="Server103"
Aufgabe ="Fileserver"
}
@{
NodeName="Server108"
Aufgabe ="DC"
}
)
}
```
Diese Variable mit der Hashtable ist mit dem Parameter -
ConfigurationData beim Kompilieren der MOF-Datei anzugeben:


```
DSCErstesBeispielMitParametern -ConfigurationData $Konfigu
ration
```
Innerhalb der Ressourcenkonfiguration gibt es drei feststehende
Variablen, um die Konfigurationsdaten zu nutzen:

```
$AllNodes ist die Liste aller Knoten. Hier ist Filtern mit
.Where{Bedingung} möglich.
$Node ist der jeweils aktuelle Knoten.
$ConfigurationData: Zugriff auf die selbst definierten
Einträge
```
Das nachstehende vollständige Listing zeigt dann auch, wie die
Einträge über $AllNodes. NodeName und $ConfigurationData.Name
innerhalb der Ressourcenkonfiguration genutzt werden können.
Die Konfiguration filtert dabei auf solche Rechner, deren Name
mit einem "D" beginnt.


Listing 30.5 [2_Aufbauwissen\DSC\DSC_ErstesBeispiel_Konfigdaten.ps1]

```
"Lade DSC..."
configuration DSCErstesBeispiel_Konfigdaten
{
node $AllNodes.NodeName.Where{$_.StartsWith('D')}
{
Registry RegEintrag 1 Erzeugen
{
Ensure ="Present"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\$($ConfigurationDat
a.Firma)"
ValueName="Inhaber"
ValueData=$($ConfigurationData.Inhaber)
}
Registry RegEintrag 2 Erzeugen
{
Ensure ="Present"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\$($ConfigurationDat
a.Firma)"
ValueName="Produkte"
ValueData=$($ConfigurationData.Produkte)
}
Registry RegEintrag 3 Erzeugen
{
Ensure ="Present"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\$($ConfigurationDat
a.Firma)"
ValueName="Angelegt am"
ValueData=$(Get-date)
}
Registry RegEintrag 4 Erzeugen
```

{
Ensure ="Present"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\$($ConfigurationDat
a.Firma)"
ValueName="Rechneraufgabe"
ValueData=$($Node.Aufgabe)
}
}
}
$Konfiguration = @{
# Eingabedaten
Firma = "www.IT-Visions.de";
Inhaber = "Dr. Holger Schwichtenberg";
Produkte = "Schulung, Beratung, Support";

# Rechnerliste
AllNodes = @(
@{
NodeName="D130";
Aufgabe ="Arbeitsplatz 1. Etage"
}
@{
NodeName="D140"
Aufgabe ="Arbeitsplatz 2. Etage"
}
@{
NodeName="Server103"
Aufgabe ="Fileserver"
}
@{
NodeName="Server108"
Aufgabe ="DC"


```
}
)
}
"DSC ist geladen!"
DSCErstesBeispiel_Konfigdaten -ConfigurationData $Konfigur
ation
"DSC ist kompiliert"
Start-DscConfiguration DSCErstesBeispiel_Konfigdaten -wait
```
- force

###### 30.13 Entfernen einer DSC-

###### Konfiguration

Das Entfernen einer DSC-Konfiguration ist leider noch nicht so
einfach, wie man es sich vorstellen würde. Ein "Undo-
DscConfiguration"-Commandlet gibt es leider nicht. Das
Commandlet Restore-DscConfiguration stellt zwar laut seiner
Beschreibung die vorherige Konfiguration wieder her; das geht
aber nur, wenn es vorher schon eine explizite DSC-Konfiguration
gab. Wenn es auf dem Rechner noch gar keine DSC-Konfiguration
gab, kann man nicht den vorherigen "nackten" Zustand
wiederherstellen.

DSC speichert das jeweils aktuelle Konfigurationsdokument in
der Datei c:\Windows\ Sys tem 32 \Configuration\current.mof. Das
Konfigurationsdokument der vorherigen Konfiguration liegt
unter c:\Windows\System 32 \Configuration\previous.mof. Auch ein
Administrator hat im Standard keinen Zugriff auf das Verzeichnis


c:\Windows\System 32 \Configuration. Er kann die jeweils zuletzt
angewendeten Konfigurationseinstellungen abrufen mit

```
Get-DscConfiguration | Format-Table
```
Zudem kann er die gespeicherten Konfigurationsdokumente
löschen:

```
Remove-DscConfigurationDocument -Stage Current
Remove-DscConfigurationDocument -Stage Previous
```
Wenn es vorher schon eine Konfiguration gab, sorgt Restore-
DscConfiguration dafür, dass diese erneut ausgeführt wird. Das
bedeutet aber nicht, dass die aktuelle Konfiguration rückgängig
gemacht wird. Es kann aber natürlich sein, dass das vorherige
Konfigurationsdokument die aktuellen Einstellungen
überschreibt. Jedes Mal beim Aufruf von Restore-
DscConfiguration tauscht DSC die Dokumente current.mof und
previous.mof, sodass man zwischen den beiden letzten
Konfigurationen beliebig hin- und herwechseln kann. Warum
Microso hier nicht direkt eine beliebige Historie speichert, ist
nicht nachvollziehbar.

Ein echtes Rückgängigmachen gibt es in DSC also bisher nicht.
Der Administrator muss immer explizit Einstellungen wieder
zurücksetzen. Das kann er in einem Konfigurationsdokument
machen, indem er bei einer Ressource die Eigenscha
Ensure="Absent" festlegt.

Allerdings ist die Arbeit mit DSC nicht immer so einfach, wie sie
es sein könnte. Wenn man zum Beispiel einen
Registrierungsdatenbankschlüssel mit allen seinen Einträgen
entfernen will, geht das so nicht:


```
Registry RegEintrag 1 Erzeugen
{
Ensure ="Absent"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\$Firma"
}
```
Die PowerShell beschwert sich: "Die Registry-Klasse erfordert,
dass ein Wert vom Typ ‚String' für die ValueName-Eigenscha
angegeben wird." Das heißt: Man muss jeden Eintrag zu einem
Schlüssel einzeln entfernen, wie das nächste Listing zeigt.


Listing 30.6
[2_Aufbauwissen\DSC\DSC_ErstesBeispiel_Absent_RegistryRessouce.ps1]

```
"Lade DSC..."
configuration DSCErstesBeispielMitParametern
{
node $AllNodes.NodeName
{
Registry RegEintrag 1 Loeschen
{
Ensure ="Absent"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\$Firma"
ValueName="Inhaber"
}
Registry RegEintrag 2 Loeschen
{
Ensure ="Absent"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\$Firma"
ValueName="Produkte"
}
Registry RegEintrag 3 Loeschen
{
Ensure ="Absent"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\www.IT-Visions.de"
ValueName="Angelegt am"
}
}
}
$ConfigurationData = @{
AllNodes = @(
@{
NodeName="D130"
```

```
}
@{
NodeName="D140"
}
)
}
"DSC ist geladen!"
DSCErstesBeispielMitParametern -ConfigurationData $configu
rationData
"DSC ist kompiliert"
Start-DscConfiguration DSCErstesBeispielMitParametern -ver
bose -wait -force
```
Eine etwas prägnantere Alternative ist der Einsatz der Script-
Ressource. Diese besteht aus drei Codeblöcken:

```
Bei der Anwendung der Konfiguration wird erst der
TestScript-Codeblock aufgerufen. Nur wenn dieser $false
liefert, wird die Aktion ausgeführt.
Die Aktion, die dann ausgeführt werden soll, ist bei SetScript
abzulegen.
Der GetScript-Codeblock wird nur genutzt, wenn der
PowerShell-Anwender mit Get-DSC-Configuration den
Zustand der Konfiguration abfragt.
```
In der vorliegenden Aufgabe, der Entfernung eines
Registrierungsdatenbankschlüssels mit Untereinträgen, ist die
Aktion bei SetScript in einer Zeile realisiert:

```
Remove- Item "hklm:SOFTWARE\www.IT-Visions.de"
```
Das folgende Listing zeigt die ganze Lösung mit Script-
Ressource.


Listing 30.7
[2_Aufbauwissen\DSC\DSC_ErstesBeispiel_Absent_ScriptRessource.ps1]

```
"Lade DSC..."
configuration DSCErstesBeispielMitParametern
{
node $AllNodes.NodeName
{
Script SchluesselLoeschen
{
TestScript = { - not (Test-Path "hklm:SOFTWARE\www.IT-V
isions.de") }
SetScript = {
Remove-Item "hklm:SOFTWARE\www.IT-Visions.de"
}
GetScript = { @{result = "Schlüssel vorhanden: " + (Te
st-Path
"hklm:SOFTWARE\www.IT-Visions.de")} }
}
```
```
}
}
$ConfigurationData = @{
AllNodes = @(
@{
NodeName="D130"
}
@{
NodeName="D140"
}
)
}
```

```
"DSC ist geladen!"
DSCErstesBeispielMitParametern -ConfigurationData $configu
rationData
"DSC ist kompiliert"
Start-DscConfiguration DSCErstesBeispielMitParametern -ver
bose -wait -force
```
```
HINWEIS: An dieser Stelle ist es angebracht, einmal
deutlich Kritik an DSC zu üben. DSC ist manchmal zu
umständlich, wenn man sich ansieht, dass man die
Aufgabe des Löschens eines
Registrierungsdatenbankschlüssels auf mehreren
Rechnern ohne DSC mit nur einem PowerShell-
Commandlet in einer Zeile lösen kann:
```
```
invoke-command -ComputerName d140,d 130 - scriptblock
{ rd "hklm:SOFTWARE\
http://www.IT-Visions.de"}
```
###### 30.14 DSC Pull Server

Bisher erfolgte in diesem Kapitel die Verbreitung der
Konfigurationen im "Push-Modus", d. h., ein Rechner hat die
Konfiguration an einen anderen gesendet, der zu diesem
Zeitpunkt erreichbar sein musste.

Ein "DSC Pull Server" ist im Gegensatz dazu ein Webdienst, bei
dem sich die Computer in regelmäßigen Abständen ihre


Konfiguration durch eine HTTP-Anfrage abholen können.

Ein "Pull Server" spricht das Open Data Protocol (OData) und
wird in den Internet Information Services (IIS) von Windows
gehostet. Eine Implementierung für Linux ist noch nicht
verfügbar, aber mit absehbarem Aufwand möglich.

Die für den Pull-Modus konfigurierten Clients rufen dann
periodisch die aktuellen Konfigurationsdokumente bei dem Pull
Server ab. Das Abrufintervall darf in der aktuellen
Implementierung aber nicht kleiner als 30 Minuten sein.

30.14.1 Einrichten des DSC Pull Servers

Ein DSC Pull Server kann auf einem Windows Server eingerichtet
werden. Folgende Windows-Komponenten müssen dort
installiert sein:

```
Internet Information Services (IIS) (Rolle "Web Server")
DSC Service
```

Bild 30.4 Installieren des IIS-Web Servers

Bild 30.5 Installieren des DSC Service


Beide Installationen können auch per PowerShell-Commandlets
erfolgen:

```
Install-WindowsFeature Web-Server
Install-WindowsFeature DSC-Service
```
Auch per DSC könnte man dies konfigurieren, siehe Abschnitt
30.15 "Praxislösung 1: IIS installieren" in diesem Kapitel.

Danach ist der Pull Server zu konfiguieren. Dafür stellt Microso
ein PowerShell-Modul "xPSDesiredStateConfiguration" bereit,
das eine DSC-Ressource xDscWebService anbietet. Das
nachstehende PowerShell-Skript mit eingebetteter DSC-
Konfiguration ist eine modifizierte Variante eines Beispiels, das
Microso beim PowerShell-Modul
"xPSDesiredStateConfiguration" mitliefert.

```
HINWEIS: Das folgende Listing erstellt ein selbst
signiertes SSL-Zertifikat für die Website des DSC Pull
Servers. In der Praxis sollten Sie ein SSL-Zertifikat bei
einer Zertifizierungsstelle käuflich erwerben oder selbst
eine unternehmenseigene Zertifizierungsstelle gründen.
Ein solches Zertifikat kann der Verlag Ihnen natürlich
nicht im Rahmen des Buchs mitliefern.
```

Listing 30.8 [2_Aufbauwissen\DSC\DSC_PullServer_Konfigurieren.ps1]

```
# DSC configuration for Pull Server and Compliance Server
# Autor: Microsoft
# Enthalten in: Modul xPSDesiredStateConfiguration im Ordn
er "Samples"
```
```
Install-Module xPSDesiredStateConfiguration
$ServerName = "D142"
```
```
configuration Sample_xDscWebService
{
param
(
[string[]]$NodeName = $ServerName,
```
```
[ValidateNotNullOrEmpty()]
[string] $certificateThumbPrint
)
```
```
Import-DSCResource -ModuleName xPSDesiredStateConfigur
ation
```
```
Node $NodeName
{
WindowsFeature DSCServiceFeature
{
Ensure = "Present"
Name = "DSC-Service"
}
```
```
xDscWebService PSDSCPullServer
```

{
Ensure = "Present"
EndpointName = "PSDSCPullServer"
Port = 8080
PhysicalPath = "$env:SystemDrive
\inetpub\PSDSCPullServer"
CertificateThumbPrint = $certificateThumbP
rint
ModulePath = "$env:PROGRAMFILES
\WindowsPowerShell\
DscService\Modules"
ConfigurationPath = "$env:PROGRAMFILES
\WindowsPowerShell\
DscService\Configuration"
State = "Started"
DependsOn = "[WindowsFeature]D
SCServiceFeature"
}
xDscWebService PSDSCComplianceServer
{
Ensure = "Present"
EndpointName = "PSDSCComplianceSe
rver"
Port = 9080
PhysicalPath = "$env:SystemDrive
\inetpub\
PSDSCComplianceServer"
CertificateThumbPrint = "AllowUnencryptedT
raffic"
State = "Started"
IsComplianceServer = $true
DependsOn = @("[WindowsFeatur


```
e]DSCServiceFeature",
"[xDSCWebService]PSDSCPullServer")
}
}
}
```
```
# Zertifikat anlegen
$cert =New-SelfSignedCertificate -DnsName $ServerName -Cer
tStoreLocation
"cert:\LocalMachine\My"
#oder laden: $cert = Get-ChildItem CERT:\LocalMachine\MY |
Where-Object {$_.Subject
```
- eq 'CN=PSDSCPullServerCert'}
# MOF-Datei erstellen
Sample_xDscWebService -certificateThumbprint $cert.Thumbpr
int -verbose
# MOF-Datei ausführen
Start-DscConfiguration Sample_xDscWebService -wait -force
- verbose
# Zertifikat für Clients exportieren
Get-ChildItem CERT:\LocalMachine\MY | Where-Object {$_.Sub
ject -eq 'CN=$ServerName'}
| Export-Certificate -FilePath "w:\temp\$ServerName`_SSL.c
er"

Dass die Konfiguration erfolgreich war, kann man wie folgt
überprüfen:

```
Es gibt ein Verzeichnis c:\Program Files
(x 86 )\WindowsPowerShell\DscService mit zwei
Unterverzeichnisen Configuration und Modules.
Es gibt im IIS zwei Websites (siehe folgende Abbildung).
```

```
Aufruf der URL des DSC Pull Servers
[https://SERVERNAME:8080/PSDSCPullServer.svc/] in einem
Browser auf einem Client. Dies zeigt XML-Daten des OData-
Dienstes des DSC Pull Servers.
```
Bild 30.6 Verzeichnisse des Pull Servers

Bild 30.7 IIS-Websites des Pull Servers


Bild 30.8 OData-Dienst des DSC Pull Servers

Alternativ kann man auch den Datenabruf auf dem Client per
PowerShell-Skript prüfen:

```
Listing 30.9
[2_Aufbauwissen\DSC\DSC_PullServer_Client_CertImport+Check.ps1]
function Check-DSCPullServer ($fqdn) {
([xml](invoke-webrequest "https://$($fqdn):8080/psdsc
pullserver.svc" | %
Content)).service.workspace.collection.href
}
Check-DSCPullServer ' D142'
```

```
HINWEIS: Wenn Sie ein selbst signiertes Zertifikat
verwenden, müssen Sie dieses Zertifikat erst auf dem
Client importieren, damit der Datenabruf ohne Warnung
gelingen kann. Dies können Sie über die MMC machen
(Import nach Computer/Trusted Root Certification
Authorities) oder per PowerShell:
Import-Certificate -FilePath "w:\temp\D142_ssl.Cer" -
CertStoreLocation 'Cert:\ LocalMachine\root' - verbose
```
30.14.2 Einrichten der Clients

Damit der Client den DSC Pull Server tatsächlich abfragt, braucht
auch er eine Konfiguration. Wichtig dabei ist, dass Sie die
korrekte URL des DSC-Pull-Server-Datendienstes bei ServerURL
eintragen. Die GUID bei ConfigurationID ist wichtig: Unter genau
dieser GUID müssen Sie auf dem DSC Pull Server die gewünschte
Konfiguration bereitstellen.

Die 30 bei RefreshFrequencyMins steht für das Abrufintervall.
Leider kann man hier keine kleineren Werte eintragen. Der
Versuch, dies zum Test auf eine Minute zu reduzieren, führt zum
Fehler: "Property ‚RefreshFrequencyMins' of Resource ‚Settings'
has value ‚1' which is not between valid range ‚30' and ‚44640'."


Listing 30.10 [2_Aufbauwissen\DSC\DSC_PullServer_Client_konfig.ps1]

```
# Konfigurieren eines Computers zur Nutzung eines DSC Pull
Servers
```
```
[DSCLocalConfigurationManager()]
configuration PullClientConfigID
{
Node localhost
{
Settings
{
RefreshMode = 'Pull'
ConfigurationID = '1d 545 e 3 b-60c3-47a0-bf65-5af
c 05182 fd0'
RefreshFrequencyMins = 30
RebootNodeIfNeeded = $true
}
ConfigurationRepositoryWeb PullServer
{
ServerURL = 'https://D142:8080/PSDSCPullServe
r.svc'
}
}
}
```
```
# MOF erstellen
PullClientConfigID
# MOF einlesen
Set-DSCLocalConfigurationManager localhost -Path .\PullCli
entConfigID -verbose
```

30.14.3 Bereitstellen von DSC-

Konfigurationen für Clients

Das folgende Listing zeigt nun ein DSC-Konfigurationsbeispiel für
die Konfiguration mit der oben verwendeten GUID. Diese DSC-
Konfiguration ist als MOF zu kompilieren und in das Verzeichnis
c:\Program Files\WindowsPowerShell\dscservice\configuration zu
legen. Zudem ist mit New- DSCChecksum eine Prüfsumme zu
erstellen. Diese erscheint dann als eigenständige Datei in dem
Verzeichnis (1d 545 e 3 b-60c3-47a0-bf65-
5 afc 05182 fd0.mof.checksum).


Listing 30.11
[2_Aufbauwissen\DSC\DSC_PullServer_BeispielKonfigurationFuerClient.ps1]

```
$ConfigurationIDdesClients = "1d 545 e 3 b-60c3-47a0-bf65-5afc
05182 fd0"
"Lade DSC..."
configuration DSCErstesBeispiel
{
node D 130
{
Registry RegEintrag 1 Erzeugen
{
Ensure ="Present"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\www.IT-Visions.de"
ValueName="Inhaber"
ValueData="Dr. Holger Schwichtenberg"
}
Registry RegEintrag 2 Erzeugen
{
Ensure ="Present"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\www.IT-Visions.de"
ValueName="Produkte"
ValueData="Schulung,Beratung,Support"
}
Registry RegEintrag 3 Erzeugen
{
Ensure ="Present"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\www.IT-Visions.de"
ValueName="Angelegt"
ValueData="vom Pull Server D142: $(get-date)"
}
}
```

```
}
"DSC ist geladen und wird nun kompiliert"
DSCErstesBeispiel -OutputPath w:\temp
"Kopieren der MOF-Datei in das Configuration-Verzeichnis d
es Pull Servers"
$ziel = "c:\Program Files (x 86 )\WindowsPowerShell\dscservi
ce\configuration\
$ConfigurationIDdesClients.mof"
copy w:\temp\D130.mof $ziel
"Erstellen der Checksumme"
New-DSCChecksum $ziel
```
30.14.4 Diagnose

Zur Diagnose von Problemen kann man das PowerShell-Modul
xDscDiagnostics einsetzen, das aber, wie "x" andeutet, auch
nicht Bestandteil von Windows oder der PowerShell ist, sondern
zu den "experimentellen", nicht offiziell unterstützten Modulen
zählt.

Modulinstallation:

```
Install-Module -Name xDscDiagnostics
```
Abruf der Liste von Ereignisprotokolleinträgen zu DSC:

```
Get-xDscOperation -Newest 20 | FT SequenceID,Timecreated,R
esult,AllEvents
```
Ausgabe von Detailinformationen zu einem Eintrag:


```
Get-xDscOperation | where sequenceid -eq 8 | fl *
```
Bild 30.9 Diagnoseliste

###### 30.15 DSC-Praxislösung 1: IIS

###### installieren

In dem folgenden Beispiel wird auf dem Rechner "Server123" per
DSC Folgendes erledigt:

```
Installation der Internet Information Services (Windows
Features "Web-Server")
Installation des Webserver-Frameworks ASP.NET 4.5
(Windows Features "Web-Asp-Net45")
Die Dienste WAS (Windows Activation Service) und Windows
Update werden gestartet.
```

Listing 30.12 [/2_Aufbauwissen/DSC/DSCIIS.ps1]

```
"Lade DSC..."
configuration Website_wwwITVisionsde
{
WindowsFeature IISVorhanden
{
Ensure ="Present"
Name="Web-Server"
}
WindowsFeature IISASPNETVorhanden
{
Ensure ="Present"
Name="Web-Asp-Net45"
DependsOn="[WindowsFeature]IISVorhanden"
}
Service DienstWAS
{
Name ="WAS"
State="Running"
StartupType="Automatic"
DependsOn="[WindowsFeature]IISVorhanden"
}
Service DienstWindowsUpdate
{
Name ="wuauserv"
State="Running"
StartupType="Automatic"
}
}
"DSC ist geladen!"
Website_wwwITVisionsde
```

```
"DSC ist kompiliert"
Start-DscConfiguration Website_wwwITVisionsde -verbose -wa
it
```
Bild 30.10 Ablauf der Installation von Windows-Features per DSC in der ISE

###### 30.16 DSC-Praxislösung 2: Soware

###### installieren

In dem folgenden Beispiel wird per DSC Folgendes erledigt:

```
Kopieren der Setup-Datei von einem Netzlaufwerk ins
w:\Temp-Verzeichnis
```

Installieren einer Anwendung per MSI-Paket

Löschen der Setup-Dateien im w:\Temp-Verzeichnis

Erstellen eines Ereignisprotokolleintrags

Erstellen von zwei Registrierungsdatenbankeinträgen

```
ACHTUNG: Mit dem doppelten Zugriff auf den Ordner im
w:\temp-Verzeichnis hat DSC ein Problem. DSC geht
davon aus, dass man im Rahmen einer Konfiguration
immer nur genau eine Aktion auf einer bestimmten
Ressourceninstanz ausführen kann. In folgendem Listing
musste man daher tricksen. Der Pfad ist bei
DestinationPath beim Ressourcenblock "File
SetupKopieren" mit umgekehrtem Schrägstrich am Ende
(w:\temp\helloworld\) und bei "File SetupLoeschen" ohne
diesen angegeben. Ohne dies würde sich DSC
beschweren: "The key properties combination
‚w:\temp\HelloWorld' is duplicated for keys
‚DestinationPath' of resource ‚File' in node ‚localhost'.
Please make sure key properties are unique for each
resource in a node." Durch die kleine Nuance der
Schreibweise lässt sich DSC aber in diesem Fall
austricksen.
```

Listing 30.13 [/2_Aufbauwissen/DSC/DSCSowareInstallieren.ps1]

```
$Quellpfad = "\\Server 123 \software\Setup_for_HelloWorld_VB
NET.msi"
clear
"Lade DSC..."
configuration HelloWorldInstallieren
{
Import-DscResource -ModuleName 'PSDesiredStateConfigur
ation'
```
```
node $AllNodes.NodeName.Where{$_.StartsWith('D')}
{
Log Protokolleintrag 1
{
Message = "Hello World wird installiert: $(Get
```
- Date)"
}

```
File SetupKopieren
{
```
```
Ensure = "Present"
SourcePath = $Quellpfad
DestinationPath = "w:\temp\helloworld\"
Recurse = $true
Type = "File"
DependsOn="[Log]Protokolleintrag1"
}
```
```
Package HelloWorldInstallieren
{
```

Ensure = "Present"
Path = "w:\temp\helloworld\Setup_for_HelloWorl
d_VBNET.msi"
Name = "Hello World VB.NET"
ProductId = "29E 4 EB91-7F 2 C-4B27-9FF5-DBE 35 A 0 F 6
9 AF"
DependsOn="[File]SetupKopieren"
}

File SetupDirLoeschen
{
Ensure = "Absent"
DestinationPath = "w:\temp\helloworld"
Recurse = $true
Force=$true
Type = "Directory"
DependsOn="[Package]HelloWorldInstallieren"
}

Log Protokolleintrag 2
{
Message = "Hello World installiert!"
DependsOn="[File]SetupDirLoeschen"
}

Registry RegEintrag 1 Erzeugen
{
Ensure ="Present"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\$($Configura
tionData.Firma)"
ValueName="Angelegt am"
ValueData=$(Get-date)


}

Registry RegEintrag 2 Erzeugen
{
Ensure ="Present"
Key ="HKEY_LOCAL_MACHINE\SOFTWARE\$($Configurat
ionData.Firma)"
ValueName="Rechneraufgabe"
ValueData=$($Node.Aufgabe)
}
}
}
$Konfiguration = @{
# Eingabedaten
Firma = "www.IT-Visions.de";

# Rechnerliste
AllNodes = @(
@{
NodeName="D130";
Aufgabe ="Arbeitsplatz 1. Etage"
}
@{
NodeName="D140"
Aufgabe ="Arbeitsplatz 2. Etage"
}
@{
NodeName="Server103"
Aufgabe ="Fileserver"
}
@{
NodeName="Server108"


```
Aufgabe ="DC"
}
)
}
"DSC ist geladen!"
HelloWorldInstallieren -ConfigurationData $Konfiguration
"DSC ist kompiliert"
Start-DscConfiguration HelloWorldInstallieren -verbose -wa
it -force
```
###### 30.17 D SC-Praxislösung 3: Soware

###### deinstallieren

Im folgenden Beispiel wird per DSC Folgendes erledigt:

```
Deinstallieren eines MSI-Pakets
Löschen der Setup-Dateien im c:\Temp-Verzeichnis
Erstellen eines Ereignisprotokolleintrags
```

Listing 30.14 [\2_Aufbauwissen\DSC\DSCSowareDeinstallieren.ps1]

```
"Lade DSC..."
configuration HelloWorldDeinstallieren
{
```
```
Package SoftwareDeinstallieren
{
Ensure = "Absent"
Path = "w:\temp\Setup_for_HelloWorld_VBNET.msi"
Name = "HelloWorld"
ProductId = "29E 4 EB91-7F 2 C-4B27-9FF5-DBE 35 A 0 F 69 AF"
}
File SetupLoeschen
{
Ensure = "Absent"
DestinationPath = "w:\temp\Setup_for_HelloWorld_VBNET.ms
i"
Recurse = $true
Force=$true
Type = "File"
DependsOn="[Package]SoftwareDeinstallieren"
}
```
```
Log Protokolleintrag
{
Message = "Hello World deinstalliert!"
DependsOn="[File]SetupLoeschen"
}
}
```

###### 30.18 Realisierung einer DSC-

###### Ressource

Eine DSC-Ressource ist in Form eines PowerShell-Moduls
implementiert. Diese Module liegen im Dateisystem unter:

c:\Windows\System 32 \WindowsPowerShell\v1.0\Modules\PSDesire
dStateConfiguration\ DSCResources

In jedem Modul müssen drei Commandlets realisiert sein:

```
Test-TargetResource: Prü, ob die Ressource den
gewünschten Zustand hat, und liefert dafür $true oder
$false zurück. Das Commandlet muss sowohl die
Einstellung des Zustands (Ensure="Present") als auch die
Rückgängigmachung des Zustands (Ensure="Absent")
abdecken.
Set-TargetResource: Bringt die Ressource in den
gewünschten Zustand, falls Test-–TargetResource den Wert
$false geliefert hat. Das Commandlet muss sowohl die
Einstellung des Zustands (Ensure="Present") als auch die
Rückgängigmachung des Zustands (Ensure="Absent")
abdecken. Die Zustandsänderung darf auch einen Neustart
des Computers erfordern. Dies ist durch
$DSCMachineStatus.IsRestartRequired = $true anzuzeigen.
Das Commandlet muss aber selbst dafür sorgen, nach
einem Reboot an der richtigen Stelle weiterzumachen.
Get-TargetResource: Liefert den aktuellen Zustand der
Ressource in Form einer Hashtable.
```

###### 30.19 Weitere Möglichkeiten

Möglich ist es, eine Konfiguration aus mehreren
Konfigurationsdokumenten aus verschiedenen Quellen
zusammenzusetzen. Solche "partiellen Konfigurationen" dürfen
auch das Pull- und das Push-Verfahren mischen.

Mit den Ressourcen WaitForAll, WaitForAny bzw. WaitForSome
kann seit PowerShell 5.0 der PowerShell-Nutzer in einem
Konfigurationsdokument deklarieren, dass eine Konfiguration
auf die Fertigstellung einer Ressourcenkonfiguration auf einem
oder mehreren entfernten Systemen warten soll.

```
.admanagement" }
```

# 31 PowerShell-Snap-Ins

Die PowerShell besitzt keinen festen Satz von Commandlets.
Zusätzliche Commandlets können beim Start der PowerShell
oder jederzeit beim Betrieb hinzugefügt werden. Zusätzliche
Commandlets sind entweder als Skriptdateien implementiert,
die über das "Dot Sourcing" hinzugefügt werden (vgl. Abschnitt
6.2 "Start eines Skripts") oder durch die Installation eines Snap-
In (im Folgenden beschrieben) oder PowerShell-Moduls (siehe
nächstes Kapitel).

```
HINWEIS: Heutzutage verwendet Microso selbst fast nur
noch PowerShell-Module, die in PowerShell 2.0 neu
eingeführt wurden. Dieses Kapitel verbleibt aber im Buch,
da es noch einzelne PowerShell-Snap-Ins von Microso
und anderen Anbietern gibt.
In PowerShell ab Version 6.0 gibt es keine Snap-Ins mehr!
Hier kann man nur noch Module verwenden!
```
## 31.1 Einbinden von Snap-Ins


Commandlet-Erweiterungen, die in Form einer Snap-In-DLL
vorliegen, müssen in zwei Schritten in die PowerShell
eingebunden werden:

```
Registrieren der DLL (alias Assembly), welche die
Commandlets enthält
Hinzufügen des Snap-In zur PowerShell-Konsole
```
Registrieren der DLL

Das Registrieren der DLL erfolgt mit dem
Kommandozeilenwerkzeug installutil.exe, das mit dem .NET
Framework mitgeliefert wird. Das Werkzeug finden Sie im
Installationsordner des .NET Frameworks (in der Regel
c:\Windows\Microso .NET\Framework\v x.y\). Die Windows
PowerShell hat diesen Pfad automatisch als Suchpfad
eingebunden.

Bei installutil.exe ist der Dateiname zu der Erweiterungs-DLL
anzugeben, inklusive Pfad (sofern die PowerShell-Konsole genau
diesen Pfad nicht schon als aktuellen Pfad hat).

```
installutil.exe G:\PowerShell_Commandlet_Library\bin\Debug
\PowerShell_Command.dll
```
Die folgende Abbildung zeigt, wie das Werkzeug die erfolgreiche
Installation quittiert.


Bild 31.1 Ausgabe von InstallUtil.exe

Das Registrieren führt dazu, dass die DLL in der
Registrierungsdatenbank unter HKEY_
LOCAL_MACHINE\SOFTWARE\Microso\PowerShell\ 1 \PowerShellS
napIns eingetragen wird.

Hinzufügen des Snap-In zur PowerShell-

Konsole


Zum Aktivieren des Snap-In muss man in der PowerShell-Konsole
das Commandlet Add-PSSnapin verwenden. Dieses Commandlet
lädt die Erweiterung:

```
Add-PSSnapin PowerShell_Commandlet_Library
```
Laden des Snap-In

Während das Registrieren der DLL nur einmal notwendig ist,
verwir die PowerShell-Konsole bei jedem Beenden alle
geladenen Snap-Ins. Wenn man möchte, dass die PowerShell
immer mit bestimmten Erweiterungen geladen wird, gibt es zwei
Möglichkeiten:

```
Aufnehmen der entsprechenden Add-PSSnapIn-Anweisungen
in Ihre systemweite oder benutzerspezifische Profildatei.
```

Bild 31.2 Laden eines Snap-Ins in der Profildatei. Danach steht Get-Computername
im danach geöffneten Konsolenfenstern zur Verfügung.

```
Exportieren einer Konsolenkonfigurationsdatei mit Export-
Console. Sie müssen allerdings vorher erst das Snap-In in der
aktuellen Konsole hinzufügen und dann diese aktuelle
Konsole exportieren. Dabei entsteht eine XML-Datei mit der
Dateinamenserweiterung .psc 1. Diese .psc 1 - Datei muss
dann beim Starten der PowerShell mit dem
Kommandozeilenparameter –PSConsoleFile übergeben
werden.
```

Bild 31.3 Exportieren einer Konsolenkonfigurationsdatei

Am besten legt man sich eine Verknüpfung im Dateisystem mit
folgendem Ziel an:

```
%SystemRoot%\system 32 \WindowsPowerShell\v1.0\powershell.ex
e -PSConsoleFile
"G:\Consoles\HolgersConsole.psc1"
```

Bild 31.4 Anlegen einer Verknüpfung zur PowerShell-Konsole, die automatisch eine
bestimmte Konsolenkonfigurationsdatei mitlädt

Liste der Snap-Ins

```
HINWEIS: Das Commandlet Get-PSSnapIn listet im
Normalfall nur die Snap-Ins auf, die bereits der
PowerShell mit Add-PSSnapIn hinzugefügt wurden.
Darunter findet man auch die Standard-Commandlet-
Pakete, die mit Microsoft. PowerShell.* beginnen (siehe
folgende Abbildung).
```

Mit Get-PSSnapin -registered listet man hingegen alle
registrierten Snap-Ins auf, unabhängig davon, ob diese in der
aktuellen Konsole aktiv sind. In der folgenden Abbildung sieht
man die WorldWideWings_PowerShell_Extensions, die nicht in
der Konsole aktiv sind (siehe folgende Abbildung).

Bild 31.5 Aktive PowerShell-Snap-Ins


Bild 31.6 Alle auf dem System registrierten Commandlets

###### 31.2 Liste der Commandlets

Um sich alle Commandlets einer bestimmten Erweiterung
auflisten zu lassen, können Sie nach dem Attribut PSSnapIn in der
Klasse CmdletInfo filtern, z. B.:

```
Get-Command | where { $_.pssnapin -like "Pscx" }
```
oder

```
Get-Command | where { $_.pssnapin -like "ITVisions_PowerSh
ell_Extensions" }
```
oder

```
Get-Command | where { $_.pssnapin -like "quest.activeroles
```

# 32 PowerShell-Module

PowerShell-Module sind Sowarepakete, die die PowerShell und
PowerShell Core durch Funktionalität erweitern. Module können
aus Navigationsprovidern, Commandlets, Funktionen,
Workflows, vordefinierten Variablen und Aliasen bestehen. Auch
Typformatierungsdateien (.ps 1 xml) und Dateidateien (z. B.
Textdateien, XML-Datei, Datenbankdateien) können enthalten
sein.

Durch Module können Entwickler bzw. Administratoren
Funktionalität zur Wiederverwendung an andere Personen
weitergeben. Der Empfänger muss das Modul importieren und
kann die darin enthaltene Funktionalität dann nutzen wie die
Kernfunktionalität der Power-Shell.


```
HINWEIS: Seit Version 3.0 importiert die PowerShell lokal
vorhandene Module automatisch bei Bedarf.
Seit PowerShell 5.0 kann die PowerShell auch Module
automatisiert aus Internetportalen herunterladen und
installieren.
Einige Module für Windows PowerShell laufen nicht auf
der modernen PowerShell ab Version 6. Die moderne
PowerShell erfordert spezielle Module, die sich an die
Restriktionen von .NET Core/.NET halten!
```
Die bereits in PowerShell 1.0 eingeführten Snap-Ins sind .NET-
Komponenten (Assemblies), die nur Navigationsprovider und
Commandlets enthalten können. Module sind ein
übergeordnetes Konzept, in dem neben kompilierten Assemblies
auch PowerShell-Skripte liegen können.

###### 32.1 Überblick über die

###### Commandlets

Folgende Commandlets sind für PowerShell-Module wichtig:

```
Get-Module liefert eine Liste der installierten bzw.
importierten Module.
New-Module erzeugt ein neues sogenanntes dynamisches
Modul im Hauptspeicher.
```

```
Export-ModuleMember legt innerhalb eines Moduls fest, welche
Funktionen von außen verfügbar sein sollen.
Import-Module lädt ein Modul in die aktuelle PowerShell-
Sitzung. Nach dem Ende der Sitzung ist das Modul nicht
mehr verfügbar. Das Commandlet kann im Profilskript
verwendet werden.
Remove-Module entfernt ein Modul aus der aktuellen Sitzung.
```
###### 32.2 Modularchitektur

Ein Modul ist im installierten Zustand ein Dateisystemverzeichnis,
das die Moduldateien enthält. Systemmodule werden vom
Betriebssystem installiert unter

C:\Windows\System 32 \WindowsPowerShell\v1.0\Modules

Für alle Benutzer werden Module installiert unter

C:\Program Files\WindowsPowerShell\Modules

Benutzer können Module installieren unter

C:\Users\xy\Documents\WindowsPowerShell\Modules


```
TIPP: Die Umgebungsvariable PSModulePath liefert den
Pfad zu den Benutzermodulverzeichnissen. Man kann
diesen Pfad ändern oder auch weitere Pfade hinzufügen,
z.B.:
```
```
$env:psmodulepath = $env:psmodulepath + ";x:\WPSMod
ules"
```
Bild 32.1 Systemmodulverzeichnis und Inhalt des Moduls "ActiveDirectory"

Seit PowerShell Core 6.0 sind die Modulverzeichnisse geändert.
Im Standard sind folgende Modulverzeichnisse in
$env:psmodulepath hinterlegt:

Die Standardpfade in der PowerShell 7 unter Windows sind:

```
C:\Users\xy\Documents\PowerShell\Modules
C:\Program Files\PowerShell\Modules
C:\Program Files\PowerShell\ 7 \Modules
C:\Program Files\WindowsPowerShell\Modules
```

```
C:\WINDOWS\system 32 \WindowsPowerShell\v1.0\Modules
C:\WINDOWS\SysWOW 64 \WindowsPowerShell\v1.0\Modules
```
```
HINWEIS: Bitte beachten Sie aufgrund der geänderten
Pfade in der modernen gegenüber der klassischen
Windows PowerShell, dass installierte Module nur
automatisch in beiden Varianten der PowerShell
erscheinen, wenn Sie diese in einem gemeinsamen
Verzeichnis installieren. Sonst müssen Sie die Module
zweimal installieren, um Sie in beiden Varianten der
PowerShell nutzen zu können!
```
Die Modulpfade unter Linux sind:

```
/home/xy/.local/share/powershell/Modules
/usr/local/share/powershell/Modules
/opt/microso/powershell/ 7 - preview/Modules
```
###### 32.3 Aufbau eines Moduls

Ein Modul besitzt ein Modul-Manifest (.psd 1 - Datei), in dem die zu
dem Modul gehörenden Dateien festgelegt sind.


```
Listing 32.1 Modul-Manifest für das Modul "ActiveDirectory"
@{
GUID="{ 43 c15630-959c-49e4-a977-758c 5 cc 93408 }"
Author="Microsoft Corporation"
CompanyName="Microsoft"
ModuleVersion="1.0.0.0"
Description="Active Directory Module"
PowerShellVersion="2.0"
CLRVersion="2.0.50727"
NestedModules="Microsoft.ActiveDirectory.Management"
RequiredAssemblies="Microsoft.ActiveDirectory.Management"
TypesToProcess="ActiveDirectory.Types.ps 1 xml"
FormatsToProcess="ActiveDirectory.Format.ps 1 xml"
}
```
Mit dem Commandlet Test-ModuleManifest kann man prüfen, ob
ein Manifest korrekt ist und alle dort genannten Dateien in dem
Modulverzeichnis existieren.

Beispiel:

```
Test-ModuleManifest
c:\windows\system 32 \WindowsPowerShell\v1.0\Modules\ActiveD
irectory\ActiveDirectory.
psd 1
```

###### 32.4 Module aus dem Netz

###### herunterladen und installieren

###### mit PowerShellGet

Die Online-Sowarepaketverwaltung in PowerShell besteht aus
zwei Gebieten:

```
PowerShellGet: PowerShell-Module laden aus der
PowerShell Gallery und anderen Online-Repositories für
PowerShell-Erweiterungen. Dies wird in diesem Kapitel
besprochen.
Package Management (alias: OneGet): die allgemeine
Grundlage auch für die PowerShell-Get zum Herunterladen
beliebiger Sowarepakete. Dies wird aus systematischen
Gründen im Buchteil C im Kapitel "Sowareverwaltung"
näher besprochen.
```
Installation von PowerShellGet

Die in diesem Abschnitt beschriebenen Funktionen zum
Sowarepaketmanagement (automatisches Herunterladen und
Installieren von PowerShell-Modulen) sind enthalten in
PowerShell ab Version 5.0 in Form der Module
"PackageManagement" und "PowerShellGet". Sie sind als Add-
On verfügbar für PowerShell 3.0 und 4.0 mit der Erweiterung
"PackageManagement PowerShell Modules"
[https://www.powershellgallery.com/packages/PackageManage
ment/1.4.7]. Das heißt: Auf PowerShell 3.0 und 4.0 muss man die


Module "PackageManagement" und "PowerShellGet" manuell
einmalig installieren, damit man dann anschließend andere
PowerShell-Module automatisiert herunterladen und installieren
kann.

PowerShell Gallery

Die PowerShell Gallery ist ein Online-Repository für PowerShell-
Module, die die PowerShell um Commandlets,
Navigationsprovider und/oder Ressourcen für PowerShell
Desired State Configuration (DSC) erweitern. Die Website der
PowerShell Gallery ist [http://www.powershellgallery.com.](http://www.powershellgallery.com.) Auf der
Website kann man eine Liste der verfügbaren Module einsehen
oder nach Modulen suchen. Einen ATOM-Feed der Pakete findet
man unter [http://www.powershellgallery.com/api/v](http://www.powershellgallery.com/api/v) 2 /. PowerShell-
Gallery verwendet das gleiche Format wie das .NET-
Komponentenportal [http://www.nuget.org.](http://www.nuget.org.)

Zum Redaktionsschluss dieses Buchs bietet die PowerShell
Gallery 9651 Erweiterungsmodule an (siehe Abbildung).


Bild 32.2 [http://www.powershellgallery.com](http://www.powershellgallery.com)

Einen Filter für die moderne PowerShell gibt es nicht. Module, die
aber auf Linux und macOS laufen, laufen auch in der modernen
PowerShell auf Windows. Aber es kann auch Module für moderne
PowerShell auf Windows geben, die nicht auf anderen
Betriebssystemen laufen.


Bild 32.3 Filtern nach Modulen für Linux und macOS in [http://www.powershellgallery.com](http://www.powershellgallery.com)

Module in der PowerShell Gallery stellt nicht nur Microso
Module bereit; jedermann kann hier Module veröffentlichen.
Microso führt bei hochgeladenen Modulen einen einfachen
Sicherheitscheck aus [PSB7815]: Es wird ein Virenscanner
eingesetzt und einige Programmierrichtlinien werden mit dem
PowerShell Script Analyzer abgeprü.


```
ACHTUNG: Microso garantiert in keinster Weise, dass ein
heruntergeladenes Paket das tut, was es verspricht. Das
Modul kann fehlerha sein oder unerwünschte Dinge tun,
d. h., auch Schadsoware enthalten!
```
Commandlets für die Verwendung von

PowerShellGet

Zum Herunterladen oder Installieren von Modulen aus der
PowerShell Gallery verwendet man die Commandlets aus dem
Modul "PowerShellGet". Dies sind u. a.:

```
Find-Module Modulname: Online-Suche nach Modulen in der
PowerShell Gallery (oder anderen kompatiblen Websites)
Save-Module -Name Modulname -Path pfad: Lädt das Modul
aus dem Netz und speichert es in dem genannten Pfad,
ohne es in einem der PowerShell-Modulverzeichnisse zu
installieren. Wenn der angegebene Pfad ein PowerShell-
Modulverzeichnis ist, wird das Modul dadurch aber dennoch
installiert.
Install-Module -Name Modulname: Lädt das Modul herunter
und installiert es global in c:\Program
Files\WindowsPowerShell\Modules für alle Benutzer
(erfordert die Ausführung der PowerShell mit
Administratorrechten). Die Angabe -scope AllUsers ist
optional.
```

```
Install-Module Modulname -MinimumVersion 1.2.3 -
MaximumVersion 1.2.3: Lädt eine ganz genau bestimmte
Version des Moduls herunter (erfordert die Ausführung der
Power-Shell mit Administratorrechten)
Install-Module -Name Modulname -Scope CurrentUser: Lädt
das Modul herunter und installiert es lokal nur für den
aktuellen Benutzer in c:\Users\<name>\Documents\
WindowsPowerShell\Modules (erfordert KEINE
Administratorrechte!)
Install-Module -Name Modulname -Scope CurrentUser -
Force: wie vorheriges Beispiel. Das -Force installiert das
Modul aber auch dann, wenn es schon eine Version auf dem
System gibt.
```
Beispiel: Herunterladen und Installieren der PowerShell
Community Extension (PSCX) mit dem Modulnamen PSCX:

```
Install-Module PSCX
```
Wenn das Modul bereits in einer älteren Version vorliegt, müssen
Sie - force ergänzen:

```
Install-Module PSCX -force
```

Bild 32.4 Installation des Moduls "PSCX"

Falls das Modul Commandlets mit Namen implementiert, die
bereits in anderen Modulen vorhanden sind, müssen Sie -
AllowClobber ergänzen. Unter anderem bei den PSCX tritt dieses
Problem auf.

```
Install-Module PSCX -force -AllowClobber
```
Bild 32.5 Einsatz von -AllowClobber bei Install-Module am Beispiel der PSCX


```
HINWEIS: Zur Installation von Modulen sind im Standard
Administratorrechte erforderlich. Mit dem Zusatz -scope
CurrentUser wird ein Modul nur in das Modulverzeichnis
des angemeldeten Benutzers installiert und erfordert
keine Administratorrechte!
```
Module Browser für die ISE

Der Module Browser
[https://www.powershellgallery.com/packages/ISEModuleBrowser
Addon] ist ein Add-On für die PowerShell ISE auf Windows, mit
der man Module in einer ISE-Seitenleiste suchen und installieren
kann. Zudem zeigt der Module Browser die installierten Module
übersichtlich an. Hersteller der Erweiterung ist Microso.

Den Module Browser kann man so installieren:

```
Install-Module -Name ISEModuleBrowserAddon
```

Bild 32.6 Module-Browser-Erweiterung für die PowerShell ISE

Andere Modulquellen

Neben der PowerShell Gallery können auch andere Websites
PowerShell-Module bereitstellen. Eine solche Website ist


[http://www.Chocolatey.org.](http://www.Chocolatey.org.) Um von hier Module zu laden, muss man
den ATOM-Feed dieser Website zunächst registrieren:

```
Register-Packagesource -Name chocolatey -Provider PSModule
```
- Trusted -Location
[http://chocolatey.org/api/v](http://chocolatey.org/api/v) 2 / - Verbose

Danach wird diese Website bei Find-Module automatisch
berücksichtigt:

Bild 32.7 Das Modul "PSCX" wird nun in mehreren Quellen gefunden.

Wenn bei Find-Module ein Modul mehrfach gefunden wird und
man Install-Module ausführt, ohne anzugeben, welche der
Quellen verwendet werden soll, kommt es zum Fehler: "Unable
to install, multiple modules matched".

Bild 32.8 Fehler, wenn ein Modul mehrfach gefunden wird


In diesem Fall muss man das zu verwendende Repository explizit
angeben:

```
Install-Module -Name pscx -Repository PSGallery
```
Die verfügbaren PowerShell-Modul-Repositories listet man auf
mit:

```
Get-PSRepository
```

ACHTUNG: Bitte beachten Sie aber unbedingt die
Veröffentlichungsprozesse des jeweiligen Internetportals.
Bei [http://www.Chocolatey.org](http://www.Chocolatey.org) können Sie nachlesen: "How do I
know if I can trust the community feed (the packages on
this site?) Until we have package moderation in place, the
answer is that you can't trust the packages here."
[CHOCO1].

Das heißt: Die Soware, die Sie da herunterladen, kann
alles möglich tun und Schadsoware enthalten. Wenn Sie
auf diesem Wege Soware installieren, sind Sie nur
wenige Sekunden davon entfernt, dass eine Soware die
Kontrolle über Ihren PC übernimmt oder den Inhalt Ihres
Active Directory in die Welt verschickt.

Fans von Chocolatey argumentieren, dass viele
Chocolatey-Pakete ja o gar keine Binärdateien
enthalten, sondern nur einen Download von der
offiziellen Website des Herstellers anstoßen. Jedoch muss
man dazu erst mal das Chocolatey-Paket herunterladen
und es betrachten, ob es wirklich keine Binärdateien
enthält. Und der Nutzer muss sich dann auch sicher sein,
dass die Quelle auch die richtige ist. Manchmal
registrieren Bösewichte Domänen, die sich von den
echten nur durch einen Buchstaben unterscheiden, was
leicht übersehen wird.


```
Bild 32.9 Blick in ein Chocolatey-Paket, das Chrome bei Google
herunterlädt
```
###### 32.5 Module manuell installieren

Wenn PowerShellGet nicht verfügbar ist oder sein Einsatz nicht
gewünscht wird, kann der PowerShell-Nutzer die Module auch
wie bisher manuell installieren. Zum manuellen Installieren eines
PowerShell-Moduls kopiert man alle Dateien des Moduls in eines
der PowerShell-Modulverzeichnisse. Wichtig ist, dass die Dateien
nicht direkt in dem PowerShell-Modulverzeichnis liegen, sondern
in einem seiner Unterordner.

Falsch:

```
c:\windows\system 32 \WindowsPowerShell\v1.0\Modules\ActiveD
irectory.psd 1
```
Richtig:


```
c:\windows\system 32 \WindowsPowerShell\v1.0\Modules\ActiveD
irectory\ActiveDirectory.psd 1
```
```
TIPP: Omals werden PowerShell-Module durch Setup-
Routinen (z. B. die Windows Server Remote
Administration Tools) automatisch in die passenden
Verzeichnisse installiert.
```
###### 32.6 Doppeldeutige Namen

Es ist möglich, dass Sie verschiedene PowerShell-Erweiterungen
aktivieren, die gleichnamige Commandlets und Funktionen
definieren, denn es gibt keine zentrale Registrierungsstelle für
Commandlets und Funktionen.

Die ersten Versionen der PowerShell haben dann eine
Fehlermeldung geliefert beim Aufruf eines doppeldeutigen
Commandlets (siehe folgende Abbildung).

Bild 32.10 Ein Commandlet-Name ist doppelt vergeben.


Seit PowerShell 3.0 verhält sich PowerShell jedoch anders und
verwendet immer das zuletzt importierte Commandlet, außer bei
eingebauten Commandlets, die immer Vorrang haben (siehe
Abbildung mit dem Beispiel des Commandlets Get-Clipboard,
das es in PowerShell seit Version 5.0 gibt und in der Erweiterung
PSCX schon seit Langem).

Bild 32.11 Ein doppeltes Commandlet erkennen und nutzen

Die Lösung zur Unterscheidung zwischen den beiden
gleichnamigen Commandlets besteht darin, den Namen des
Moduls dem Commandlet voranzustellen (getrennt durch einen
Schrägstrich), z. B.:

```
PSCX\Get-Clipboard
```
und

```
Microsoft.PowerShell.Management\Get-Clipboard
```

###### 32.7 Auflisten der verfügbaren

###### Module

Der Befehl

```
Get-Module -listAvailable
```
zeigt alle auf dem System installierten Module. Zur Verwendung
eines Moduls muss dieses aber nicht nur installiert, sondern auch
in der aktuellen PowerShell-Sitzung importiert sein.

Get-Module ohne Parameter liefert eine Liste der aktuell
importierten Module.


Bild 32.12 Ausschnitt aus der Liste der 69 mit Windows 10 (Grundinstallation von
Windows 10 Enterprise) mitgelieferten PowerShell-Module – mit insgesamt 1404
Befehlen. In Windows 8.0 waren es 53 Module. In Windows 8.1 waren es 59 Module.


Bild 32.13 Durch die Installation der "Remote Server Administration Tools" erhöht
sich in Windows 10 die Zahl der PowerShell-Module.

###### 32.8 Importieren von Modulen

In PowerShell 2.0 war es notwendig, ein Modul explizit zu
importieren, bevor man einen Befehl daraus verwenden konnte.
Seit PowerShell-Version 3.0 macht dies die PowerShell bei Bedarf
automatisch. Die PowerShell zeigt sowohl in der ISE als auch in
der Konsole alle Commandlets und Funktionen in der
Vorschlagsliste und beim Aufruf von Get-Command bereits an. Der


eigentliche Import des Moduls erfolgt dann beim ersten Aufruf
eines Befehls aus einem Modul.

```
TIPP: Wenn Sie das automatische Laden von Modulen
stört, können Sie dies abschalten:
$PSModuleAutoLoadingPreference = "none"
```
Bild 32.14 Automatischer Modulimport in PowerShell (ab Version 3.0)

Weiterhin besteht die Möglichkeit, ein Modul explizit zu
importieren. Zum expliziten Importieren eines Moduls nutzt man
Import-Module gefolgt von dem Modulnamen (aus der Liste der
installierten Module), z. B.:

```
Import-Module ActiveDirectory
```
Eine Liste der neuen Befehle (im Fall des Active-Directory-Moduls
sind dies z. B. 135) kann man auf einfache Weise erhalten, da der


Typ System.Management.Automation.CmdletInfo, den GetCommand
liefert, seit PowerShell 2.0 ein neues Attribut ModuleName besitzt:

```
(Get-Command) | where { $_.ModuleName -eq "ActiveDirector
y" } | ft name, modulename,
pssnapin
```
Get-Command hat auch ein Filterattribut für Module, so dass man
alternativ schreiben kann:

```
Get-Command -module ActiveDirectory | ft name, modulename,
pssnapin
```
Bild 32.15 Eine Auswahl der Commandlets aus dem Active-Directory-Modul in
Windows Server 2012


Bild 32.16 Das Modul "ServerManager" umfasst nur drei Commandlets.

```
TIPP: Durch den Zusatz –verbose erhält man eine genaue
Liste der Auswirkungen des Moduls.
```
Bild 32.17 Parameter –verbose für Import-Module


TIPP: Ein Modul, das sich nicht in einem der
Standardverzeichnisse befindet, muss man unter Angabe
des ganzen Pfads importieren, z. B.:

```
Import-Module x:\ITVModule\Basismodul
```
Einen Modulimport kann man auch beim Start der
PowerShell an der Kommandozeile angeben, z. B.:

```
powershell.exe -noexit -command import-module
ActiveDirectory
```
Man kann auch anordnen, alle Systemmodule zu laden:

```
powershell.exe -NoExit -ImportSystemModules
```
HINWEIS: Da die Namen für Commandlets weltweit nicht
eindeutig vergeben werden, kann es doppelte Namen in
zwei Modulen geben. PowerShell verwendet dann immer
das zuletzt importierte Commandlet. PowerShell 1.0 gab
beim Import von Snap-Ins in dieser Situation einen Fehler
aus. Seit PowerShell 2.0 ist auch dieses Verhalten
geändert auf die Verwendung des zuletzt importierten
Commandlets.


```
ACHTUNG: Zu beachten ist, dass einige der von Microso
gelieferten Module auf 64-Bit-Systemen nur im 64-Bit-
Modus der PowerShell verfügbar sind. Die folgende
Abbildung beweist, dass einige der Module in der 32-Bit-
PowerShell nicht verfügbar sind.
```
```
Bild 32.18 Verfügbare Module auf einem Windows Server 2008 R 2 mit
installiertem PowerShellPack und WWWings_Commandlets (links: 32-Bit-
PowerShell, rechts: 64-Bit-PowerShell auf dem gleichen System)
```
###### 32.9 Entfernen von Modulen

Zum Entfernen eines Moduls aus der aktuellen PowerShell-
Sitzung kann man das Modul mit Remove-module entfernen, z. B.:

```
Remove-Module activedirectory
```

HINWEIS: Hinweise zum Erstellen von eigenen Modulen
finden Sie in Teil D "Profiwissen – Erweitern der
PowerShell".


33 Ausgewählte PowerShell-Erweiterungen

Einige wichtige am Markt verfügbare kostenlose und kostenpflichtige Commandlet-Erweiterungen,
die hier kurz vorgestellt werden, sind:
PowerShell-Module in Windows-Clients (seit Version 7) und Windows Server (seit Version 2008
R2)
PowerShell Community Extensions (PSCX) von Microso
PowerShell Pack von Microso
PowerShell Extensions von [http://www.IT-Visions.de](http://www.IT-Visions.de)
Die Firma Quest bietet Commandlets zum Active Directory Scripting, die auch auf älteren
Betriebssystemen laufen
Microso bietet u. a. Commandlets im Rahmen von Microso Exchange Server und System
Center Virtual Machine Manager
Die Erweiterung "PowerShell Management Library for Hyper-V" funktioniert auch für ältere
Hyper-V-Versionen
PSConfig bietet eine Sammlung von Commandlets in Form eines PowerShell-Moduls für
verschiedene Konfigurationsaufgaben in Windows

```
HINWEIS: Bitte beachten Sie, dass einige der hier vorgestellten Erweiterungen auf
PowerShell 6/7 nicht lauffähig sind.
```
33.1 PowerShell-Module in Windows 8.0 und Windows

Server 2012

Die folgende Tabelle zeigt die Anzahl der in Windows 8.0 und Windows Server 2012 mitgelieferten
Commandlets. Hier nicht aufgeführt sind die Standard-Commandlets der PowerShell 5.x.




33.2 PowerShell-Module in Windows 8.1 und Windows

Server 2012 R 2

Die folgende Tabelle zeigt die Anzahl der in Windows 8.1 und Windows Server 2012 R 2
mitgelieferten Commandlets. Nicht aufgeführt sind hier die Standard-Commandlets der Power-
Shell 5.x. In beiden Fällen geht es um eine Standardinstallation ohne Zusatzmodule.

```
Modulname Windows 8.1 Windows Server 2012 R 2
AppBackgroundTask 9
AppLocker 5 5
Appx 6 6
AssignedAccess 3
BestPractices 4
BitLocker 13
```

BitsTransfer 8 8

BranchCache 32 32

CimCmdlets 26 26

Defender 11

DirectAccessClientComponents 11 11

Dism 39 34

DnsClient 17 17

International 18 18

iSCSI 13 13

IscsiTarget 28

ISE 3 3

Kds 6 6

Microso.WSMan.Management 13 13

MMAgent 5 5

MsDtc 41 41

NetAdapter 64 64

NetConnection 2 2

NetEventPacketCapture 23 23

NetLbfo 13 13

NetNat 13 13

NetQos 4 4

NetSecurity 85 85

NetSwitchTeam 7 7

NetTCPIP 36 36

NetworkConnectivityStatus 4 4


NetworkSwitchManager 19 19

NetworkTransition 34 34

NFS 42

PackageManagement 13 13

PcsvDevice 5 5

PKI 17 17

PrintManagement 22 22

PSDesiredStateConfiguration 27 27

PSDiagnostics 10 10

PSReadline 6

PSScheduledJob 16 16

PSWorkflow 3 3

PSWorkflowUtility 1 1

RemoteDesktop 73

ScheduledTasks 19 19

SecureBoot 5 5

ServerCore 2

ServerManager 7

ServerManagerTasks 11

SmbShare 70 70

SmbWitness 5 5

SowareInventoryLogging 11

StartScreen 3 3

Storage 108 102

TLS 4 4


```
TroubleshootingPack 22
TrustedPlatformModule 1111
UserAccessLogging 14
VpnClient 1919
Wdac 1212
WebAdministration 80
Whea 2
WindowsDeveloperLicense 33
WindowsErrorReporting 33
WindowsSearch 22
```
33.3 PowerShell-Module in Windows 10 und Windows

Server 2019

Die folgende Tabelle zeigt die Anzahl der in Windows 10 und Windows Server 2019 (jeweils Stand
zum Redaktionsschluss dieses Buchs) mitgelieferten Module mit der Anzahl der Commandlets.
Nicht aufgeführt sind hier die Standard-Commandlets der PowerShell 5.x.





33.4 PowerShell Community Extensions (PSCX)

Die PowerShell Community Extensions (PSCX) mit zusätzlichen Commandlets und Providern gibt
es schon seit PowerShell 1.0. Die aktuelle Version zum Reaktionsschluss dieses Buchs ist die
Version 3.3.2 vom 17. 1. 2018 (es gibt hier also seit längerem keine neue Version mehr). Diese
Version läu auch unter PowerShell 7.x.
Während die PSCX früher ein PowerShell-Snap-In waren, sind sie nun ein PowerShell-Script-Modul
mit Namen "PSCX".

```
PowerShell Community Extensions
Hersteller: Microso/Open-Source-Community-Projekt
Preis: Kostenlos
URL: https://github.com/Pscx/Pscx
```
PSCX enthalten die in nachstehender Liste genannten Commandlets. Einige dieser Commandlets
gehören mittlerweile auch zur Grundausstattung der PowerShell, sodass es zu
Namensdoppelungen kommt.

```
TIPP: Um bei Namensdoppelungen das Commandlet aus den PSCX zu verwenden, müssen
Sie den Modulnamen PSCX voranstellen, z. B. PSCX\Get-Clipboard
```
```
Add-PathVariable
```

Clear-MSMQueue
ConvertFrom-Base 64
ConvertTo-Base 64
ConvertTo-MacOs 9 LineEnding
ConvertTo-Metric
ConvertTo-UnixLineEnding
ConvertTo-WindowsLineEnding
Convert-Xml
Disconnect-TerminalSession
Expand-Archive
Export-Bitmap
Format-Byte
Format-Hex
Format-Xml
Get-ADObject
Get-AdoConnection
Get-AdoDataProvider
Get-Clipboard
Get-DHCPServer
Get-DomainController
Get-DriveInfo
Get-EnvironmentBlock
Get-FileTail
Get-FileVersionInfo
Get-ForegroundWindow
Get-Hash
Get-HttpResource
Get-LoremIpsum
Get-MountPoint
Get-MSMQueue
Get-OpticalDriveInfo
Get-PathVariable
Get-PEHeader
Get-Privilege


Get-PSSnapinHelp
Get-ReparsePoint
Get-RunningObject
Get-ShortPath
Get-TerminalSession
Get-TypeName
Get-Uptime
Import-Bitmap
Invoke-AdoCommand
Invoke-Apartment
Join-String
New-Hardlink
New-Junction
New-MSMQueue
New-Shortcut
New-Symlink
Out-Clipboard
Ping-Host
Pop-EnvironmentBlock
Push-EnvironmentBlock
Read-Archive
Receive-MSMQueue
Remove-MountPoint
Remove-ReparsePoint
Resolve-Host
Send-MSMQueue
Send-SmtpMail
Set-BitmapSize
Set-Clipboard
Set-FileTime
Set-ForegroundWindow
Set-PathVariable
Set-Privilege
Set-VolumeLabel


Skip-Object
Split-String
Stop-TerminalSession
Test-AlternateDataStream
Test-Assembly
Test-MSMQueue
Test-Script
Test-UserGroupMembership
Test-Xml
Write-BZip 2
Write-Clipboard
Write-GZip
Write-Tar
Write-Zip
Add-DirectoryLength
Add-ShortPath
Dismount-VHD
Edit-File
Edit-HostProfile
Edit-Profile
Enable-OpenPowerShellHere
Get-ExecutionTime
Get-Help
Get-Parameter
Get-ScreenCss
Get-ScreenHtml
Get-ViewDefinition
help
Import-VisualStudioVars
Invoke-BatchFile
Invoke-Elevated
Invoke-GC
Invoke-Method
Invoke-NullCoalescing


```
Invoke-Ternary
less
Mount-VHD
New-HashObject
Out-Speech
QuoteList
QuoteString
Resolve-ErrorRecord
Resolve-HResult
Resolve-WindowsError
Set-LocationEx
Set-ReadOnly
Set-Writable
Show-Tree
Start-PowerShell
Stop- RemoteProcess
```
33.5 PowerShellPack

Das PowerShellPack ist eine massive Erweiterung zur Windows PowerShell, die Microso früher
unter [http://code.msdn.microso.com/PowerShellPack](http://code.msdn.microso.com/PowerShellPack) zum Download anbot. Leider hat Microso
dieses Installationspaket komplett aus dem Netz genommen. Die letzte erschienene Version
vom 16. 10. 2009 steht Lesern dieses Buchs über das Leser-Portal zur Verfügung – allerdings ohne
jegliche Garantie. Der Einsatz erfolgt auf eigene Verantwortung!
Ein kleiner Teil der Funktionen aus dem PowerShellPack gehört seit PowerShell-Version 3.0 zum
Standardlieferumfang der PowerShell.

```
PowerShellPack
Hersteller: Microso
Preis: Kostenlos
URL: http://www.IT-Visions.de/leser
```
PowerShellPack beinhaltet rund 800 neue Befehle, aufgeteilt in zehn Module.
Modul "WPK": Das größte Modul im PowerShellPack ermöglicht die Erstellung von grafischen
Benutzeroberflächen mit der Windows Presentation Foundation (WPF). WPK steht für WPF
PowerShell Kit.


IsePack: mehr als 35 Erweiterungen für die ISE, hauptsächlich Shortcuts
TaskScheduler: geplante Vorgänge einrichten und löschen.
ACHTUNG: Diese Funktionen gehören seit PowerShell-Version 3.0 in geänderter Form zum
Standard des Produkts.
FileSystem: Handhabung von ZIP-Dateien (z. B. New-Zip, Copy-ToZip), Laufwerken (Rename-
Drive), Dateisystemüberwachung (Start-FileSystemWatcher) und Suche nach doppelten
Dateien (Get-DuplicateFile)
DotNet: Zugriff auf die geladenen Typen, herausfinden, welche Befehle auf die Typen
angewendet werden können, sowie erarbeiten, wie PowerShell, DotNet und COM
zusammenarbeiten können
PSImageTools: Umwandeln, Drehen, Beschneiden bzw. Vergrößern oder Verkleinern von
Bildern sowie Zugriff auf die Metadaten
PSRSS: Befehle, um mit dem FeedStore für RSS-Feeds zu arbeiten
PSSystemTools: Auslesen von Betriebssystem- und Hardwareinformationen
PSUserTools: Zugriff auf die Benutzerkonten des lokalen Systems, Prüfung auf "elevation" und
Starten von Prozessen als Administrator
PSCodeGen: Erzeugen von PowerShell-Skripten sowie C#-Code und PInvoke-Aufrufe
Diese Module kann man einzeln importieren mit Import-Module oder man kann alle Module
zusammen importieren mit Import-Module PowerShellPack.
Zahlreiche der PowerShellPack-Commandlets werden in Teil C "PowerShell im Praxiseinsatz"
besprochen.
Die Module des PowerShellPack sind als Skript-Module implementiert, d. h., man kann sich die
Implementierung ansehen und davon lernen. Das PowerShellPack installiert sich in das
benutzerspezifische Modulverzeichnis.


Bild 33.1 Module des PowerShellPack im benutzerspezifischen Modulverzeichnis der PowerShell

Wenn Sie beim Importieren eines PowerShellPack-Moduls oder bei einzelnen Commandlets dieser
Erweiterung auf Fehlermeldungen stoßen, könnte das daran liegen, dass Sie die PowerShell
Community Extensions ebenfalls geladen haben. Leider sind diese beiden Erweiterungen nicht
vollkompatibel zueinander, weil sie gleichnamige Commandlets definieren.

33.6 [http://www.IT-Visions.de:](http://www.IT-Visions.de:) PowerShell Extensions

Die PowerShell-Erweiterungen, die von der Firma des Buchautors kostenlos bereitgestellt werden,
bieten Funktionen aus den Bereichen
Verzeichnisdienstverwaltung (Get-DirectoryEntry, Get-DirectoryChildren, Add-
DirectoryEntry, Remove-DirectoryEntry.. .),
Hardwareinformationen (Get-Processor, Get-Memorydevice, Get-NetworkAdapter, Get-
CDRomDrive, Get-VideoController, Get-USBController.. .),
Datenbankzugriff (Get-DBTable, Get-DBRow, Set-DBTable, Invoke-DBCommand, Get-DBConnection,..
.).
[http://www.IT-Visions.de:](http://www.IT-Visions.de:) PowerShell Extensions
Hersteller: [http://www.IT-Visions.de](http://www.IT-Visions.de)


```
Preis: Kostenlos
URL: http://www.dotnetframework.de/scripting/powershell/PowerShellCommandletExtensions.asp
```
Die Erweiterung kann als PowerShell-Modul oder Snap-In installiert werden.
Für die Snap-In-Installation muss installutil.exe verwendet werden:

```
installutil.exe ITVisions_PowerShell_Extensions.dll
```
Anschließend muss die Erweiterung in die Konsole geladen werden (dies am besten in Profil.ps 1
eintragen):

```
Add-PSSnapin ITVisions_PowerShell_Extensions
```
33.7 Quest Management Shell for Active Directory

Die Firma Quest stellt Commandlets zur Active-Directory-Verwaltung sowie eine angepasste
PowerShell-Konsole (Quest Management Shell for Active Directory) zur Verfügung. Der Vorteil
dieser Commandlets gegenüber dem Active-Directory-Modul von Microso ist, dass sie auch auf
älteren Betriebssystemen laufen. Das Active-Directory-Modul von Microso läu erst seit Windows
7 und Windows Server 2008 R2.

```
Quest Management Shell for Active Directory
Hersteller: Quest
Preis: Kostenlos
URL: http://www.quest.com/activeroles-server/arms.aspx
```
Die Quest-Commandlets können auch unabhängig von der Quest-Management-Konsole in die
normale PowerShell durch den Befehl Add-Pssnapin quest.activeroles.admanagement eingebunden
werden.


Bild 33.2 Quest Management Shell for Active Directory

Die Quest-Erweiterungen enthalten in der aktuellen Version folgende Commandlets:
Add-QADGroupMember
Connect-QADService
Disconnect-QADService
Get-QADComputer
Get-QADGroup
Get-QADGroupMember
Get-QADObject
Get-QADUser
New-QADGroup
New-QADObject
New-QADUser
Remove-QADGroupMember
Set-QADObject
Set-QADUser

33.8 Microso Exchange Server

Der Microso Exchange Server 2007 war das erste Microso-Produkt, das die PowerShell zur
Administration eingesetzt hat. Die mit dem Exchange Server mitgelieferte Exchange Management
Shell (eine angepasste Version der PowerShell) sowie zahlreiche zugehörige Commandlets
ermöglichen es, alle administrativen Aufgaben des Exchange Servers von der Kommandozeile
auszuführen.
Unter anderem folgende Commandlets werden dort bereitgestellt:


```
Get-ExchangeServer
Enable-Mailcontact
Enable-Mailbox
Disable-Mailbox
Get-Mailbox
Get-MailboxStatistics
New-SystemMessage
Get-Recipient
Get-UMMailbox
New-MailboxDatabase
New-StorageGroup
New-SendConnector
Suspend-Queue
Resume-Queue
Set-RecipientFilterConfig
New-JournalRule
```
Bild 33.3 Exchange Server Management Shell

Weitere Informationen finden Sie unter https://docs.microso.com/en-us/powershell/exchange/?
redirectedfrom=MSDN&view=exchange-ps.

33.9 System Center Virtual Machine Manager


System Center Virtual Machine Manager (SCVMM) ist ein Verwaltungswerkzeug für virtuelle
Systeme auf Basis von Virtual Server. Auch diese Verwaltungskonsole basiert im Hintergrund
komplett auf PowerShell-Commandlets, so dass alle Aktionen des SCVMM auch per Skript
ausgeführt werden können.
U. a. werden dort folgende Commandlets bereitgestellt:
New-VirtualNetworkAdapter
New-VirtualDVDDrive
New-HardwareProfile
Get-VirtualHardDisk
Add-VirtualHardDisk
New-VM
Get-VMHost
Get-FloppyDrive
Get-DVDDrive
u. a.

33.10 PowerShell Management Library for Hyper-V

(pshyperv)

Diese bei GitHub verfügbare Commandlets-Bibliothek bietet Commandlets zur Verwaltung von
Virtuellen Maschinen (VM) im Virtualisierungsdienst Hyper-V in Windows Server 2008. Seit
Windows 8 und Windows Server 2012 gibt es dafür ein Modul von Microso (siehe Kapitel "Hyper-
V")!

```
PowerShell Management Library for Hyper-V (pshyperv)
Hersteller: Open Source-Projekt
Preis: Kostenfrei
URL: http://github.com/gcbond/pshyperv
```
Die folgende Liste zeigt die verfügbaren Commandlets (Quelle:
[http://github.com/gcbond/pshyperv).](http://github.com/gcbond/pshyperv).)
Auffinden einer Virtuellen Maschine: Get-VM, Choose-VM, Get-VMHost
Zu einer Virtuellen Maschine verbinden: New-VMConnectSession
Verändern einer Virtuellen Maschine:
Get-VMState, Set-VMState, Convert-VMState,
Ping-VM, Test-VMHeartBeat, Shutdown-VM, Start-VM, Stop-VM, Suspend-VM


```
Get-VMKVP, Add-KVP, Remove-KVP, Get-VMJPEG
Sichern und Exportieren einer Virtuellen Maschine, Erstellen von Momentaufnahmen
(Snapshots):
Export-VM, Import-VM, Get-VMSnapshot, Choose-VMSnapshot, Apply-VMSnapshot, New-VMSnapshot,
Remove-VMSnapshot, Rename-VMSnapShot, Update-VMSnapshot, Get-VMSnapshotTree, Get-
VMBackupScript
Virtuelle Maschine erstellen und löschen:
New-VM, Remove-VM, Set-VM, Get-VMCPUCount, Set-VMCPUCount, GetVMMemory, Set-VMMemory, Set-
VMSerialPort
Laufwerk erstellen:
Get-VMDiskController
Add-VMSCSIController, Remove-VMSCSIcontroller
Get-VMDriveByController, Add-VMDRIVE, Remove-VMdrive
Get-VMDiskByDrive, Add-VMDISK, Set-VMDisk, Get-VMDisk
Get-VMFloppyDisk, Add-VMFloppyDisk
Add-VMNewHardDisk
Network Interface Cards erstellen:
Get-VMNic, List-VMNic, Choose-VMNIC, Add-VMNIC, Remove-VMNIC, Set-VMNICAddress, Set-
VMNICConnection, Get-VMNicport
Get-VMNicSwitch, Choose-VMSwitch, New-VMSwitchPort, Get-VMByMACaddress, Choose-
VMExternalEthernet
New- VMExternalSwitch, New- VMInternalSwitch, New- VMPrivateSwitch
Mit VHD-Dateien arbeiten:
Get-VHDDefaultPath, Get-VHDInfo, New-VHD, Compact-VHD, Test-VHD, Convert-VHD, Merge-VHD,
Mount-VHD, Unmount-VHD
```
33.11 PowerShell Configurator (PSConfig)

PSConfig bietet eine Sammlung von Commandlets in Form eines PowerShell-Moduls für
verschiedene Konfigurationsaufgaben in Windows. Die Bibliothek ist laut der Website
insbesondere gedacht für die Verwaltung von Windows-Server-Core-Installationen. Die
Commandlets sind aber auch nützlich auf vollständigen Windows-Server-Systemen.
Soware, Updates und Treiber:
Add-Driver, Get-Driver
Add-HotFix
Add-InstalledProduct, Get-InstalledProduct, Remove-InstalledProduct
Add-WindowsFeature, Get-WindowsFeature, Remove-WindowsFeature


Add-WindowsUpdate, Get-WindowsUpdateConfig, Set-WindowsUpdateConfig
Windows Firewall:
Get-FirewallConfig, Set-FirewallConfig, Get-FirewallProfile, Get-FireWallRule
Netzwerkkonfiguration:
Get-NetworkAdapter, Get-IpConfig, New-IpConfig, Remove-IpConfig, SetIpConfig
Lizenzierung/Aktivierung:
Get-Registration, Register-Computer
Auslagerungsdatei (Page File):
Get-ShutDownTracker, Set-ShutDownTracker
Remote Desktop:
Get-RemoteDesktopConfig, Set-RemoteDesktop
Sonstige:
Get-WinRMConfig
Rename-Computer
Set-iSCSIConfig
Set-RegionalConfig
Out-Tree
Test-Admin
Get-FirstAvailableDriveLetter

```
PowerShell Configurator (PSConfig)
Hersteller: Microso/James O'Neill
Preis: Kostenfrei
Bezug: Dieses Modul stand früher auf dem mittlerweile geschlossenen Codeplex-Portal zur
Verfügung; Sie finden es nun in den Downloads zu diesem Buch.
```

# 34 Delegierte

# Administration/Just

# Enough Administration

# (JEA)

Die Rechteverwaltung von Windows ist grobkörnig. Mit der
Windows PowerShell ist es möglich, Personen eingeschränkte
Administrationsrechte zu geben, die genau auf die Aufgaben
beschränkt sind, die die Person tatsächlich ausführen soll ("Least
Privilege"). Microso nennt dies Just Enough Administration
(JEA).

## 34.1 JEA-Konzept

JEA ist eng verbunden mit PowerShell Remoting. Ein
Administrator richtet auf einem Computer (meistens ein Server)
eine spezielle PowerShell-Sitzungskonfiguration (PowerShell
Session Configuration mit einem sogenannte "Restricted


Runspace") in einer Sitzungskonfigurationsdatei (.pssc) ein, die
festlegt, welche Module, welche Commandlets, welche
Funktionen und welche Sprachfeatures der PowerShell
verwendet werden dürfen.

Zudem legt er fest, unter welchem Benutzerkonto die
PowerShell-Sitzung ausgeführt werden soll und welche Benutzer
diese Sitzungskonfiguration verwenden dürfen. Die berechtigten
Benutzer können sich dann per PowerShell Remoting unter
Verwendung der Sitzungskonfiguration mit dem Computer
verbinden, unterliegen aber dort den konfigurierten
Restriktionen.

###### 34.2 PowerShell-

###### Sitzungskonfiguration erstellen

Das folgende PowerShell-Skript erstellt eine
Sitzungskonfigurationsdatei per New-PSSessionConfigurationFile
und registriert diese per Register-PSSessionConfiguration.

```
HINWEIS: Die Konfiguration einer Sitzung ist nur möglich,
wenn die PowerShell als Administrator gestartet wurde.
```
Im Rahmen der Sitzung ist der Nutzer der Sitzung nur auf
folgende Befehle beschränkt:

```
Status der Systemdienste auflisten mit Get-Service und in
gruppierter Form mit der benutzerdefinierten Funktion Get-
ServiceStatus
```

```
Systemdienste starten mit Start-Service und neu starten mit
Restart-Service
Benutzer anlegen in einer bestimmten Active Directory-
Organisationseinheit
Die benutzerdefinierte Funktion Get-SessionInfo liefert (zu
Diagnosezwecken) den Namen des Computers und des
agierenden Benutzers sowie die Zeit auf dem Computer
Die Sitzung erlaubt keine Sprachelemente der PowerShell-
Skriptsprache.
```
Die Sitzung konfiguriert das Konto "ADAdmin" als das Konto,
unter dem der Benutzer auf dem Zielsystem interagiert. Dieses
Konto ist Mitglied der Active Directory-Domänenadministratoren.

```
HINWEIS: Das Kennwort für das Konto "ADAdmin" ist im
Quellcode hinterlegt. Dies ist nicht Best Practices und
dient hier nur der Demonstration. In der Praxis sollten Sie
das Kennwort per Get-Credential interaktiv abfragen.
```

Listing 34.1 [2_Aufbauwissen\DelegierteAdministration\JEA_Einrichten.ps1]

```
#region ------------- Einstellungen
# Konfigurationsname
$name = "JEA_ServiceAdminAndNewUser"
# Speicherort der Sitzungskonfigurationsdatei
$sessionConfigFile = "x:\$name.pssc"
# RunAs-User
$benutzer = "ITV\ADAdmin"
$Kennwort = "geheim123" # hier nur im Beispiel im Skript a
bgelegt!
$kennwortSecure = ConvertTo-SecureString –String $Kennwort
```
- AsPlainText -Force
$cred = New-Object –TypeName System.Management.Automation.
PSCredential –ArgumentList
$benutzer, $kennwortSecure
# in der Praxis:
# $cred = Get-Credential "ITV\ADAdmin"
# Zugriffsrechte als SDDL
$Zugriffsrechte = "O:NSG:BAD:P(A;;GA;;;S-1-5-21-1973890784
-140174113-2732654181-1110)
(A;;GA;;;S-1-5-21-1973890784-140174113-2732654181-1265)S:P
(AU;FA;GA;;;WD)
(AU;SA;GXGW;;;WD)"
#endregion

```
#region -------------Funktionen für die Sitzungskonfigurat
ion
$func 1 = @{ name='Get-ServiceStatus'
ScriptBlock = { Get-Service | group status } }
```
```
$func 2 = @{ name='New-User'
```

ScriptBlock = {
function New-Password([int] $Anzahl)
{
$kennwort = ""
$zufallszahlgenerator = New-Object System.Random
for($i=0;$i -lt $Anzahl;$i++) { $kennwort = $kennw
ort
+[char]$zufallszahlgenerator.next(33,127) }
return $kennwort
}

function New-UserInternal($vorname,$Nachname)
{
$OU = "ou=TEST,dc=FBI,dc=net"
Write-host "Creating User $vorname $Nachname in $o
u..."
$verzeichnisname = $Vorname + "_" + $Nachname
$Anzeigename = $Vorname + " " + $Nachname
$SamAccountName = $Vorname.Substring(0,1) + $Nachnam
e

$kennwort = New-Password 13
$kennwortSecure = (ConvertTo-SecureString $Kennwort

- AsPlainText -force)
# Benutzer anlegen
$benutzerObj = New-ADUser -GivenName $vorname -Surna
me $Nachname -path $OU
- Name $verzeichnisname -SamAccountName $SamAccountName -Di
splayName $Anzeigename
- Enabled $true -ChangePasswordAtLogon $true -AccountPasswo
rd $kennwortSecure
- PassThru


Add-ADGroupMember -Identity "Angestellte" - Members
$SamAccountName
return $kennwort
}
New-UserInternal $args[ 0 ] $args[ 1 ]
} }

$func 3 = @{ name='Get-SenderInfo'
ScriptBlock = { $PSSenderInfo } }

$func 4 = @{ name='Get-SessionInfo'
ScriptBlock = {
"Rechnername: $([System.Environment]::MachineName)"
"Benutzername: $([System.Environment]::UserDomainname +
"\" + [System.
Environment]::Username)"
"Zeit: $(Get-Date)"
} }

#endregion

# Sitzungskonfigurationsdatei einrichten
New-PSSessionConfigurationFile -Path $sessionConfigFile -S
essionType
RestrictedRemoteServer `

- LanguageMode FullLanguage `
- ExecutionPolicy Restricted `
- VisibleCmdlets Get-Service,Start-Service,Restart-Service,
Get-ADUser,Write-Host `
- ModulesToImport ActiveDirectory `
- FunctionDefinitions $func1,$func2,$func3,$func 4 `


# Sitzungskonfiguration registrieren
Register-PSSessionConfiguration -Name $name -Path $session
ConfigFile `

- RunAsCredential $cred -SecurityDescriptorSddl $zugriffsre
chte -Force

Write-host "Sitzungskonfiguration ist eingerichtet!" - Fore
groundColor Yellow
# Sitzungskonfiguration abrufen
Get-PSSessionConfiguration -Name $name


```
TIPP: Die Zugriffsrechte auf die Sitzungskonfiguration
sind im Skript in Form der Security Descriptor Definition
Language (SDDL) angegeben. Sie müssen die SDDL nicht
manuell schreiben. Sie können den Parameter zunächst
weglassen und dann Set-PSSessionConfiguration -Name
JEA_ServiceAdminAndNewUser -Show SecurityDescriptorUI
ausführen. Dadurch zeigt die PowerShell einen Dialog, in
dem man die Nutzer festlegen kann. Nach dem Speichern
kann man die zugehörige SSDL abrufen per (Get-
PSSessionConfiguration -Name JEA_ServiceAdmin
AndNewUser).SecurityDescriptorSddl.
```
Eine Liste der registrierten Sitzungskonfigurationen liefert

```
Get-PSSessionConfiguration | ft name, guid, author
```

Mit Unregister-PSSessionConfiguration JEA* löscht man alle
Sitzungskonfigurationen, die mit dem Wort "JEA" beginnen.

###### 34.3 Sitzungskonfiguration nutzen

Eine berechtigte Person kann sich nun mit dem Rechner
verbinden unter Angabe des Namens der Sitzungskonfiguration:

```
"Sitzung einrichten mit der Konfiguration:"
$s = New-PSSession -ConfigurationName JEA_ServiceAdminAndN
ewUser -ComputerName
Server 123
Enter-PSSession $s
```
In der folgenden Abbildung läu die PowerShell unter dem Konto
"MMeier". Dieser Benutzer, der Mitglied der berechtigten
Benutzergruppe "Abteilungsleiter" ist, verbindet sich mit der
Sitzungskonfiguration JEA_ServiceAdminAndNewUser auf dem
Computer Server123. Dort agiert er unter dem Konto
ITV\ADAdmin. Ihm stehen allerdings nur sehr wenige Befehle zur
Verfügung: Neben den explizit konfigurierten Commandlets und
Funktionen sind es nur einige unschädliche Standardbefehle wie
Clear-Host, Get-Help, Select-Object, Measure-Object und Exit-
PSSession. Er kann mit der Funktion New-User unter Angabe von
Vor- und Nachname einen neuen Benutzer anlegen und erhält als
Antwort das zufällig generierte Kennwort. Der Versuch aber, das
Kennwort eines bestehenden Benutzers zu ändern, scheitert. Er
kann nicht einmal das generierte Kennwort in einer Variablen
ablegen, denn er darf keine PowerShell-Sprachfeatures nutzen!


Bild 34.1 Nutzung der Sitzungskonfiguration

###### 34.4 Delegierte Administration per

###### Webseite

Die Möglichkeiten der delegierten Administration in PowerShell
sind kommandozeilenbasiert. Dies ist für einige Benutzer
angemessen, aber andere Benutzer (z. B. Abteilungsleiter, die ein
Benutzerkonto für neue Mitarbeiter anlegen wollen) erwarten
eine grafische Benutzeroberfläche.


Die Firma [http://www.IT-Visions.de](http://www.IT-Visions.de) besitzt eine webbasierte Lösung
mit Namen "PowerShell Web Admin" für delegierte
Administration. Die berechtigten Benutzer können im Browser
aus einer Liste von ihnen zugewiesenen Skripten auswählen und
in einer vollautomatisch generierten Eingabemaske die
Parameter für das gewählte Skript erfassen. Die Benutzer
erhalten das Ergebnis wahlweise als Webseite oder per E-Mail.

Die Lösung basiert serverseitig auf Windows Server und Microso
.NET Framework. Clientseitig sind alle Betriebssysteme und
Gerätearten (auch SmartPhone und Tablet) unterstützt.

Die Lösung wird von [http://www.IT-Visions.de](http://www.IT-Visions.de) als auf den jeweiligen
Kunden angepasste Individuallösung inklusive jeweiligem
Quellcode vertrieben. Bei Interesse kontaktieren Sie bitte
kundenteam@IT-Visions.de oder Telefon 0201 649590 - 0 unter
Bezugnahme auf den PowerShell Web Admin.

Bild 34.2 PowerShell Web Admin von [http://www.IT-Visions.de](http://www.IT-Visions.de)


# 35 Tipps und Tricks zur

# PowerShell

## 35.1 Alle Anzeigen löschen

Clear-Host (Alias clear) löscht die Anzeige in der PowerShell-
Konsole, aber nicht die Be fehlsgeschichte. Alternativ dazu kann
man die statische Methode [System.Console]::Clear()
verwenden.

## 35.2 Befehlsgeschichte

Die PowerShell-Konsole speichert im Standard die letzten 64
eingegebenen Befehle in einer Befehlsgeschichte (History). Diese
lassen sich mit Get-History auflisten. Alternativ kann man die
Tastenkombination STRG+R oder die Pfeiltasten hoch/runter
verwenden, um zu vorher eingegebenen Befehlen zu kommen.

Durch den Parameter Count kann man eine bestimmte Anzahl von
Befehlen ansehen (jeweils die letzten n Befehle werden gezeigt).


```
Get-History -count 10
```
Einen Befehl aus der Befehlsgeschichte kann man gezielt über
die Position aufrufen:

```
Invoke-History 9
```
Die Anzahl der gespeicherten Befehle kann durch die Variable
$MaximumHistoryCount erhöht werden.

Die Befehlsgeschichte kann man exportieren, entweder als
Skriptdatei oder als XML-Datei. Eine Skriptdatei verwendet man,
wenn man die eingegebenen Befehle wieder automatisch in der
Reihenfolge der Eingabe ablaufen lassen will. Das XML-
Dateiformat verwendet man, wenn man die Befehlsgeschichte
einer früheren Sitzung wiederherstellen will, ohne die Befehle
gleichzeitig auch alle auszuführen.

```
Export als Skriptdatei
(.ps1)
```
```
Export als XML-
Format
```
Exportieren Get-History -Count^10 |

- format-table
commandline -
HideTableHeader | Out-
file

```
Get-History |
Export-ClixmlClixml
"x:\geschichte.xml"
```
```
"x:\meinSkript.ps1"
```
```
Importieren
(bzw.
Ausführen)
```
. "x:\meinSkript.ps1" Import-ClixmlClixml
    "x:\geschichte.xml"
    | Add–History


Mit Clear-History (seit PowerShell-Version 2.0) kann der Nutzer
die Befehlsliste löschen.

###### 35.3 System- und

###### Hostinformationen

Das Commandlet Get-Host und die eingebaute Variable $Host
liefern Informationen über die aktuelle PowerShell-Umgebung.
Sowohl das Commandlet als auch die Variable liefern die gleiche
Instanz der Klasse
System.Management.Automation.Internal.Host.InternalHost.
InternalHost enthält Informationen und erlaubt über sein
Unterobjekt UI.RawUI auch Modifikationen, z. B.:

```
$Host.Name: Name des Hosts (damit ist eine Unterscheidung
der Umgebung möglich, z. B. liefert hier der PowerShellPlus
Host einen anderen Wert als die normale PowerShell-
Konsole)
$Host.Version: Versionsnummer der Ablaufumgebung
$Host.UI.RawUI.WindowTitle = "Titel": Setzen der Titelzeile
des Fensters
$Host.UI.RawUI.ForeGroundColor =
[System.ConsoleColor]::White: Setzen der Textfarbe
$Host.UI.RawUI.BackgroundColor =
[System.ConsoleColor]::DarkBlue: Setzen der
Texthintergrundfarbe
```

Das folgende Beispiel erzeugt eine Kopfzeile, in der neben dem
Namen des aktuellen Benutzers auch gezeigt wird, ob dieser ein
Administrator ist oder nicht. Der Code eignet sich hervorragend
zur Verwendung im Profilskript.

```
Listing 35.1 Beispiel für ein Profilskript für eine aussagekräige Titelzeile
[2_Aufbauwissen/Profile/Profile_Title.ps1]
# PowerShell Profile Script
# Holger Schwichtenberg
```
```
# ------------- Window Title
```
```
$WI = [System.Security.Principal.WindowsIdentity]::GetCurr
ent()
$WP = New-Object System.Security.Principal.WindowsPrincipa
l($wi)
if ($WP.IsInRole([System.Security.Principal.WindowsBuiltIn
Role]::Administrator))
{
$Status = "[elevated user]"
}
else
{
$Status = "[normal User]"
}
```
```
$Host.UI.RawUI.WindowTitle = "PowerShell – " + [System.Env
ironment]::UserName + " "
+ $Status
```
Get-Culture (oder $Host.CurrentCulture) und Get-UICulture
(oder $Host.CurrentUI-Culture) liefern die Informationen über


die aktuelle Sprache auch einzeln in Form von Instanzen der
.NET-Klasse System. Globalization.CultureInfo. Get-Culture
bezieht sich auf die Ausgaben von Datum, Uhrzeit und
Währungen (vgl. regionale Einstellungen der Windows-
Systemsteuerung). Get-UICulture bezieht sich auf die Sprache
der Benutzeroberfläche. In der Regel sind zwar beide
Einstellungen gleich, ein Benutzer kann diese jedoch auch
abweichend festlegen.

Bild 35.1 Ausführung von Get-Host

###### 35.4 Anpassen der

###### Eingabeaufforderung (Prompt)

Die Anzeige, mit der die PowerShell zur Eingabe von Befehlen
auffordert, z. B. "PS c:\Users\ hs>", wird als "Prompt" bezeichnet.
Der Aufbau des Prompts ist nicht in der PowerShell-Konsole starr
festgelegt, sondern wird durch die eingebaute Funktion Prompt
erzeugt. Diese Funktion kann man abändern, z. B. so, dass die
aktuelle Uhrzeit als Eingabeaufforderung in gelb erscheint.


```
function prompt
{
Write-Host ("WPS $([System.DateTime]::Now.ToShortTimeS
tring())") - nonewline
```
- foregroundcolor Yellow
return " "
}

Die folgende Abbildung zeigt die Standardimplementierung der
Funktion Prompt und ihre Abänderungen. Die Funktion muss in
der PowerShell einfach nur definiert werden. Eine explizite
Ausführung ist nicht notwendig, damit sie wirkt.

Bild 35.2 Änderung der Eingabeaufforderung


```
ACHTUNG: Eine Funktion zum Zurücksetzen auf den alten
Wert gibt es nicht. Innerhalb einer PowerShell-Sitzung
bekommen Sie die normale Eingabeaufforderung nur
dann wieder, wenn Sie sich die alte Implementierung in
einer Variablen merken. Mit dem Ende der PowerShell-
Sitzung (Schließen der Konsole) ist das Überschreiben der
Prompt-Funktion aber wieder gelöscht. Wenn Sie die
Eingabeaufforderung für alle PowerShell-Sitzungen
ändern wollen, müssen Sie die eigene Prompt-Funktion in
die Profildatei eintragen (siehe nächstes Kapitel).
```
###### 35.5 PowerShell-Befehle aus

###### anderen Anwendungen heraus

###### starten

Es ist möglich, PowerShell-Befehle aus jeder beliebigen anderen
Anwendung heraus auszuführen, wenn die Anwendung erlaubt,
Windows-Prozesse zu starten. Die Windows-Anwendung
powershell.exe besitzt einen Parameter -Command, dem man eine
Befehlsfolge als Zeichenkette oder Skriptblock übergeben kann,
der direkt nach dem Start des PowerShell-Prozesses ausgeführt
wird.


Listing 35.2 [2_Aufbauwissen\TippsTricks\PowerShell-Befehle aus anderen
Anwendungen heraus starten.ps1]

```
# Ein einzelnes Commandlet als Zeichenkette
powershell.exe -Command "Add-Content w:\temp\log.txt -Valu
e ('Startzeit ' +
(Get-Date)) "
# Pipeline als Zeichenkette
powershell.exe -Command "'Startzeit ' + (Get-Date) | Add-C
ontent w:\temp\log.txt"
# Ein einzelnes Commandlet als Skriptblock
powershell.exe -Command { Add-Content w:\temp\log.txt -Val
ue ("Startzeit " +
(Get-Date)) }
# Pipeline als Skriptblock
powershell.exe -Command { 'Startzeit ' + (Get-Date) | Add-
Content w:\temp\log.txt }
# Mehrere Befehle als Skriptblock
powershell.exe -Command { $datum = Get-Date; $text = "Star
tzeit"; Add-Content w:\
temp\log.txt -Value ($text + " " + $datum) ; }
```
```
HINWEIS: Da -Command der Standardparameter ist, kann
man den Namen des Parameters auch weglassen:
powershell.exe "Add-Content w:\temp\log.txt -Value
('Startzeit ' + (Get-Date))"
Falls der auszuführende Befehl Anführungszeichen
erfordert, muss man dafür einfache Anführungszeichen
verwenden!
```

Mit dem Zusatz -noexit kann man verhindern, dass der
PowerShell-Prozess nach der Ausführung der Startbefehle
beendet wird.

```
powershell.exe -noexit -Command { $datum = Get-Date; $text
= "Startzeit"; Add-Content
w:\temp\log.txt -Value ($text + " " + $datum) }
```
Es ist auch möglich, aus einem PowerShell-Prozess heraus eine
PowerShell auszuführen. Dies kann Sinn machen, wenn man in
der 64-Bit-PowerShell eine 32-Bit-PowerShell benötigt, weil man
Bibliotheksbefehle (z. B. in COM-Komponenten) aufrufen will, die
64 Bit nicht unterstützen.

```
c:\Windows\syswow 64 \WindowsPowerShell\v1.0\powershell.exe
```
- Command { [System.
Environment]::Is 64 BitProcess | Add-Content w:\temp\log.txt
}

###### 35.6 ISE erweitern

Die PowerShell ISE bietet ein Objektmodell, um die
Benutzeroberfläche zu erweitern. Administratorrechte sind dazu
nicht erforderlich.

Das folgende Skript ergänzt einige Menüpunkte. Diesen
Skriptcode würde man in das Profilskript der ISE eintragen,
damit diese zusätzlichen Menüpunkte immer beim Start der ISE
direkt angelegt werden.


Listing 35.3 [2_Aufbauwissen\ISEErweitern\ISEErweitern.ps1]

```
# Befehl ohne Shortcut
$psise.CurrentPowerShellTab.ToolsMenu.Submenus.Add('Script
```
- Pfad', { $psise.
CurrentFile.FullPath }, $null)

```
# Befehl ohne Shortcut
$psise.CurrentPowerShellTab.AddOnsMenu.Submenus.Add('Scrip
t-Pfad', { $psise.
CurrentFile.FullPath }, $null)
```
```
# Befehl mit Shortcut ALT+T:
$psise.CurrentPowerShellTab.AddOnsMenu.Submenus.Add('Reged
it', { regedit.exe },
'ALT+T')
```
```
# Befehl mit Shortcut ALT+X:
$psise.CurrentPowerShellTab.AddOnsMenu.Submenus.Add('Alle
Tabs schließen', { $psise.
CurrentPowerShellTab.Files.Clear() }, 'ALT+X' )
```
```
# Untermenü mit zwei Befehlen:
$parent = $psise.CurrentPowerShellTab.AddOnsMenu.SubMenus.
Add('Links', $null, $null) $parent.Submenus.Add('www.dotne
t-doktor.de', { Start-Process http://www.dotnet-doktor.de },
'ALT+D' )
$parent.Submenus.Add('www.powershell-schulungen.de', { Sta
rt-Process http://www.powershell-
schulungen.de }, 'ALT+S' )
```

Bild 35.3 Neue Menüpunkte in der ISE

###### 35.7 PowerShell für

###### Gruppenrichtlinienskripte

Seit Windows 7 bzw. Windows Server 2008 R 2 gibt es bei den
Skripten in Gruppenrichtlinien die Möglichkeit, explizit
PowerShell-Skripte für folgende Fälle zu hinterlegen:

```
Systemstart (Computer Configuration/Windows
Settings/Scripts/Startup)
Systemende (Computer Configuration/Windows
Settings/Scripts/Shutdown)
Benutzeranmeldung (User Configuration/Windows
Settings/Scripts/Logon)
Benutzerabmeldung (User Configuration/Windows
Settings/Scripts/Logoff)
```

Die auszuführenden PowerShell-Skripte sind in den
entsprechenden Sysvol-Ordner der Domäne zu kopieren. Den
Pfad dahin findet man über die Funktion "Show Files" auf der
Registerkarte "PowerShell Scripts" der o. g.
Gruppenrichtlinieneinträge. Nach dem Ablegen der Skriptdateien
sind diese zusätzlich über "Add" in den Dialog einzubinden.
Dabei kann optional ein Parameter an das Skript übergeben
werden (siehe folgendes Bild).

Bild 35.4 Einbinden von PowerShell-Skripten in Gruppenrichtlinien


Das folgende Listing zeigt ein universell für alle vier Fälle
einsetzbares PowerShell-Skript, das bei Systemstart,
Systemende, Benutzeranmeldung und Benutzerabmeldung
einen Webservice informiert, der diese Information dann in einer
Datenbank protokolliert. Die optionale Protokollierung in eine
lokale Textdatei dient nur zur Diagnose, falls der Webservice
nicht aufgerufen werden kann. Die Art des Ereignisses wird als
Parameter übergeben und als $args[ 0 ] ausgelesen.


Listing 35.4 Protokollierungsskript, das im Rahmen der Gruppenrichtlinien
ausgeführt wird

```
### GPO-Protokoll-Skript
### (C) Dr. Holger Schwichtenberg 2014
```
```
$Version = "1.0"
$LogToFile = $false
```
```
## Protokollieren in w:\temp zur Diagnose (optional)
function Write-Log($text)
{
if (!$LogToFile) { return; }
$text = (Get-Date).ToString() + ": " + $text
Add-Content "w:\temp\GPO-Skript.txt" $text
}
```
```
$ereignis = $args[ 0 ]
Write-Log "GPO-Skript $Version Parameter: $ereignis"
Write-Log "MachineName=$([System.Environment]::MachineNam
e)"
Write-Log "UserName=$([System.Environment]::UserName)"
```
```
## Protokollieren über Webservice
function Log-Global([string] $Anwendung, [string] $teil,
[string] $ereignis, [string]
$Text, [string] $details, [int] $grad)
{
if ($Anwendung -eq "") { $anwendung = split-path $MyInvoca
tion.ScriptName -leaf }
$ws 2 = New-WebServiceProxy https://Server 113 /Log.svc - Use
DefaultCredential
```

$ws2.Write([System.Environment]::MachineName,$anwendung,$t
eil,$ereignis,$grad,$text,
$details,0,[System.Environment]::UserName)
}

$text = $ereignis

if ([String]::IsNullOrEmpty($ereignis)) { $ereignis = "unb
ekannt"; $text = "Aufruf
von GPO_Script.ps 1 ohne Parameter!" }

Write-Log "Webservice-Auruf ..."
try
{
# Grad: 1 = Information
Log-Global "MeineDomaene" ([System.Environment]::MachineNa
me) $ereignis $text "" 1
Write-Log "Webservice-Auruf: OK!"
}
catch
{
Write-log "Webservice-Auruf: Fehler: " + $error[ 0 ]
}


```
HINWEIS: PowerShell-Skripte in älteren
Betriebssystemen für Startup, Shutdown, Logon und
Logoff zu verwenden, ist nicht so schön: Hier können
PowerShell-Skripte nicht direkt ausgeführt werden,
sondern eine Batch-Datei (.bat) oder WSH-Datei (.vbs/.js)
muss verwendet werden, um die PowerShell selbst und
dann das Skript zu starten (vgl.
http://www.computerperformance.co.uk/powershell/powershell_
logon_script.htm).
```
###### 35.8 Einblicke in die Interna der

###### Pipeline-Verarbeitung

Wenn Sie genauer wissen wollen, wie der Pipeline Processor der
PowerShell arbeitet, weil etwas nicht so funktioniert, wie Sie es
erwarten, oder weil Sie einfach "wissbegierig" sind, dann können
Sie Trace-Command nutzen. Bei Trace-Command können Sie nach -
expression eine Pipeline angeben und dann sehen Sie sehr genau
(o viel zu genau), was passiert. Zu beachten sind insbesondere
die Stellen, wo eine Bindung von Parametern als erfolgreich,
"Successful", dokumentiert wird.

An dem folgenden Beispiel erkennt man, dass in der Pipeline

```
Get-ChildItem w:\temp -filter *.txt | select -First 1 | Ge
t-Content
```

die Übergabe zwischen Get-ChildItem und Select-Object über
den Parameter "InputObject" erfolgt, während Get-Content sich
nur für die Eigenscha "LiteralPath" interessiert und den Rest des
Objekts gar nicht erhält.

Bild 35.5 Beispiel für den Einsatz von TraceCommand


# C Teil C:

# PowerShell im

# Praxiseinsatz

Dieser Buchteil enthält zahlreiche praktische
Anwendungsbeispiele für die PowerShell. Die
Automatisierungslösungen sind gegliedert nach den
verschiedenen Windows-Bausteinen bzw. Zusatzprodukten, wie
Microso SQL Server und Microso Exchange Server.

```
HINWEIS: Bitte beachten Sie die Restriktionen der
modernen PowerShell (vgl. Kapitel "PowerShell 7 für
Windows, Linux und macOS"), die dazu führen, dass ein
Teil der hier dargestellten Lösungen nicht auf PowerShell
6/7 funktionieren können. Zudem sind viele Lösungen
Windows-spezifisch (z. B. Bitlocker, Active Directory,
Gruppenrichtlinien, IIS).
```

36 Dateisystem

Das Dateisystem kann über das PowerShell-Navigationsmodell mit dem Provider
"Filesystem" angesprochen werden. Die folgende Tabelle zeigt wichtige
Commandlets zur Arbeit mit dem Dateisystem sowie ähnliche Befehle in der
klassischen Windows-Konsole und der Unix-Shell "sh".

```
TIPP: Die PowerShell 7 ist bei den Dateisystemoperationen generell
deutlich schneller als Windows PowerShell 5.1, denn Microso hat die
Dateisystemoperationen in modernem .NET gegenüber dem klassischen
.NET Framework erheblich beschleunigt!
```

Tabelle 36.1 Wichtige Commandlets für die Arbeit mit dem Dateisystem

```
PowerShell-
Commandlet
```
```
PowerShell-
Alias
```
```
Befehl
Klassische
Windows-
Kommandozeile
```
```
Befehl Unix
Shell
```
```
Beschreibung
```
```
Clear-Item Cli –– Inhalt leeren
Copy-Item Cpi, cpp,
cp, copy
```
```
Copy cp Kopieren von
Elementen
Get-Content Gc Type cat Holt den
Inhalt
Get-Location Gl, pwd Pwd pwd Holt das
aktuelle
Verzeichnis
Move-Item Mi, move,
mv, mi
```
```
Move mv Bewegen von
Elementen
New-Item Ni (Für
Ordner:
Funktion
mkdir und
Alias md)
```
- (für Ordner:
md)
    - (für
    Ordner:
    mkdir)

```
Element
anlegen
```
```
Remove-Item Ri, rp, rm,
rmdir, del,
erase, rd
```
```
del, rd rm, rmdir Löschen von
Elementen
```
```
Rename-Item Rni, ren Rn ren Umbenennen
eines
Elements
Set-Content Sc (Umleitungen >)(Umleitungen
>) Festlegen desInhalts
```
```
Set-Item Si –– Inhalt
festlegen
Set-Location Sl, cd,
chdir
```
```
cd, chdir cd, chdir Setzt das
aktuelle
```

```
Verzeichnis
```
36.1 Laufwerke

Dieses Kapitel behandelt den Umgang mit Dateisystemlaufwerken.

36.1.1 Auflisten der Laufwerke

Für den Zugriff auf die Dateisystemlaufwerke hat man fünf Möglichkeiten:

```
Verwendung des Commandlets Get-PSDrive (Commandlet der PowerShell-
Version 1.0)
Statische Methode GetDrives() der .NET-Klasse System.IO.DriveInfo
Ermitteln der Instanzen der WMI-Klasse Win32_LogicalDisk
Verwendung des Commandlets Get-Disk (Commandlet von http://www.IT-Visions.de)
Get-LogicalDiskInventory (aus dem Modul "PSSystemTools", enthalten im
PowerShell-Pack). Dieses Commandlet verwendet Win32_LogicalDisk,
beschränkt sich aber auf den Laufwerkstyp 3 (lokale Laufwerke).
```
Eine Liste der Dateisystemlaufwerke erhält man von Get-PSDrive durch
Einschränkung auf den Provider "Filesystem":

```
Get-PSDrive -psprovider filesystem
```
Das Ergebnis sind Objekte des Typs System.Management.Automation.PSDriveInfo. Zu
den Eigenschaen dieser Klasse gehört auch Root, welches das Wurzelverzeichnis
zu jedem Laufwerk enthält.

```
ACHTUNG: Die PowerShell-Klasse PSDriveInfo enthält keine Informationen
über Größe und Füllstand der Laufwerke, da es sich um ein generisches
Konzept für alle Arten von Mengen handelt und solche Werte für einige
Laufwerke (z. B. Umgebungsvariablen) keinen Sinn machen würden.
```

Bild 36.1 Einsatz der Methode GetDrives()

36.1.2 Laufwerk anlegen

Die PowerShell ermöglicht das Anlegen logischer Laufwerke im Dateisystem, die
auf vorhandene Pfade abgebildet werden. Dazu kann New-PSDrive mit -PSProvider
FileSystem eingesetzt werden. Der Laufwerksname darf mehr als einen Buchstaben
umfassen.

Beispiel:

```
New-PSDrive -PSProvider FileSystem -name M -Root W:\data\marketing
```
Bild 36.2 Ausführung des obigen Beispiels

```
ACHTUNG: Zu beachten ist, dass die logischen Laufwerke nur innerhalb der
PowerShell sichtbar sind und an die PowerShell-Sitzung gebunden sind. Sie
werden nach dem Beenden der PowerShell-Konsole also wieder entfernt.
```
Das Commandlet Mount-SpecialFolder erstellt logische Laufwerke für alle
Windows-Sonderordner (System, Programs, MyComputer, MyMusic, Desktop etc.).


Die Liste aller Sonderordner erhält man mit

```
[Enum]::GetValues([Environment+SpecialFolder]) | foreach { "$_ = " + [Syst
em. Environment]::GetFolderPath($_) }
```
Bild 36.3 Liste der Sonderordner

Die nächste Abbildung zeigt die verfügbaren Laufwerke nach der Ausführung von
Mount-SpecialFolder.


Bild 36.4 Mount-SpecialFolder hat zahlreiche Laufwerke für Sonderordner angelegt, z. B. Desktop: und
Recent:.

36.1.3 Füllstand

Um den Füllstand der Dateisystemlaufwerke auszugeben, hat man vier
Möglichkeiten:

```
Attribut TotalFreeSpace in der .NET-Klasse System. IO.DriveInfo
Attribut Freespace in der WMI-Klasse Win32_LogicalDisk
Verwendung des Commandlets Get-Disk (Commandlet von http://www.IT-Visions.de),
das intern WMI verwendet
Verwendung des Commandlets Get-FreeDiskSpace aus dem Modul
"FileSystem" in dem PowerShellPack. Das Commandlet verwendet intern die
```

```
Leistungsindikatoren von Windows.
Listing 36.1 Auslesen des Füllstands von C unter Einsatz der .NET-Klasse System.IO.DriveInfo
$drive = New-Object System.IO.DriveInfo("C")
$drive.TotalFreeSpace
Listing 36.2 Auslesen des Füllstands von C unter Einsatz der WMI-Klasse Win32_LogicalDisk
Get-CimInstance Win32_Logicaldisk -Filter "DeviceID = 'c:'" | Select FreeS
pace
Listing 36.3 Auslesen des Füllstands aller Laufwerke unter Einsatz der WMI-Klasse Win32_ LogicalDisk
Get-CimInstance Win32_Logicaldisk | Select-Object deviceid,size,freespace
```
Das folgende Skript zeigt eine Möglichkeit, diese Daten besser formatiert
auszugeben:

```
Listing 36.4 Ausgabe des Füllstands der Laufwerke
[Freespace.ps1]
$Computer = "localhost"
$laufwerke = Get-CimInstance Win32_LogicalDisk -computer $computer
" Laufwerk Groesse(MB) Freier Platz(MB)"
ForEach ($laufwerk in $laufwerke)
{
" { 0 } {1,15:n} {2,15:n}" - f $laufwerk.DeviceID,
($laufwerk.Size/ 1 m), ($laufwerk.freespace/ 1 m)
}
```
Der Einsatz der WMI-Klasse Win32_LogicalDisk bietet zwei Vorteile:

```
Man kann selbst unter PowerShell-Version 1.0 entfernte Systeme abfragen
(siehe Beispiel).
Man kann auch gezielt mit Hilfe einer WQL-Abfrage filtern (siehe Beispiel).
Listing 36.5 Auslesen des Füllstands von Laufwerk C von einem entfernten Computer unter Einsatz der
WMI-Klasse Win32_LogicalDisk
Get-CimInstance Win32_logicaldisk -Filter "DeviceID = 'c:'" - Computer PC 17
1 | Select
DeviceID, FreeSpace
```

```
Listing 36.6 Ermitteln der Laufwerke mit wenig freiem Speicherplatz unter Einsatz einer WQL-Abfrage über
die WMI-Klasse Win32_LogicalDisk
([WMISearcher] "Select * from Win32_LogicalDisk where Freespace < 10000000
00").Get()
| Select DeviceID, FreeSpace
```
Mit Get-FreeDiskSpace kann man alle Laufwerke und einzelne Laufwerke auf dem
lokalen oder entfernten Computern abfragen. Eine Besonderheit ist, dass man eine
periodische Abfrage einrichten kann.

Bild 36.5 Ausgabe von GetFreediskSpace

```
Listing 36.7 Periodische Abfrage (alle 30 Sekunden) des freien Speichers auf Laufwerk C auf dem System
D 142
Get-FreeDiskSpace -drive c: - con -sampleinterval 30 - computername D 142
```
36.1.4 Laufwerksbezeichnungen

Zum Auslesen und Verändern der Laufwerksbezeichnungen kann man VolumeLabel
aus der Klasse DriveInfo verwenden.


```
Listing 36.8 Ändern der Laufwerksbezeichnung [ChangeVolumeLabel.ps1]
$drive = New-Object System.IO.DriveInfo("C")
"Alte Bezeichnung:" + $drive.VolumeLabel
$drive.VolumeLabel = "SYSTEM"
"Neue Bezeichnung:" + $drive.VolumeLabel
Alternativ kann man das Commandlet Set-Volumelabel aus den PSCX einsetzen
(wobei es noch kein Gegenstück "Get-VolumeLabel" gibt).
Set-VolumeLabel c: "Systemlaufwerk"
```
Ebenfalls kann man Rename-Drive aus dem FileSystem-Modul des PowerShellPack
einsetzen:

```
Rename-Drive t: "Systemlaufwerk"
```
36.1.5 Datenträger-GUID

An einigen Stellen spricht Windows bei Datenträgern in "GUID-Sprache", z. B. in
Windows Server Backup bei der Fehlermeldung "A volume ‚\\?\Volume{9048d 1 dc-
d 96 d-11df-8a68-0024e 85 f 2 e 7 a}\' in the list of volumes to include in the backup is
missing".

Die Frage ist, welches Laufwerk hier gemeint ist. Die GUID eines Datenträgers ist die
DeviceID, die man so ermittelt:

```
Get-Wmiobject -namespace root\cimv 2 - class Win32_Volume | select deviceid,
capacity
```
36.1.6 Netzlaufwerke

Informationen über die verbundenen Netzwerklaufwerke des angemeldeten
Benutzers liefert die WMI-Klasse Win32_MappedLogicalDisk:

```
Get-CimInstance Win32_MappedLogicalDisk | select caption, providername
```
36.2 Ordnerinhalte


Den Inhalt eines Dateisystemordners listet man mit Get-ChildItem (Alias: dir) auf.

Ohne Parameter listet Get-ChildItem den aktuellen Pfad auf. Man kann auch einen
Pfad explizit angeben:

```
Get-ChildItem x:\Scripte
```
Die Ergebnismenge besteht aus .NET-Objekten der Typen System. IO.DirectoryInfo
(für Unterverzeichnisse) und System. IO.FileInfo (für Dateien).

Performance-Vergleich

In Microsos PowerShell gibt es o mehrere Wege, um ein Ziel zu erreichen. Dabei
gibt es manchmal erhebliche Geschwindigkeitsunterschiede.

```
TIPP: Bei vielen Praxisszenarien des PowerShell-Einsatzes ist die
Geschwindigkeit in der PowerShell wenig relevant. Aber wenn es doch mal
relevant ist, lohnt sich eine Messung mit Measure-Command!
```
Dies möchte ich hier beispielha für Dateisystemoperationen aufzeigen. Zum
Auflisten nur von Unterverzeichnissen (Klasse System. IO.DirectoryInfo) innerhalb
von Verzeichnissen gibt mehrere Alternativen:

```
(new-object System.IO.DirectoryInfo c:\windows).GetDirectories()
dir c:\windows -Directory
dir c:\windows | where psiscontainer
dir c:\windows | where mode -like "*d*"
```
Auch zum Auflisten nur der Dateien (Klasse System. IO.FileInfo) innerhalb von
Verzeichnissen gibt mehrere Alternativen:

```
(new-object System.IO.DirectoryInfo c:\windows).GetFiles()
dir c:\windows -file
dir c:\windows | where psiscontainer -eq $false
dir c:\windows | where mode -notlike "*d*"
```
Wenn man die obigen vier Alternativen mit Measure-Command vergleicht (Code
siehe Ab bildung), kommt man zu den Ergebnissen der folgenden Abbildung (siehe
immer "TotalMilliseconds").


Klare Erkenntnisse sind dabei:

```
Die direkte Verwendung der .NET-Klassenbibliothek ist mit Abstand die
schnellste Lösung. Das war zu erwarten, denn die PowerShell-Commandlets
sind eine Abstraktion der .NET-Klassenbibliothek.
Dir ist ein Alias für Get-Childitem. Die direkte Verwendung von Get-Childitem
ergibt keinen messbaren Geschwindigkeitsunterschied.
Die PowerShell 7 ist bei den Dateisystemoperationen schneller als Windows
PowerShell 5.1, denn Microso hat die Dateisystemoperationen in modernem
.NET gegenüber dem klassischen .NET Framework erheblich beschleunigt!
```

Bild 36.6 Performancevergleich beim Auflisten von Unterverzeichnissen


Bild 36.7 Performancevergleich beim Auflisten von Dateien


Bild 36.8 Performancevergleich Windows PowerShell 5.1 mit PowerShell 7

36.2.1 Filtern nach Dateiname

Der Parameter -Filter beschränkt die Ausgabemenge auf Dateien mit einem
bestimmten Namensmuster:

```
Get-ChildItem x:\skripte -filter "*.ps1"
```
Alternativ kann man -include zum Filtern verwenden und dabei auch mehrere
Dateiextensionen angeben:

```
Get-ChildItem x:\skripte -include *.ps1,*.vbs
```
36.2.2 Rekursion

Das Commandlet arbeitet normalerweise nur auf der angegebenen
Verzeichnisebene. Es kann auch rekursiv die Unterordner durchsuchen:


```
Get-ChildItem x:\skripte -filter "*.ps1" - recurse
```
```
ACHTUNG: Seit PowerShell-Version 3.0 gibt es eine Verhaltensänderung:
Wenn -recurse angegeben ist und der Pfad nicht existiert, wird das ganze
übergeordnete Verzeichnis durchsucht. Der Befehl dir x:\Unsinn -recurse
```
- filter *.txt wird also sehr lange suchen, wenn es x:\Unsinn nicht gibt,
weil dann das ganze C-Laufwerk durchsucht wird.

36.2.3 Filtern nach Inhaltstyp

Zum Filtern nach Art des Inhalts (nur Unterverzeichnisse oder nur Dateien) musste
man bisher Where-Object einsetzen. Seit PowerShell-Version 3.0 gibt es dazu
Parameter in Get-ChildItem mit Namen -Directory und -File.

```
# Nur Unterverzeichnisse
Get-ChildItem x:\skripte | where-object { $_.psiscontainer }
# Nur Unterverzeichnisse neu seit PowerShell-Version 3.0
Get-ChildItem x:\skripte -Directory
```
```
# Nur Dateien
Get-ChildItem x:\skripte | where-object { - not $_.psiscontainer }
# Nur Dateien neu seit PowerShell-Version 3.0
Get-ChildItem x:\skripte -File
```
Das Filtern ist auch nachträglich über den Objekttyp möglich: System.
IO.DirectoryInfo (für Unterverzeichnisse) und System. IO.FileInfo (für Dateien).


```
Listing 36.9 \Einsatzgebiete\Dateisystem\Ordnerstatistik.ps 1
###########################################
# Ausgabe der Anzahl der Dateien und Ordner inkl. Unterordner in einem Pfa
d
# (C) Dr. Holger Schwichtenberg, http://www.IT-Visions.de
##########################################
```
```
function Get-OrdnerStatistik($ordner)
{
if (-not (Test-Path $ordner)) { "Ordner $($ordner) nicht gefunden!"; retur
n }
"Statistik für $($ordner):"
$alle = Dir $ordner -Recurse
$AngelegteDateien = ($alle | Where-Object { $_.GetType().FullName -like "*
File*"
}).Count
$AngelegteOrdner = ($alle | Where-Object { $_.GetType().FullName -like "*D
irectory*"
}).Count
"Anzahl Ordner: " + $AngelegteOrdner
"Anzahl Dateien: " + $AngelegteDateien
}
```
```
Get-OrdnerStatistik w:\temp
```
36.2.4 Filtern nach Dateiattributen

Auch die neue Einschränkungsmöglichkeit auf Dateiattribute seit PowerShell-
Version 3.0 ist sehr schön. Der folgende Befehl ermittelt alle Dateien ("nicht
Ordner"), die versteckt sind, die nur gelesen werden und die weder komprimiert
noch verschlüsselt sind.

```
Get-ChildItem c:\Windows\
```
- Attributes !Directory+Hidden+Readonly+!Compressed+!Encrypted

36.2.5 Praxistipp: Versteckte Dateien


Get-ChildItem (Alias: dir) listet im Standard keine versteckten Dateien auf! Dies
erfolgt nur, wenn der Parameter -force angegeben ist.

Im folgenden Skript wird ein Ordner mit drei Dateien angelegt. Eine Datei wird
versteckt. Der Befehl dir ohne - force findet dann nur noch zwei Dateien. Mit -
force sind es drei Dateien. Eine Liste der versteckten Dateien erhält man mit dem
Parameterwert -attributes Hidden.

```
Listing 36.10 Einsatzgebiete\Dateisystem\VersteckteDateien.ps 1
# Ordner mit drei Dateien anlegen
$pfad = "W:\projekte"
md $pfad
"irgendein Inhalt" | Set-Content "$pfad/datei1.txt"
"irgendein Inhalt" | Set-Content "$pfad/datei2.txt"
"irgendein Inhalt" | Set-Content "$pfad/datei3.txt"
```
```
# Ermitteln der Dateianzahl
(dir $pfad).count # 3
```
```
# Verstecken einer Datei
Set-ItemProperty $pfad/datei1.txt -name attributes -value ([System.
IO.FileAttributes]::Hidden)
(dir $pfad).count # 2
(dir $pfad -Force).count # 3
(dir $pfad -Attributes Hidden).Count # 1
```
36.2.6 Praxislösung: Ordnergröße ermitteln

Mit Measure-Object kann man Berechnungen über eine Objektmenge ausführen.
Der folgende Befehl zeigt die Anzahl der Dateien in X:\Skriptesowie die
Gesamtgröße aller Dateien, die Größe der größten und kleinsten Datei sowie die
Durchschnittsgröße.

```
Get-ChildItem x:\Skripte | Measure-Object -Property length -min -max -aver
age -sum
```
Mit dem folgenden Befehl erzeugt man eine Liste von großen Word-Dateien auf
dem Laufwerk "X" und seiner Unterverzeichnisse und exportiert eine Liste der
Namen und Größe sortiert nach Größe in eine CSV-Datei:


```
Get-ChildItem x:\ - filter *.doc | Where-Object { $_.Length -gt 40000 } | S
elect-
Object Name, Length | Sort-Object Length | export-csv p:\GrosseWordDateie
n.csv
```
- notype

Das -notype am Ende sorgt dafür, dass der Name der .NET-Klasse nicht exportiert
wird. Würde man den Namen exportieren, so könnte man später mit einem Import-
CSV die Daten wieder als Objekt-Pipeline weiterverarbeiten.

36.2.7 Praxislösung: Ordnerinhalte vergleichen

In der Praxis muss man o zwei Ordnerstrukturen miteinander vergleichen, zum
Beispiel, um eine erfolgreiche Kopie (etwa im Rahmen eines Backups oder einer
Replikation) oder mögliche Duplikate von Ordnerstrukturen zu erkennen. Das
folgende Skript verwendet das Commandlet Compare-Object, um zwei
Ordnerstrukturen miteinander zu vergleichen. Es kann zum Beispiel verwendet
werden, um zu erkennen, ob eine SysVol-Replikation zwischen zwei
Domänencontrollern funktioniert.


```
Listing 36.11 Einsatzgebiete\Dateisystem\OrdnerVergleichen.ps 1
#######################################
# PowerShell Script
# (C) Dr. Holger Schwichtenberg
# http://www.powershell-doktor.de
########################################
```
```
$path 1 = "\\DC 1 \sysvol"
$path 2 = "\\DC 2 \sysvol"
```
```
$ordner 1 = Get-ChildItem -Recurse -path $path 1
$ordner 2 = Get-ChildItem -Recurse -path $path 2
```
```
$ergebnis = Compare-Object -ReferenceObject $ordner 1 - DifferenceObject $or
dner 2
```
```
# Powershell packt Einzelobjekt automatisch aus Liste aus, das wollen wir
hier nicht!
if ($ergebnis -ne $null -and $ergebnis.Length -eq $null) { $ergebnis = ,
$ergebnis }
```
```
if ($ergebnis -eq $null)
{ Write-host "Ordner sind gleich!" - ForegroundColor Green }
else
{ Write-host ("Ordner sind NICHT gleich: " + ($ergebnis.Length) + " Unters
chiede!")
```
- ForegroundColor Red }

```
$result = [PSCustomObject]@{
Count = $ergebnis.Length
Details = $ergebnis
}
```
```
return $result
```
36.3 Dateieigenschaen verändern


Zum Ändern von Eigenschaen von Dateisystemeinträgen kann man auf die
Attribute der FileInfo- und DirectoryInfo-Objekte direkt schreibend zugreifen. Ein
expliziter Speichervorgang ist nicht vorgesehen.

Das folgende Beispiel zeigt, wie man das Erzeugungsdatum eines
Dateisystemordners nachträglich ändert und nachher überprü, ob es auch
wirklich geändert wurde.

Bild 36.9 Ändern von Attributen; in Dateisystemobjekten werden die Änderungen sofort wirksam.

Eine Alternative ist die Veränderung von Eigenschaen mit Set- ItemProperty. Mit
dem folgenden Befehl werden die in Attributes gespeicherten Bitflags gesetzt. Die
.NET-Klassenbibliothek definiert die möglichen Flags in der Aufzählung System.
IO.FileAttributes. Wichtig ist, dass die Elemente der Aufzählung wie statische
Mitglieder angesprochen (also mit dem ::-Operator) und mit einem binären
exklusiven Oder (-bxor) verknüp werden.

```
Set-ItemProperty daten.txt -name attributes -value ([System.
IO.FileAttributes]::ReadOnly -bxor [System.IO.FileAttributes]::Archive)
```
Manchmal möchte man Dateiattribute setzen oder entfernen und die bestehenden
Attribute unverändert lassen. Dies ist ebenfalls möglich mit den Bitoperationen der
PowerShell:


```
# Setze Readonly, lasse alle anderen Dateiattribute unverändert
$attr = (Get-ItemProperty w:\daten.txt -name attributes).attributes
Set-ItemProperty w:\daten.txt -name attributes -value ($attr -bor [System.
IO.FileAttributes]::ReadOnly)
# Entferne Readonly, lasse alle anderen Dateiattribute unverändert
$attr = (Get-ItemProperty w:\daten.txt -name attributes).attributes
Set-ItemProperty w:\daten.txt -name attributes -value ($attr -band (-bnot
[System.
IO.FileAttributes]::ReadOnly))
```
Die FileInfo-Klasse bietet Informationen über das Erstellungsdatum und das
Datum des letzten Zugriffs.

```
dir $dir | select name, creationtime, lastaccesstime, lastwritetime
```
Mit Set-FileTime (enthalten in den PSCX) kann man diese Daten manipulieren, z. B.
wenn man nicht möchte, dass jemand sieht, wie alt eine Datei wirklich ist.

```
Listing 36.12 Setzen aller Zeiten aller Dateien in einem Verzeichnis auf das aktuelle Datum und die
aktuelle Uhrzeit
[/Dateisystem/Filetime.ps1]
$dir = "w:\temp"
$time = [DateTime]::Now
dir $dir | Set-FileTime -Time $time -SetCreatedTime -SetModifiedTime
dir $dir | select name, creationtime, lastaccesstime, lastwritetime
```
36.4 Eigenschaen ausführbarer Dateien

Für ausführbare Dateien bieten die PSCX einige spezielle Commandlets an:

```
Test-Assembly: liefert true, wenn die Datei eine .NET-Assembly ist (nur
anwendbar auf Dateien des Typs .dll)
Get-FileVersionInfo: liefert Informationen über die Produkt- und Dateiversion
Get-PEHeader: liefert die Kopfinformationen des Portable-Executable-Formats
(PE) für beliebige ausführbare Dateien
Get-ExportedType: liefert für eine .NET-Assembly die Liste der von außen
instanziierbaren Klassen
```

Das folgende PowerShell-Skript ermittelt alle mit .NET geschriebenen ausführbaren
DLLs im Windows-Verzeichnis und zeigt zu diesen DLLs die Versionsinformationen
an.

```
Listing 36.13 Suche nach .NET-Assemblies
[/Dateisystem/AssemblySearch.ps1]
"Suche .NET-Assemblies"
```
```
foreach ( $d in (Get-ChildItem c:\Windows\ - include "*.dll" - recurse))
{
$a = $d.Fullname | Test-assembly -ErrorAction SilentlyContinue
if ($a) { Get-FileVersionInfo $d.Fullname }
}
```
Das folgende Beispiel liefert die PE-Kopfinformationen über den Windows Editor:

```
Get-PEHeader c:\windows\system 32 \notepad.exe
```

Bild 36.10 Ausgabe der PE-Kopfinformationen

Mit dem Commandlet Resolve-Assembly kann man prüfen, welche Versionen einer
.NET-Sowarekomponente vorliegen bzw. ob eine bestimmte Version vorliegt.

```
# Zeige alle Versionen dieser Assembly
Resolve-Assembly System.Windows.Forms
# Prüfe, ob Version 3.0 verfügbar ist
Resolve-Assembly System.Windows.Forms -Version 3.0.0.0
```

36.5 Kurznamen

Den Kurznamen einer Datei oder eines Ordners gemäß der alten 8 +3-Notation kann
man mit dem Commandlet Get-ShortPath aus den PSCX ermitteln.

Bild 36.11 Einsatz von Get-ShortPath

36.6 Lange Pfade

Die PowerShell hatte immer schon Probleme mit Dateisystempfaden, die länger als
260 Zeichen sind, weil es diese Restriktion im .NET Framework gab. Microso hat
dies erst mit .NET Framework 4.6.2 bzw. .NET Core 2.0 aufgehoben
[blogs.msdn.microso.com/jeremykuhne/ 2016 / 07 / 30 /net- 4 - 6 - 2 - and-long-paths-on-
windows- 10 ]. PowerShell Core 6/7 kommt nun mit Pfaden klar, die insgesamt
länger sind. Ein einzelner Teil eines Pfades ist jedoch weiterhin auf 251 Zeichen
begrenzt. Das folgende Skript läu unter PowerShell Core 6/7, nicht aber unter
Windows PowerShell.


```
Listing 36.14 [_Einsatzgebiete\Dateisystem\LangePfade.ps1]
# Das Beispiel legt einen Dateisystempfad an, der 777 Zeichen lang ist
$root = "x:\Pfadlängentest"
cls
cd c:\
if (Test-Path $root) { rd $root -Recurse -Force }
md $root
cd $root
$langerPfad = "x"* 251
md $langerPfad
cd "$langerPfad"
md $langerPfad
cd "$langerPfad"
"test" | Set-Content "$langerPfad.txt"
dir | foreach { $_.fullname, $_.fullname.length }
```
Unter Windows PowerShell scheitert schon der Befehl rd mit dem Fehler "Ein Teil
des Pfades konnte nicht gefunden werden.", wenn der lange Pfad schon existiert.

36.7 Dateisystemoperationen

Zum Kopieren von Dateien und Ordnern verwendet man Copy-Item (Aliase copy
oder cp):

```
Copy-Item w:\dokumente\profil.pdf w:\temp\profil_HSchwichtenberg.pdf
```
Zum Bewegen (Verschieben) von Dateisystemobjekten kommt Move-Item (Alias
move) zum Einsatz:

```
Move-Item w:\dokumente\profil.pdf w:\temp\profil_HSchwichtenberg.pdf
```
Das Commandlet Rename-Item (Alias Rename) benennt ein Dateisystemobjekt um:

```
Rename-Item profil.pdf profil_HS.pdf
```
Zum Löschen einer Datei oder eines Ordners verwendet man das Commandlet
Remove-Item (Alias del):


```
Remove-Item w:\demo\profil_HSchwichtenberg.pdf
```
```
TIPP: Für Remove-Item ist die Simulation des Verhaltens mit –whatif eine
sehr nützliche Funktion.
```
Bild 36.12 Einsatz von –whatif bei Remove-Item

36.8 Praxislösung: Dateien umorganisieren

Der folgende Befehl löscht alle Dateien, die älter als 30 Tage sind.

```
Listing 36.15 \3_Einsatzgebiete\Dateisystem\Ältere Dateien löschen.ps 1
Get-ChildItem w:\logs -recurse | Where-Object {($now – $_.LastWriteTime).D
ays -gt 30 }
| remove-Item
```
Manchmal will man aber nicht alle älteren Dateien löschen, sondern jede x-te
behalten. Das macht zum Beispiel Sinn bei regelmäßigen Backups. Das folgende
Skript löscht jede dritte Datei aus einem Verzeichnis, sofern die Datei älter ist als
100 Tage.


```
Listing 36.16 [\3_Einsatzgebiete\Dateisystem\Lösche jede x-te Datei.ps1]
$pfad = "w:\backups"
$x = 3
$before = (Get-Date).AddDays(-100)
```
```
Write-host "Vorher:" - ForegroundColor Cyan
$dateien = dir $pfad -File | where { $_.LastWriteTime -le $before }
Write-host $dateien.Count "Dateien"
```
```
$c = 0
foreach($d in $dateien)
{
$c++
if ($c % $x -eq 0 ) {
"Lösche " + $d.FullName
Remove-Item $d.FullName
}
else
{
"Skipped " + $d.fullname
}
}
```
```
Write-host "Nachher:" - ForegroundColor Cyan
$dateien = dir $pfad -File | where { $_.LastWriteTime -le $before }
Write-host $dateien.Count "Dateien"
```
Der folgende Befehl verschiebt alle Dateien, die kleiner als 10 KB sind.

```
Listing 36.17 [\3_Einsatzgebiete\Dateisystem\Kleine Dateien verschieben.ps1]
dir "w:\daten" | where length -le 10 KB | move-item -Destination "w:\temp
\zukleine
Dateien\$($_.name)"
```
Alle Textdateien, die in Unterordnern organisiert sind, sollen in einen einzigen
Ordner verschoben werden, d. h., die Sortierung soll aufgelöst werden.


```
Listing 36.18 [\3_Einsatzgebiete\Dateisystem\Dateien aus Ordnerordnern herausholen.ps1]
$quelle = "w:\Projekte\UnerwünschteUnterordnerstruktur"
$ziel = "w:\Projekte\FlacheOrdnerStruktur\"
if (-not (test-path $ziel)) { md $ziel }
dir $quelle -File -Recurse -filter *.txt | move-item -Destination $ziel -V
erbose
```
36.9 Praxislösung: Zufällige

Dateisystemstruktur erzeugen

Für Testzwecke von Dateisystemoperationen benötigt man häufig eine
Dateisystemstruktur mit Ordnern, Dateien und Unterordnern über mehrere
Ebenen. Nur ungerne verwendet man hier eine reale Dateisystemstruktur aus der
Praxis mit echten Daten. Das folgende Power-Shell-Skript erzeugt eine
Dateisystemstruktur mit einem zufälligen Aufbau, wobei der Aufbau über mehrere
Parameter steuerbar ist (siehe Listing). New-OrdnerStruktur ist eine rekursive
Funktion. Am Ende gibt es eine Auswertung der Anzahl der angelegten Ordner und
Dateien.


Listing 36.19 [Einsatzgebiete\Dateisystem\Erzeuge zufällige Verzeichnisstuktur.ps1]

```
###########################################
# Erzeugen einer zufälligen Dateisystemstruktur
# mit Dateien und Unterordnern auf mehreren Ebenen
# (C) Dr. Holger Schwichtenberg, http://www.IT-Visions.de
##########################################
```
```
$ErrorActionPreference = "stop"
$maxOrdner = 10 # Anzahl der Ordner der Startebene und maximale Anzahl pro
Unterebene
$maxDateien = 20 # Maximalanzahl der Dateien pro Ordner
$maxebenen = 5 # Maximalanzahl der Ebenen
$path = "w:\projekte" # Wurzelordner
```
```
Import-Module pscx # Wird für Get-LoremIpsum benötigt
```

function New-OrdnerStruktur($root,$name,$ebene){
if ($ebene -gt $maxebenen) { return; }

$path = [System.IO.Path]::Combine($root,$name)

#Ordner anlegen
md $path -ErrorAction SilentlyContinue | out-null

# Zufällige Anzahl von Dateien anlegen
$AnzDateien = (Get-Random -Minimum 0 - Maximum $maxDateien)

"Neuer Ordner: $path mit $AnzDateien Dateien"

for($j = 1; $j -lt $AnzDateien; $j++)
{
$dateiname = "$path/Datei$j.txt"
Get-LoremIpsum | set-content $dateiname
}

# Zufällige Anzahl von Ordnern anlegen
$AnzOrdner = (Get-Random -Minimum 0 - Maximum $maxOrdner)
for($i = 1; $i -lt $AnzOrdner; $i++)
{
New-OrdnerStruktur $path "$name-$i" $($ebene+ 1 )
}
}
# ------------------ Hauptprogramm

# Ziel erst mal bereinigen
if (test-path $path) {
remove-item "$path\*" - Recurse -force
}

# Wurzelordner anlegen
for ($i = 1; $i -le $maxordner; $i++)
{
new-OrdnerStruktur $path "Ordner $i" 1
}

$allesAngelegte = Dir $path -Recurse


```
"================ Ergebnis:"
$AngelegteDateien = ($allesAngelegte | Where-Object { $_.GetType().FullNam
e -like
"*File*" }).Count
$AngelegteOrdner = ($allesAngelegte | Where-Object { $_.GetType().FullName
```
- like
"*Directory*" }).Count
"Angelegte Dateien: " + $AngelegteDateien
"Angelegte Ordner: " + $AngelegteOrdner

36.10 Praxislösung: Leere Ordner löschen

Leere Ordner auf der Festplatte hat jeder. Man hat sie irgendwann einmal
(versehentlich) angelegt oder den Inhalt gelöscht, ohne den Ordner zu entfernen.

Das folgende PowerShell-Skript räumt auf. Es entfernt alle leeren
Dateisystemordner innerhalb des angebenen Pfads. Dabei wird der Pfad rekursiv
durchsucht. Der Parameter -force wird bei Get-ChildItem (Alias: dir) eingesetzt,
damit auch versteckte Dateien und Ordner erkannt und Ordner nicht gelöscht
werden, wenn nur versteckte Elemente enthalten sind.


Listing 36.20 Löschen leerer Dateisystemordner
[3_Einsatzgebiete\Dateisystem\Leere Ordner löschen.ps1]

```
###########################################
# Löschen leerer Dateisystemordner in einem Pfad (rekursiv)
# (C) Dr. Holger Schwichtenberg, http://www.IT-Visions.de
###########################################
```
```
# Eingabedaten
$root = "w:\projekte-archiv"
$logfile = "w:\temp\Leere Ordner löschen LOG.txt"
[int] $AnzGelöschteOrdner = 0
```
```
function Remove-EmptyFolder($path)
{
$list = dir -literalpath $path -File -Force
$Dateien = $list.count
$subdirs = dir -literalpath $path -Directory -Force
```

```
foreach($subdir in $subdirs)
{
$Dateien = $Dateien + (Remove-EmptyFolder $subdir.fullname)
}
Write-verbose "$path : $Dateien"
if ($Dateien -eq 0 )
{
Write-host "==> Lösche leeren Ordner: $path"
rd -literalpath $path -Recurse -Force
$global:AnzGelöschteOrdner++
Add-Content -Path $logfile -value $path
}
```
```
return $Dateien
}
```
```
## Hauptprogramm
Write-Host "Suche nach leerem Ordner im Pfad $root"
$subdirs = dir $root -Directory -Force
foreach($subdir in $subdirs)
{
Remove-EmptyFolder $subdir.fullname | out-null
}
Write-Host "$AnzGelöschteOrdner Ordner gelöscht!"
```
Die gelöschten Pfade werden in einer Protokolldatei notiert. Diese könnte bei
Bedarf später genutzt werden, um die Dateisystemordner wieder anzulegen. Dazu
würde der folgende Einzeiler reichen.

```
Get-Content "w:\temp\Leere Ordner löschen LOG.txt" | where { $_ - ne $null
} | foreach
{ md $_ - ErrorAction SilentlyContinue }
```
Der Parameter -ErrorAction wird auf SilentlyContinue gesetzt, da es sonst zu
Fehlermeldungen kommt, wenn ein übergeordneter Ordner bereits existiert, weil er
beim Anlegen eines Unterordners automatisch mit angelegt wurde.


36.11 Praxislösung: Geschwindigkeitsmessung

```
des Dateisystems (beim Kopieren von
Dateien)
```
Das folgende Skript misst die Dauer für das Kopieren einer (größeren) Datei auf ein
oder mehrere (Netz)Laufwerke. $iterations gibt an, wie o das Kopieren
wiederholt werden soll. Am Ende werden die Durchschnittswerte angezeigt.

```
HINWEIS: Für diesen Test verwenden Sie am besten nur Testdaten. Wie Sie
eine Testdatendatei in beliebiger Größe erzeugen, erfahren Sie im Kapitel
"Dokumente/Binärdateien".
```

Listing 36.21 [\Einsatzgebiete\Dateisystem\MeasureFileCopySpeed.ps1]

```
# Messe die Dauer für das Kopieren einer (größeren) Datei auf ein (Netz)La
ufwerk
# (C) Dr. Holger Schwichtenberg 2022
```
```
$datei = "w:\testdatei.bin"
$Ziele = "c:\temp", \\Server 123 \Backup\","\\Server 456 \backup"
$iterations = 10
```
```
if (-not (Test-Path $datei)) { Write-Warning "Datei existiert nicht!" ; re
turn }
```
```
foreach($z in $Ziele)
{
$summeW = 0
$summeR = 0
1..$iterations | % {
Write-Host "Run #$_" $z -ForegroundColor Yellow
$zieldatei = "$z\Datei.bin"
$w = Measure-Command { copy-item $datei $zieldatei }
Write-host "Write to $z = $($w.TotalMilliseconds) ms"
$r = Measure-Command { copy-item $zieldatei $datei }
Write-host "Read from $z = $($r.TotalMilliseconds) ms"
$summeW += $w.TotalMilliseconds
$summeR += $r.TotalMilliseconds
remove-item $zieldatei
}
Write-Host "$z Auswertung / Durchschnitte" - ForegroundColor Green
"Write to "+ $summeW/ 10 + " ms"
"Read from "+ $summeR/ 10 + " ms"
}
```

Bild 36.13 Ausgabe des obigen Skripts für das zehnmalige Kopieren einer 500 MB großen Datei zwischen den
lokalen Laufwerken t:\ und c:\

36.12 Einsatz von Robocopy in der PowerShell

Auch in Zeiten der PowerShell ist das klassische Kommandozeilenwerkzeug
robocopy.exe, das Microso früher als Teil des Windows Ressource Kits und seit
Windows Vista und Windows Server 2008 als Teil des Betriebssystems im
Verzeichnis c:\Windows\System 32 liefert, noch ein wertvolles Instrument, da sich
hiermit einige Operationen eleganter realisieren lassen als mit dem PowerShell-
Commandlets Copy-Item.


```
ACHTUNG: Copy-Item hat die unangenehme Eigenscha, sich beim
Kopieren eines Ordners anders zu verhalten in Abhängigkeit davon, ob der
Zielordner schon existiert.
Write-host "Zielordner nicht vorhanden" - ForegroundColor Yellow
$ziel = "w:\projekte1"
Copy-Item w:\projekte $ziel -Recurse
dir $ziel -Recurse
```
```
Write-host "Zielordner vorhanden" - ForegroundColor Yellow
$ziel = "w:\projekte2"
md $ziel
Copy-Item w:\projekte $ziel -Recurse
dir $ziel -Recurse
```
```
Die folgende Abbildung zeigt: Wenn man /Projekte nach /Projekte 2 kopiert,
was schon existiert, dann landet die Kopie in /Projekte2/Projekte statt – wie
man es erwarten würde – direkt in /Projekte2.
```
Robocopy besitzt zahlreiche Optionen, die man mit robocopy /? auflisten kann. Im
Folgenden werden diese Parameter verwendet:

```
/E Rekursiv für Unterverzeichnisse, auch wenn diese leer sind
/MOVE Verschieben
/MIR Spiegeln
/NFL Keine Dateiliste ausgeben
```

```
/NDL Keine Ordnerliste ausgeben
/NJH Keinen Auragskopf ausgeben
```
```
/NJS Keine Statistikausgabe am Ende
/LOG Senden der Textausgabe an eine Datei
/TEE Zusätzliche Bildschirmausgabe neben der Textausgabe an Datei
```
Beispiel 1 : Ordnerstruktur kopieren

```
Listing 36.22 [Einsatzgebiete\Dateisystem\Robocopy.ps1]
$Quellordner = "w:\projekte"
$Zielordner = "w:\projekte"
"------- Kopieren $Quellordner -> $Zielordner"
Get-OrdnerStatistik $Quellordner
robocopy $Quellordner $Zielordner /e /NFL /NDL /NJH
Get-OrdnerStatistik $Zielordner
```
Beispiel 2 : Ordnerstruktur verschieben

```
Listing 36.23 [Einsatzgebiete\Dateisystem\Robocopy.ps1]
$Quellordner = "w:\projekte"
$Zielordner = "w:\projekte-archiv"
Remove-Item $Ziel
