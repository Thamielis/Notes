
- [Tracing Your Way Through a Complex PowerShell Script](#tracing-your-way-through-a-complex-powershell-script)
  - [1. The Set-PSDebug cmdlet](#1-the-set-psdebug-cmdlet)
    - [1.1. Setting the Trace Level](#11-setting-the-trace-level)
    - [1.2. Performing a Basic Trace](#12-performing-a-basic-trace)
    - [1.3. Performing a More Comprehensive Trace](#13-performing-a-more-comprehensive-trace)
  - [2. Final Thoughts](#2-final-thoughts)
  - [3. FAQs](#3-faqs)
    - [3.1. Does PowerShell count blank lines when a trace reports line numbers?](#31-does-powershell-count-blank-lines-when-a-trace-reports-line-numbers)
    - [3.2. If a PowerShell Level 2 trace produces more detailed output, is there ever a reason to do a Level 1 trace?](#32-if-a-powershell-level-2-trace-produces-more-detailed-output-is-there-ever-a-reason-to-do-a-level-1-trace)
    - [3.3. How do you turn off a PowerShell trace when you are done?](#33-how-do-you-turn-off-a-powershell-trace-when-you-are-done)
    - [3.4. Does the PowerShell Set-PSDebug cmdlet support any other parameters?\*\*](#34-does-the-powershell-set-psdebug-cmdlet-support-any-other-parameters)
    - [3.5. What can you do if Set-PSDebug produces an output that scrolls off the PowerShell's screen?](#35-what-can-you-do-if-set-psdebug-produces-an-output-that-scrolls-off-the-powershells-screen)
  - [4. Resources](#4-resources)
    - [4.1. Microsoft's Official Documentation on the Set-PSDebug](#41-microsofts-official-documentation-on-the-set-psdebug)
    - [4.2. Tracing PowerShell Scripts](#42-tracing-powershell-scripts)
    - [4.3. Github PowerShell Resources](#43-github-powershell-resources)
    - [4.4. Finding the PowerShell Version](#44-finding-the-powershell-version)
    - [4.5. Malicious PowerShell Scripts](#45-malicious-powershell-scripts)
    - [4.6. Troubleshoot PowerShell Direct Errors](#46-troubleshoot-powershell-direct-errors)

# Tracing Your Way Through a Complex PowerShell Script

Over the years I've written some really **complicated PowerShell scripts**, both for personal use and for some articles I write on this [site][1]. Although these script types do have their place, they can be **exceedingly difficult to debug**. This can be especially true for scripts that contain **many functions or numerous logic gates**. 

You can make the debugging process easier by using the **Set-PSDebug command**. In this article, I want to show you a technique for tracing the script execution. 

First, let's start with the Set-PSDebug cmdlet and how we can use it to trace the script progress at runtime.

##  1. <a name='TheSet-PSDebugcmdlet'></a>The Set-PSDebug cmdlet

The [Set-PSDebug][2] cmdlet is simple to use, yet it can be an **invaluable tool** **for figuring out what your script is doing**. You can use it to understand why it isn't working in the way that you expected.

###  1.1. <a name='SettingtheTraceLevel'></a>Setting the Trace Level

When you use the Set-PSDebug cmdlet, you'll need to tell PowerShell what trace level you want to use. To specify the trace level, append the **\-Trace** parameter to the **Set-PSDebug cmdlet**. You'll also need to add the number reflecting the trace level you want to use. The **valid trace levels** include:

1.  Tracing is disabled.

1.  Basic tracing is used, and PowerShell displays the line number that is being executed.
2.  In addition to tracing line numbers, PowerShell also traces variable assignments, function calls. It also can call external scripts.

###  1.2. <a name='PerformingaBasicTrace'></a>Performing a Basic Trace

You can trace code from any PowerShell session. In this article, I'll be using **PowerShell ISE** because it makes the screen captures a little bit easier to follow. To perform a basic trace on a script:

1.  Open a **PowerShell session**.
2.  Run the following command: **Set-PSDebug -Trace 1**
3.  **Run your script**.

![Screenshot of a PowerShell window displaying in splitscreen an example script at the top, and the terminal with output at the bottom of a level 1 trace.](images/PowerShell_Trace.jpg)

The script is displayed in the top half of the window and a trace of the script is shown in the lower half.

If you look at the image above, you can see I've **opened a script in PowerShell ISE** and then performed a basic trace on that [script][3]. In this case, the script starts with a function, so the **first code line** to actually execute **is line 6**, which calls the function. Notice that the trace uses the word **Debug** to show debugger information. It then displays a line number; 6 in this case. The instruction is added to that line.

Once the function is called, the **trace reveals** that the script runs line 2; an opening bracket. Following this in line 3, a **Write-Host** statement is present. In line 4, a closing bracket. When line 3 executes, PowerShell doesn't show the line number and the command. It also **displays the output** that is being generated by that code line. Here the output is text that says, "I am doing something".

###  1.3. <a name='PerformingaMoreComprehensiveTrace'></a>Performing a More Comprehensive Trace

Now that you know how to perform a basic trace, let's perform a more comprehensive one. The **process is exactly the same as before**, except this time we will need to set the **trace level to 2**. Thus, the **Set-PSDebug** command will be: **Set-PSDebug -Trace 2**.

![Screenshot of a PowerShell window displaying in splitscreen an example script at the top, and the terminal with output at the bottom. Here the level 2 trace being run shows more detail in the terminal window than a level 1 trace.](images/PowerShell_Trace_2.jpg)

This is what a level 2 trace looks like.

You should note **I added two code lines** to the function; **lines 4 and 5**. Both lines here are variable assignments. They don't really do anything with regard to the script's functionality. I only put them there so I could **show you how variable assignment tracing works**.

That said, you'll notice trace information is like what you saw before. You'll also notice  this time, the **trace output lists the function that's running**. If you look down the trace results, you'll see PowerShell also returns the **$A variable**. You can see the [**variable assignment**][4] line and the value that was actually assigned to the variable.

##  2. <a name='FinalThoughts'></a>Final Thoughts

**Long or complex PowerShell scripts** can be **difficult to debug**, but the **Set-PSDebug cmdlet** makes the debugging process a lot easier. A **level 1 trace** shows you the sequence lines are run in, while a **level 2 trace** also shows you variable assignments and function calls.

##  3. <a name='FAQs'></a>FAQs

###  3.1. <a name='DoesPowerShellcountblanklineswhenatracereportslinenumbers'></a>Does PowerShell count blank lines when a trace reports line numbers?

Yes, **blank lines are treated as code lines**. If a [PowerShell][5] script contained four lines, a blank line, and then another code line, then the blank line would be considered line 5. This would never execute because it's blank and the last line is number 6.

###  3.2. <a name='IfaPowerShellLevel2traceproducesmoredetailedoutputisthereeverareasontodoaLevel1trace'></a>If a PowerShell Level 2 trace produces more detailed output, is there ever a reason to do a Level 1 trace?

Sometimes a **Level 2 PowerShell trace** can produce too [much information][6] to digest. If you're trying to keep things simple, then you might want to start with a Level 1 trace and see where that gets you.

###  3.3. <a name='HowdoyouturnoffaPowerShelltracewhenyouaredone'></a>How do you turn off a PowerShell trace when you are done?

Set the **trace level to 0** by typing: **Set-PSDebug -Trace 0** into your PowerShell [script][7]. This helps **stop unnecessary tasks** from running that reduce your systems performance. If you have **logging enabled** then stop your system being filled with log files by disabling these at the same time. Forgetting to disable logs can cause a **system down** event as your storage fills up.

###  3.4. <a name='DoesthePowerShellSet-PSDebugcmdletsupportanyotherparameters'></a>Does the PowerShell Set-PSDebug cmdlet support any other parameters?**

Use a **\-Step parameter** in PowerShell. Adding this to a **Set-PSDebug cmdlet** causes the script to **pause after each line** and wait for **permission to execute** the next code line. A **\-Strict** parameter forces [strict][8] mode to run. This stops the script if something falls to run correctly.

###  3.5. <a name='WhatcanyoudoifSet-PSDebugproducesanoutputthatscrollsoffthePowerShellsscreen'></a>What can you do if Set-PSDebug produces an output that scrolls off the PowerShell's screen?

If Set-PSDebub creates a long output, then you can dump the output to a file by creating a transcript. Unfortunately, you **can't change the terminal** to accommodate the output length. This is intentional and a part code, part security feature that PowerShell offers.

##  4. <a name='Resources'></a>Resources

###  4.1. <a name='MicrosoftsOfficialDocumentationontheSet-PSDebug'></a>Microsoft's Official Documentation on the Set-PSDebug

Get Microsoft's documentation for Set-PSDebug [here][9].

###  4.2. <a name='TracingPowerShellScripts'></a>Tracing PowerShell Scripts

Read more about tracing a script [here][10].

###  4.3. <a name='GithubPowerShellResources'></a>Github PowerShell Resources

Find GitHub resources related to PowerShell tracing [here][11].

###  4.4. <a name='FindingthePowerShellVersion'></a>Finding the PowerShell Version

Discover how to determine the PowerShell version you're using [here][12].

###  4.5. <a name='MaliciousPowerShellScripts'></a>Malicious PowerShell Scripts

Learn about malicious scripts [here][13].

###  4.6. <a name='TroubleshootPowerShellDirectErrors'></a>Troubleshoot PowerShell Direct Errors

Find out how to troubleshoot PowerShell Direct errors [here][14].

[1]: https://techgenix.com/powershell-storage-and-file-system-management-part1/
[2]: https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/set-psdebug?view=powershell-7.2
[3]: https://techgenix.com/best-editors-for-powershell-scripts/
[4]: https://techgenix.com/mapping-powershell-commands/
[5]: https://techgenix.com/powershellide-10-26/
[6]: https://techgenix.com/working-faster-smarter-powershell/
[7]: https://techgenix.com/how-to-schedule-powershell-scripts/
[8]: https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/set-strictmode?view=powershell-7.2
[9]: https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/set-psdebug?view=powershell-7.2
[10]: https://devblogs.microsoft.com/scripting/tracing-the-execution-of-a-powershell-script/
[11]: https://github.com/MicrosoftDocs/PowerShell-Docs/blob/staging/reference/7.1/Microsoft.PowerShell.Utility/Trace-Command.md
[12]: https://techgenix.com/overview-of-powershell-versions-and-how-to-check-what-version-you-have/
[13]: https://techgenix.com/malicious-powershell-scripts-evade-detection/
[14]: https://techgenix.com/powershell-direct-troubleshooting/
